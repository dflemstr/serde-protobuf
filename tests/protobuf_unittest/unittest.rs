// This file is generated by rust-protobuf 2.3.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct TestAllTypes {
    // message fields
    optional_int32: ::std::option::Option<i32>,
    optional_int64: ::std::option::Option<i64>,
    optional_uint32: ::std::option::Option<u32>,
    optional_uint64: ::std::option::Option<u64>,
    optional_sint32: ::std::option::Option<i32>,
    optional_sint64: ::std::option::Option<i64>,
    optional_fixed32: ::std::option::Option<u32>,
    optional_fixed64: ::std::option::Option<u64>,
    optional_sfixed32: ::std::option::Option<i32>,
    optional_sfixed64: ::std::option::Option<i64>,
    optional_float: ::std::option::Option<f32>,
    optional_double: ::std::option::Option<f64>,
    optional_bool: ::std::option::Option<bool>,
    optional_string: ::protobuf::SingularField<::std::string::String>,
    optional_bytes: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    optional_nested_message: ::protobuf::SingularPtrField<TestAllTypes_NestedMessage>,
    optional_foreign_message: ::protobuf::SingularPtrField<ForeignMessage>,
    optional_import_message: ::protobuf::SingularPtrField<super::unittest_import::ImportMessage>,
    optional_nested_enum: ::std::option::Option<TestAllTypes_NestedEnum>,
    optional_foreign_enum: ::std::option::Option<ForeignEnum>,
    optional_import_enum: ::std::option::Option<super::unittest_import::ImportEnum>,
    optional_string_piece: ::protobuf::SingularField<::std::string::String>,
    optional_cord: ::protobuf::SingularField<::std::string::String>,
    optional_public_import_message: ::protobuf::SingularPtrField<super::unittest_import_public::PublicImportMessage>,
    optional_lazy_message: ::protobuf::SingularPtrField<TestAllTypes_NestedMessage>,
    repeated_int32: ::std::vec::Vec<i32>,
    repeated_int64: ::std::vec::Vec<i64>,
    repeated_uint32: ::std::vec::Vec<u32>,
    repeated_uint64: ::std::vec::Vec<u64>,
    repeated_sint32: ::std::vec::Vec<i32>,
    repeated_sint64: ::std::vec::Vec<i64>,
    repeated_fixed32: ::std::vec::Vec<u32>,
    repeated_fixed64: ::std::vec::Vec<u64>,
    repeated_sfixed32: ::std::vec::Vec<i32>,
    repeated_sfixed64: ::std::vec::Vec<i64>,
    repeated_float: ::std::vec::Vec<f32>,
    repeated_double: ::std::vec::Vec<f64>,
    repeated_bool: ::std::vec::Vec<bool>,
    repeated_string: ::protobuf::RepeatedField<::std::string::String>,
    repeated_bytes: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    repeated_nested_message: ::protobuf::RepeatedField<TestAllTypes_NestedMessage>,
    repeated_foreign_message: ::protobuf::RepeatedField<ForeignMessage>,
    repeated_import_message: ::protobuf::RepeatedField<super::unittest_import::ImportMessage>,
    repeated_nested_enum: ::std::vec::Vec<TestAllTypes_NestedEnum>,
    repeated_foreign_enum: ::std::vec::Vec<ForeignEnum>,
    repeated_import_enum: ::std::vec::Vec<super::unittest_import::ImportEnum>,
    repeated_string_piece: ::protobuf::RepeatedField<::std::string::String>,
    repeated_cord: ::protobuf::RepeatedField<::std::string::String>,
    repeated_lazy_message: ::protobuf::RepeatedField<TestAllTypes_NestedMessage>,
    default_int32: ::std::option::Option<i32>,
    default_int64: ::std::option::Option<i64>,
    default_uint32: ::std::option::Option<u32>,
    default_uint64: ::std::option::Option<u64>,
    default_sint32: ::std::option::Option<i32>,
    default_sint64: ::std::option::Option<i64>,
    default_fixed32: ::std::option::Option<u32>,
    default_fixed64: ::std::option::Option<u64>,
    default_sfixed32: ::std::option::Option<i32>,
    default_sfixed64: ::std::option::Option<i64>,
    default_float: ::std::option::Option<f32>,
    default_double: ::std::option::Option<f64>,
    default_bool: ::std::option::Option<bool>,
    default_string: ::protobuf::SingularField<::std::string::String>,
    default_bytes: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    default_nested_enum: ::std::option::Option<TestAllTypes_NestedEnum>,
    default_foreign_enum: ::std::option::Option<ForeignEnum>,
    default_import_enum: ::std::option::Option<super::unittest_import::ImportEnum>,
    default_string_piece: ::protobuf::SingularField<::std::string::String>,
    default_cord: ::protobuf::SingularField<::std::string::String>,
    // message oneof groups
    pub oneof_field: ::std::option::Option<TestAllTypes_oneof_oneof_field>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum TestAllTypes_oneof_oneof_field {
    oneof_uint32(u32),
    oneof_nested_message(TestAllTypes_NestedMessage),
    oneof_string(::std::string::String),
    oneof_bytes(::std::vec::Vec<u8>),
}

impl TestAllTypes {
    pub fn new() -> TestAllTypes {
        ::std::default::Default::default()
    }

    // optional int32 optional_int32 = 1;

    pub fn clear_optional_int32(&mut self) {
        self.optional_int32 = ::std::option::Option::None;
    }

    pub fn has_optional_int32(&self) -> bool {
        self.optional_int32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_int32(&mut self, v: i32) {
        self.optional_int32 = ::std::option::Option::Some(v);
    }

    pub fn get_optional_int32(&self) -> i32 {
        self.optional_int32.unwrap_or(0)
    }

    // optional int64 optional_int64 = 2;

    pub fn clear_optional_int64(&mut self) {
        self.optional_int64 = ::std::option::Option::None;
    }

    pub fn has_optional_int64(&self) -> bool {
        self.optional_int64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_int64(&mut self, v: i64) {
        self.optional_int64 = ::std::option::Option::Some(v);
    }

    pub fn get_optional_int64(&self) -> i64 {
        self.optional_int64.unwrap_or(0)
    }

    // optional uint32 optional_uint32 = 3;

    pub fn clear_optional_uint32(&mut self) {
        self.optional_uint32 = ::std::option::Option::None;
    }

    pub fn has_optional_uint32(&self) -> bool {
        self.optional_uint32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_uint32(&mut self, v: u32) {
        self.optional_uint32 = ::std::option::Option::Some(v);
    }

    pub fn get_optional_uint32(&self) -> u32 {
        self.optional_uint32.unwrap_or(0)
    }

    // optional uint64 optional_uint64 = 4;

    pub fn clear_optional_uint64(&mut self) {
        self.optional_uint64 = ::std::option::Option::None;
    }

    pub fn has_optional_uint64(&self) -> bool {
        self.optional_uint64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_uint64(&mut self, v: u64) {
        self.optional_uint64 = ::std::option::Option::Some(v);
    }

    pub fn get_optional_uint64(&self) -> u64 {
        self.optional_uint64.unwrap_or(0)
    }

    // optional sint32 optional_sint32 = 5;

    pub fn clear_optional_sint32(&mut self) {
        self.optional_sint32 = ::std::option::Option::None;
    }

    pub fn has_optional_sint32(&self) -> bool {
        self.optional_sint32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_sint32(&mut self, v: i32) {
        self.optional_sint32 = ::std::option::Option::Some(v);
    }

    pub fn get_optional_sint32(&self) -> i32 {
        self.optional_sint32.unwrap_or(0)
    }

    // optional sint64 optional_sint64 = 6;

    pub fn clear_optional_sint64(&mut self) {
        self.optional_sint64 = ::std::option::Option::None;
    }

    pub fn has_optional_sint64(&self) -> bool {
        self.optional_sint64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_sint64(&mut self, v: i64) {
        self.optional_sint64 = ::std::option::Option::Some(v);
    }

    pub fn get_optional_sint64(&self) -> i64 {
        self.optional_sint64.unwrap_or(0)
    }

    // optional fixed32 optional_fixed32 = 7;

    pub fn clear_optional_fixed32(&mut self) {
        self.optional_fixed32 = ::std::option::Option::None;
    }

    pub fn has_optional_fixed32(&self) -> bool {
        self.optional_fixed32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_fixed32(&mut self, v: u32) {
        self.optional_fixed32 = ::std::option::Option::Some(v);
    }

    pub fn get_optional_fixed32(&self) -> u32 {
        self.optional_fixed32.unwrap_or(0)
    }

    // optional fixed64 optional_fixed64 = 8;

    pub fn clear_optional_fixed64(&mut self) {
        self.optional_fixed64 = ::std::option::Option::None;
    }

    pub fn has_optional_fixed64(&self) -> bool {
        self.optional_fixed64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_fixed64(&mut self, v: u64) {
        self.optional_fixed64 = ::std::option::Option::Some(v);
    }

    pub fn get_optional_fixed64(&self) -> u64 {
        self.optional_fixed64.unwrap_or(0)
    }

    // optional sfixed32 optional_sfixed32 = 9;

    pub fn clear_optional_sfixed32(&mut self) {
        self.optional_sfixed32 = ::std::option::Option::None;
    }

    pub fn has_optional_sfixed32(&self) -> bool {
        self.optional_sfixed32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_sfixed32(&mut self, v: i32) {
        self.optional_sfixed32 = ::std::option::Option::Some(v);
    }

    pub fn get_optional_sfixed32(&self) -> i32 {
        self.optional_sfixed32.unwrap_or(0)
    }

    // optional sfixed64 optional_sfixed64 = 10;

    pub fn clear_optional_sfixed64(&mut self) {
        self.optional_sfixed64 = ::std::option::Option::None;
    }

    pub fn has_optional_sfixed64(&self) -> bool {
        self.optional_sfixed64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_sfixed64(&mut self, v: i64) {
        self.optional_sfixed64 = ::std::option::Option::Some(v);
    }

    pub fn get_optional_sfixed64(&self) -> i64 {
        self.optional_sfixed64.unwrap_or(0)
    }

    // optional float optional_float = 11;

    pub fn clear_optional_float(&mut self) {
        self.optional_float = ::std::option::Option::None;
    }

    pub fn has_optional_float(&self) -> bool {
        self.optional_float.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_float(&mut self, v: f32) {
        self.optional_float = ::std::option::Option::Some(v);
    }

    pub fn get_optional_float(&self) -> f32 {
        self.optional_float.unwrap_or(0.)
    }

    // optional double optional_double = 12;

    pub fn clear_optional_double(&mut self) {
        self.optional_double = ::std::option::Option::None;
    }

    pub fn has_optional_double(&self) -> bool {
        self.optional_double.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_double(&mut self, v: f64) {
        self.optional_double = ::std::option::Option::Some(v);
    }

    pub fn get_optional_double(&self) -> f64 {
        self.optional_double.unwrap_or(0.)
    }

    // optional bool optional_bool = 13;

    pub fn clear_optional_bool(&mut self) {
        self.optional_bool = ::std::option::Option::None;
    }

    pub fn has_optional_bool(&self) -> bool {
        self.optional_bool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_bool(&mut self, v: bool) {
        self.optional_bool = ::std::option::Option::Some(v);
    }

    pub fn get_optional_bool(&self) -> bool {
        self.optional_bool.unwrap_or(false)
    }

    // optional string optional_string = 14;

    pub fn clear_optional_string(&mut self) {
        self.optional_string.clear();
    }

    pub fn has_optional_string(&self) -> bool {
        self.optional_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_string(&mut self, v: ::std::string::String) {
        self.optional_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_optional_string(&mut self) -> &mut ::std::string::String {
        if self.optional_string.is_none() {
            self.optional_string.set_default();
        }
        self.optional_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_optional_string(&mut self) -> ::std::string::String {
        self.optional_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_optional_string(&self) -> &str {
        match self.optional_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes optional_bytes = 15;

    pub fn clear_optional_bytes(&mut self) {
        self.optional_bytes.clear();
    }

    pub fn has_optional_bytes(&self) -> bool {
        self.optional_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.optional_bytes = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_optional_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.optional_bytes.is_none() {
            self.optional_bytes.set_default();
        }
        self.optional_bytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_optional_bytes(&mut self) -> ::std::vec::Vec<u8> {
        self.optional_bytes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_optional_bytes(&self) -> &[u8] {
        match self.optional_bytes.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional .protobuf_unittest.TestAllTypes.NestedMessage optional_nested_message = 18;

    pub fn clear_optional_nested_message(&mut self) {
        self.optional_nested_message.clear();
    }

    pub fn has_optional_nested_message(&self) -> bool {
        self.optional_nested_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_nested_message(&mut self, v: TestAllTypes_NestedMessage) {
        self.optional_nested_message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_optional_nested_message(&mut self) -> &mut TestAllTypes_NestedMessage {
        if self.optional_nested_message.is_none() {
            self.optional_nested_message.set_default();
        }
        self.optional_nested_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_optional_nested_message(&mut self) -> TestAllTypes_NestedMessage {
        self.optional_nested_message.take().unwrap_or_else(|| TestAllTypes_NestedMessage::new())
    }

    pub fn get_optional_nested_message(&self) -> &TestAllTypes_NestedMessage {
        self.optional_nested_message.as_ref().unwrap_or_else(|| TestAllTypes_NestedMessage::default_instance())
    }

    // optional .protobuf_unittest.ForeignMessage optional_foreign_message = 19;

    pub fn clear_optional_foreign_message(&mut self) {
        self.optional_foreign_message.clear();
    }

    pub fn has_optional_foreign_message(&self) -> bool {
        self.optional_foreign_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_foreign_message(&mut self, v: ForeignMessage) {
        self.optional_foreign_message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_optional_foreign_message(&mut self) -> &mut ForeignMessage {
        if self.optional_foreign_message.is_none() {
            self.optional_foreign_message.set_default();
        }
        self.optional_foreign_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_optional_foreign_message(&mut self) -> ForeignMessage {
        self.optional_foreign_message.take().unwrap_or_else(|| ForeignMessage::new())
    }

    pub fn get_optional_foreign_message(&self) -> &ForeignMessage {
        self.optional_foreign_message.as_ref().unwrap_or_else(|| ForeignMessage::default_instance())
    }

    // optional .protobuf_unittest_import.ImportMessage optional_import_message = 20;

    pub fn clear_optional_import_message(&mut self) {
        self.optional_import_message.clear();
    }

    pub fn has_optional_import_message(&self) -> bool {
        self.optional_import_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_import_message(&mut self, v: super::unittest_import::ImportMessage) {
        self.optional_import_message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_optional_import_message(&mut self) -> &mut super::unittest_import::ImportMessage {
        if self.optional_import_message.is_none() {
            self.optional_import_message.set_default();
        }
        self.optional_import_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_optional_import_message(&mut self) -> super::unittest_import::ImportMessage {
        self.optional_import_message.take().unwrap_or_else(|| super::unittest_import::ImportMessage::new())
    }

    pub fn get_optional_import_message(&self) -> &super::unittest_import::ImportMessage {
        self.optional_import_message.as_ref().unwrap_or_else(|| super::unittest_import::ImportMessage::default_instance())
    }

    // optional .protobuf_unittest.TestAllTypes.NestedEnum optional_nested_enum = 21;

    pub fn clear_optional_nested_enum(&mut self) {
        self.optional_nested_enum = ::std::option::Option::None;
    }

    pub fn has_optional_nested_enum(&self) -> bool {
        self.optional_nested_enum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_nested_enum(&mut self, v: TestAllTypes_NestedEnum) {
        self.optional_nested_enum = ::std::option::Option::Some(v);
    }

    pub fn get_optional_nested_enum(&self) -> TestAllTypes_NestedEnum {
        self.optional_nested_enum.unwrap_or(TestAllTypes_NestedEnum::FOO)
    }

    // optional .protobuf_unittest.ForeignEnum optional_foreign_enum = 22;

    pub fn clear_optional_foreign_enum(&mut self) {
        self.optional_foreign_enum = ::std::option::Option::None;
    }

    pub fn has_optional_foreign_enum(&self) -> bool {
        self.optional_foreign_enum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_foreign_enum(&mut self, v: ForeignEnum) {
        self.optional_foreign_enum = ::std::option::Option::Some(v);
    }

    pub fn get_optional_foreign_enum(&self) -> ForeignEnum {
        self.optional_foreign_enum.unwrap_or(ForeignEnum::FOREIGN_FOO)
    }

    // optional .protobuf_unittest_import.ImportEnum optional_import_enum = 23;

    pub fn clear_optional_import_enum(&mut self) {
        self.optional_import_enum = ::std::option::Option::None;
    }

    pub fn has_optional_import_enum(&self) -> bool {
        self.optional_import_enum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_import_enum(&mut self, v: super::unittest_import::ImportEnum) {
        self.optional_import_enum = ::std::option::Option::Some(v);
    }

    pub fn get_optional_import_enum(&self) -> super::unittest_import::ImportEnum {
        self.optional_import_enum.unwrap_or(super::unittest_import::ImportEnum::IMPORT_FOO)
    }

    // optional string optional_string_piece = 24;

    pub fn clear_optional_string_piece(&mut self) {
        self.optional_string_piece.clear();
    }

    pub fn has_optional_string_piece(&self) -> bool {
        self.optional_string_piece.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_string_piece(&mut self, v: ::std::string::String) {
        self.optional_string_piece = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_optional_string_piece(&mut self) -> &mut ::std::string::String {
        if self.optional_string_piece.is_none() {
            self.optional_string_piece.set_default();
        }
        self.optional_string_piece.as_mut().unwrap()
    }

    // Take field
    pub fn take_optional_string_piece(&mut self) -> ::std::string::String {
        self.optional_string_piece.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_optional_string_piece(&self) -> &str {
        match self.optional_string_piece.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string optional_cord = 25;

    pub fn clear_optional_cord(&mut self) {
        self.optional_cord.clear();
    }

    pub fn has_optional_cord(&self) -> bool {
        self.optional_cord.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_cord(&mut self, v: ::std::string::String) {
        self.optional_cord = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_optional_cord(&mut self) -> &mut ::std::string::String {
        if self.optional_cord.is_none() {
            self.optional_cord.set_default();
        }
        self.optional_cord.as_mut().unwrap()
    }

    // Take field
    pub fn take_optional_cord(&mut self) -> ::std::string::String {
        self.optional_cord.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_optional_cord(&self) -> &str {
        match self.optional_cord.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .protobuf_unittest_import.PublicImportMessage optional_public_import_message = 26;

    pub fn clear_optional_public_import_message(&mut self) {
        self.optional_public_import_message.clear();
    }

    pub fn has_optional_public_import_message(&self) -> bool {
        self.optional_public_import_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_public_import_message(&mut self, v: super::unittest_import_public::PublicImportMessage) {
        self.optional_public_import_message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_optional_public_import_message(&mut self) -> &mut super::unittest_import_public::PublicImportMessage {
        if self.optional_public_import_message.is_none() {
            self.optional_public_import_message.set_default();
        }
        self.optional_public_import_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_optional_public_import_message(&mut self) -> super::unittest_import_public::PublicImportMessage {
        self.optional_public_import_message.take().unwrap_or_else(|| super::unittest_import_public::PublicImportMessage::new())
    }

    pub fn get_optional_public_import_message(&self) -> &super::unittest_import_public::PublicImportMessage {
        self.optional_public_import_message.as_ref().unwrap_or_else(|| super::unittest_import_public::PublicImportMessage::default_instance())
    }

    // optional .protobuf_unittest.TestAllTypes.NestedMessage optional_lazy_message = 27;

    pub fn clear_optional_lazy_message(&mut self) {
        self.optional_lazy_message.clear();
    }

    pub fn has_optional_lazy_message(&self) -> bool {
        self.optional_lazy_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_lazy_message(&mut self, v: TestAllTypes_NestedMessage) {
        self.optional_lazy_message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_optional_lazy_message(&mut self) -> &mut TestAllTypes_NestedMessage {
        if self.optional_lazy_message.is_none() {
            self.optional_lazy_message.set_default();
        }
        self.optional_lazy_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_optional_lazy_message(&mut self) -> TestAllTypes_NestedMessage {
        self.optional_lazy_message.take().unwrap_or_else(|| TestAllTypes_NestedMessage::new())
    }

    pub fn get_optional_lazy_message(&self) -> &TestAllTypes_NestedMessage {
        self.optional_lazy_message.as_ref().unwrap_or_else(|| TestAllTypes_NestedMessage::default_instance())
    }

    // repeated int32 repeated_int32 = 31;

    pub fn clear_repeated_int32(&mut self) {
        self.repeated_int32.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_int32(&mut self, v: ::std::vec::Vec<i32>) {
        self.repeated_int32 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_int32(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.repeated_int32
    }

    // Take field
    pub fn take_repeated_int32(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.repeated_int32, ::std::vec::Vec::new())
    }

    pub fn get_repeated_int32(&self) -> &[i32] {
        &self.repeated_int32
    }

    // repeated int64 repeated_int64 = 32;

    pub fn clear_repeated_int64(&mut self) {
        self.repeated_int64.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_int64(&mut self, v: ::std::vec::Vec<i64>) {
        self.repeated_int64 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_int64(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.repeated_int64
    }

    // Take field
    pub fn take_repeated_int64(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.repeated_int64, ::std::vec::Vec::new())
    }

    pub fn get_repeated_int64(&self) -> &[i64] {
        &self.repeated_int64
    }

    // repeated uint32 repeated_uint32 = 33;

    pub fn clear_repeated_uint32(&mut self) {
        self.repeated_uint32.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_uint32(&mut self, v: ::std::vec::Vec<u32>) {
        self.repeated_uint32 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_uint32(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.repeated_uint32
    }

    // Take field
    pub fn take_repeated_uint32(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.repeated_uint32, ::std::vec::Vec::new())
    }

    pub fn get_repeated_uint32(&self) -> &[u32] {
        &self.repeated_uint32
    }

    // repeated uint64 repeated_uint64 = 34;

    pub fn clear_repeated_uint64(&mut self) {
        self.repeated_uint64.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_uint64(&mut self, v: ::std::vec::Vec<u64>) {
        self.repeated_uint64 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_uint64(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.repeated_uint64
    }

    // Take field
    pub fn take_repeated_uint64(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.repeated_uint64, ::std::vec::Vec::new())
    }

    pub fn get_repeated_uint64(&self) -> &[u64] {
        &self.repeated_uint64
    }

    // repeated sint32 repeated_sint32 = 35;

    pub fn clear_repeated_sint32(&mut self) {
        self.repeated_sint32.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_sint32(&mut self, v: ::std::vec::Vec<i32>) {
        self.repeated_sint32 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_sint32(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.repeated_sint32
    }

    // Take field
    pub fn take_repeated_sint32(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.repeated_sint32, ::std::vec::Vec::new())
    }

    pub fn get_repeated_sint32(&self) -> &[i32] {
        &self.repeated_sint32
    }

    // repeated sint64 repeated_sint64 = 36;

    pub fn clear_repeated_sint64(&mut self) {
        self.repeated_sint64.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_sint64(&mut self, v: ::std::vec::Vec<i64>) {
        self.repeated_sint64 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_sint64(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.repeated_sint64
    }

    // Take field
    pub fn take_repeated_sint64(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.repeated_sint64, ::std::vec::Vec::new())
    }

    pub fn get_repeated_sint64(&self) -> &[i64] {
        &self.repeated_sint64
    }

    // repeated fixed32 repeated_fixed32 = 37;

    pub fn clear_repeated_fixed32(&mut self) {
        self.repeated_fixed32.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_fixed32(&mut self, v: ::std::vec::Vec<u32>) {
        self.repeated_fixed32 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_fixed32(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.repeated_fixed32
    }

    // Take field
    pub fn take_repeated_fixed32(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.repeated_fixed32, ::std::vec::Vec::new())
    }

    pub fn get_repeated_fixed32(&self) -> &[u32] {
        &self.repeated_fixed32
    }

    // repeated fixed64 repeated_fixed64 = 38;

    pub fn clear_repeated_fixed64(&mut self) {
        self.repeated_fixed64.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_fixed64(&mut self, v: ::std::vec::Vec<u64>) {
        self.repeated_fixed64 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_fixed64(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.repeated_fixed64
    }

    // Take field
    pub fn take_repeated_fixed64(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.repeated_fixed64, ::std::vec::Vec::new())
    }

    pub fn get_repeated_fixed64(&self) -> &[u64] {
        &self.repeated_fixed64
    }

    // repeated sfixed32 repeated_sfixed32 = 39;

    pub fn clear_repeated_sfixed32(&mut self) {
        self.repeated_sfixed32.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_sfixed32(&mut self, v: ::std::vec::Vec<i32>) {
        self.repeated_sfixed32 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_sfixed32(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.repeated_sfixed32
    }

    // Take field
    pub fn take_repeated_sfixed32(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.repeated_sfixed32, ::std::vec::Vec::new())
    }

    pub fn get_repeated_sfixed32(&self) -> &[i32] {
        &self.repeated_sfixed32
    }

    // repeated sfixed64 repeated_sfixed64 = 40;

    pub fn clear_repeated_sfixed64(&mut self) {
        self.repeated_sfixed64.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_sfixed64(&mut self, v: ::std::vec::Vec<i64>) {
        self.repeated_sfixed64 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_sfixed64(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.repeated_sfixed64
    }

    // Take field
    pub fn take_repeated_sfixed64(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.repeated_sfixed64, ::std::vec::Vec::new())
    }

    pub fn get_repeated_sfixed64(&self) -> &[i64] {
        &self.repeated_sfixed64
    }

    // repeated float repeated_float = 41;

    pub fn clear_repeated_float(&mut self) {
        self.repeated_float.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_float(&mut self, v: ::std::vec::Vec<f32>) {
        self.repeated_float = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_float(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.repeated_float
    }

    // Take field
    pub fn take_repeated_float(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.repeated_float, ::std::vec::Vec::new())
    }

    pub fn get_repeated_float(&self) -> &[f32] {
        &self.repeated_float
    }

    // repeated double repeated_double = 42;

    pub fn clear_repeated_double(&mut self) {
        self.repeated_double.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_double(&mut self, v: ::std::vec::Vec<f64>) {
        self.repeated_double = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_double(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.repeated_double
    }

    // Take field
    pub fn take_repeated_double(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.repeated_double, ::std::vec::Vec::new())
    }

    pub fn get_repeated_double(&self) -> &[f64] {
        &self.repeated_double
    }

    // repeated bool repeated_bool = 43;

    pub fn clear_repeated_bool(&mut self) {
        self.repeated_bool.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_bool(&mut self, v: ::std::vec::Vec<bool>) {
        self.repeated_bool = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_bool(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.repeated_bool
    }

    // Take field
    pub fn take_repeated_bool(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.repeated_bool, ::std::vec::Vec::new())
    }

    pub fn get_repeated_bool(&self) -> &[bool] {
        &self.repeated_bool
    }

    // repeated string repeated_string = 44;

    pub fn clear_repeated_string(&mut self) {
        self.repeated_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_string(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.repeated_string = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_string(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.repeated_string
    }

    // Take field
    pub fn take_repeated_string(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.repeated_string, ::protobuf::RepeatedField::new())
    }

    pub fn get_repeated_string(&self) -> &[::std::string::String] {
        &self.repeated_string
    }

    // repeated bytes repeated_bytes = 45;

    pub fn clear_repeated_bytes(&mut self) {
        self.repeated_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_bytes(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.repeated_bytes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_bytes(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.repeated_bytes
    }

    // Take field
    pub fn take_repeated_bytes(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.repeated_bytes, ::protobuf::RepeatedField::new())
    }

    pub fn get_repeated_bytes(&self) -> &[::std::vec::Vec<u8>] {
        &self.repeated_bytes
    }

    // repeated .protobuf_unittest.TestAllTypes.NestedMessage repeated_nested_message = 48;

    pub fn clear_repeated_nested_message(&mut self) {
        self.repeated_nested_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_nested_message(&mut self, v: ::protobuf::RepeatedField<TestAllTypes_NestedMessage>) {
        self.repeated_nested_message = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_nested_message(&mut self) -> &mut ::protobuf::RepeatedField<TestAllTypes_NestedMessage> {
        &mut self.repeated_nested_message
    }

    // Take field
    pub fn take_repeated_nested_message(&mut self) -> ::protobuf::RepeatedField<TestAllTypes_NestedMessage> {
        ::std::mem::replace(&mut self.repeated_nested_message, ::protobuf::RepeatedField::new())
    }

    pub fn get_repeated_nested_message(&self) -> &[TestAllTypes_NestedMessage] {
        &self.repeated_nested_message
    }

    // repeated .protobuf_unittest.ForeignMessage repeated_foreign_message = 49;

    pub fn clear_repeated_foreign_message(&mut self) {
        self.repeated_foreign_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_foreign_message(&mut self, v: ::protobuf::RepeatedField<ForeignMessage>) {
        self.repeated_foreign_message = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_foreign_message(&mut self) -> &mut ::protobuf::RepeatedField<ForeignMessage> {
        &mut self.repeated_foreign_message
    }

    // Take field
    pub fn take_repeated_foreign_message(&mut self) -> ::protobuf::RepeatedField<ForeignMessage> {
        ::std::mem::replace(&mut self.repeated_foreign_message, ::protobuf::RepeatedField::new())
    }

    pub fn get_repeated_foreign_message(&self) -> &[ForeignMessage] {
        &self.repeated_foreign_message
    }

    // repeated .protobuf_unittest_import.ImportMessage repeated_import_message = 50;

    pub fn clear_repeated_import_message(&mut self) {
        self.repeated_import_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_import_message(&mut self, v: ::protobuf::RepeatedField<super::unittest_import::ImportMessage>) {
        self.repeated_import_message = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_import_message(&mut self) -> &mut ::protobuf::RepeatedField<super::unittest_import::ImportMessage> {
        &mut self.repeated_import_message
    }

    // Take field
    pub fn take_repeated_import_message(&mut self) -> ::protobuf::RepeatedField<super::unittest_import::ImportMessage> {
        ::std::mem::replace(&mut self.repeated_import_message, ::protobuf::RepeatedField::new())
    }

    pub fn get_repeated_import_message(&self) -> &[super::unittest_import::ImportMessage] {
        &self.repeated_import_message
    }

    // repeated .protobuf_unittest.TestAllTypes.NestedEnum repeated_nested_enum = 51;

    pub fn clear_repeated_nested_enum(&mut self) {
        self.repeated_nested_enum.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_nested_enum(&mut self, v: ::std::vec::Vec<TestAllTypes_NestedEnum>) {
        self.repeated_nested_enum = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_nested_enum(&mut self) -> &mut ::std::vec::Vec<TestAllTypes_NestedEnum> {
        &mut self.repeated_nested_enum
    }

    // Take field
    pub fn take_repeated_nested_enum(&mut self) -> ::std::vec::Vec<TestAllTypes_NestedEnum> {
        ::std::mem::replace(&mut self.repeated_nested_enum, ::std::vec::Vec::new())
    }

    pub fn get_repeated_nested_enum(&self) -> &[TestAllTypes_NestedEnum] {
        &self.repeated_nested_enum
    }

    // repeated .protobuf_unittest.ForeignEnum repeated_foreign_enum = 52;

    pub fn clear_repeated_foreign_enum(&mut self) {
        self.repeated_foreign_enum.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_foreign_enum(&mut self, v: ::std::vec::Vec<ForeignEnum>) {
        self.repeated_foreign_enum = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_foreign_enum(&mut self) -> &mut ::std::vec::Vec<ForeignEnum> {
        &mut self.repeated_foreign_enum
    }

    // Take field
    pub fn take_repeated_foreign_enum(&mut self) -> ::std::vec::Vec<ForeignEnum> {
        ::std::mem::replace(&mut self.repeated_foreign_enum, ::std::vec::Vec::new())
    }

    pub fn get_repeated_foreign_enum(&self) -> &[ForeignEnum] {
        &self.repeated_foreign_enum
    }

    // repeated .protobuf_unittest_import.ImportEnum repeated_import_enum = 53;

    pub fn clear_repeated_import_enum(&mut self) {
        self.repeated_import_enum.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_import_enum(&mut self, v: ::std::vec::Vec<super::unittest_import::ImportEnum>) {
        self.repeated_import_enum = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_import_enum(&mut self) -> &mut ::std::vec::Vec<super::unittest_import::ImportEnum> {
        &mut self.repeated_import_enum
    }

    // Take field
    pub fn take_repeated_import_enum(&mut self) -> ::std::vec::Vec<super::unittest_import::ImportEnum> {
        ::std::mem::replace(&mut self.repeated_import_enum, ::std::vec::Vec::new())
    }

    pub fn get_repeated_import_enum(&self) -> &[super::unittest_import::ImportEnum] {
        &self.repeated_import_enum
    }

    // repeated string repeated_string_piece = 54;

    pub fn clear_repeated_string_piece(&mut self) {
        self.repeated_string_piece.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_string_piece(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.repeated_string_piece = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_string_piece(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.repeated_string_piece
    }

    // Take field
    pub fn take_repeated_string_piece(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.repeated_string_piece, ::protobuf::RepeatedField::new())
    }

    pub fn get_repeated_string_piece(&self) -> &[::std::string::String] {
        &self.repeated_string_piece
    }

    // repeated string repeated_cord = 55;

    pub fn clear_repeated_cord(&mut self) {
        self.repeated_cord.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_cord(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.repeated_cord = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_cord(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.repeated_cord
    }

    // Take field
    pub fn take_repeated_cord(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.repeated_cord, ::protobuf::RepeatedField::new())
    }

    pub fn get_repeated_cord(&self) -> &[::std::string::String] {
        &self.repeated_cord
    }

    // repeated .protobuf_unittest.TestAllTypes.NestedMessage repeated_lazy_message = 57;

    pub fn clear_repeated_lazy_message(&mut self) {
        self.repeated_lazy_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_lazy_message(&mut self, v: ::protobuf::RepeatedField<TestAllTypes_NestedMessage>) {
        self.repeated_lazy_message = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_lazy_message(&mut self) -> &mut ::protobuf::RepeatedField<TestAllTypes_NestedMessage> {
        &mut self.repeated_lazy_message
    }

    // Take field
    pub fn take_repeated_lazy_message(&mut self) -> ::protobuf::RepeatedField<TestAllTypes_NestedMessage> {
        ::std::mem::replace(&mut self.repeated_lazy_message, ::protobuf::RepeatedField::new())
    }

    pub fn get_repeated_lazy_message(&self) -> &[TestAllTypes_NestedMessage] {
        &self.repeated_lazy_message
    }

    // optional int32 default_int32 = 61;

    pub fn clear_default_int32(&mut self) {
        self.default_int32 = ::std::option::Option::None;
    }

    pub fn has_default_int32(&self) -> bool {
        self.default_int32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_int32(&mut self, v: i32) {
        self.default_int32 = ::std::option::Option::Some(v);
    }

    pub fn get_default_int32(&self) -> i32 {
        self.default_int32.unwrap_or(41i32)
    }

    // optional int64 default_int64 = 62;

    pub fn clear_default_int64(&mut self) {
        self.default_int64 = ::std::option::Option::None;
    }

    pub fn has_default_int64(&self) -> bool {
        self.default_int64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_int64(&mut self, v: i64) {
        self.default_int64 = ::std::option::Option::Some(v);
    }

    pub fn get_default_int64(&self) -> i64 {
        self.default_int64.unwrap_or(42i64)
    }

    // optional uint32 default_uint32 = 63;

    pub fn clear_default_uint32(&mut self) {
        self.default_uint32 = ::std::option::Option::None;
    }

    pub fn has_default_uint32(&self) -> bool {
        self.default_uint32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_uint32(&mut self, v: u32) {
        self.default_uint32 = ::std::option::Option::Some(v);
    }

    pub fn get_default_uint32(&self) -> u32 {
        self.default_uint32.unwrap_or(43u32)
    }

    // optional uint64 default_uint64 = 64;

    pub fn clear_default_uint64(&mut self) {
        self.default_uint64 = ::std::option::Option::None;
    }

    pub fn has_default_uint64(&self) -> bool {
        self.default_uint64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_uint64(&mut self, v: u64) {
        self.default_uint64 = ::std::option::Option::Some(v);
    }

    pub fn get_default_uint64(&self) -> u64 {
        self.default_uint64.unwrap_or(44u64)
    }

    // optional sint32 default_sint32 = 65;

    pub fn clear_default_sint32(&mut self) {
        self.default_sint32 = ::std::option::Option::None;
    }

    pub fn has_default_sint32(&self) -> bool {
        self.default_sint32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_sint32(&mut self, v: i32) {
        self.default_sint32 = ::std::option::Option::Some(v);
    }

    pub fn get_default_sint32(&self) -> i32 {
        self.default_sint32.unwrap_or(-45i32)
    }

    // optional sint64 default_sint64 = 66;

    pub fn clear_default_sint64(&mut self) {
        self.default_sint64 = ::std::option::Option::None;
    }

    pub fn has_default_sint64(&self) -> bool {
        self.default_sint64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_sint64(&mut self, v: i64) {
        self.default_sint64 = ::std::option::Option::Some(v);
    }

    pub fn get_default_sint64(&self) -> i64 {
        self.default_sint64.unwrap_or(46i64)
    }

    // optional fixed32 default_fixed32 = 67;

    pub fn clear_default_fixed32(&mut self) {
        self.default_fixed32 = ::std::option::Option::None;
    }

    pub fn has_default_fixed32(&self) -> bool {
        self.default_fixed32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_fixed32(&mut self, v: u32) {
        self.default_fixed32 = ::std::option::Option::Some(v);
    }

    pub fn get_default_fixed32(&self) -> u32 {
        self.default_fixed32.unwrap_or(47u32)
    }

    // optional fixed64 default_fixed64 = 68;

    pub fn clear_default_fixed64(&mut self) {
        self.default_fixed64 = ::std::option::Option::None;
    }

    pub fn has_default_fixed64(&self) -> bool {
        self.default_fixed64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_fixed64(&mut self, v: u64) {
        self.default_fixed64 = ::std::option::Option::Some(v);
    }

    pub fn get_default_fixed64(&self) -> u64 {
        self.default_fixed64.unwrap_or(48u64)
    }

    // optional sfixed32 default_sfixed32 = 69;

    pub fn clear_default_sfixed32(&mut self) {
        self.default_sfixed32 = ::std::option::Option::None;
    }

    pub fn has_default_sfixed32(&self) -> bool {
        self.default_sfixed32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_sfixed32(&mut self, v: i32) {
        self.default_sfixed32 = ::std::option::Option::Some(v);
    }

    pub fn get_default_sfixed32(&self) -> i32 {
        self.default_sfixed32.unwrap_or(49i32)
    }

    // optional sfixed64 default_sfixed64 = 70;

    pub fn clear_default_sfixed64(&mut self) {
        self.default_sfixed64 = ::std::option::Option::None;
    }

    pub fn has_default_sfixed64(&self) -> bool {
        self.default_sfixed64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_sfixed64(&mut self, v: i64) {
        self.default_sfixed64 = ::std::option::Option::Some(v);
    }

    pub fn get_default_sfixed64(&self) -> i64 {
        self.default_sfixed64.unwrap_or(-50i64)
    }

    // optional float default_float = 71;

    pub fn clear_default_float(&mut self) {
        self.default_float = ::std::option::Option::None;
    }

    pub fn has_default_float(&self) -> bool {
        self.default_float.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_float(&mut self, v: f32) {
        self.default_float = ::std::option::Option::Some(v);
    }

    pub fn get_default_float(&self) -> f32 {
        self.default_float.unwrap_or(51.5f32)
    }

    // optional double default_double = 72;

    pub fn clear_default_double(&mut self) {
        self.default_double = ::std::option::Option::None;
    }

    pub fn has_default_double(&self) -> bool {
        self.default_double.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_double(&mut self, v: f64) {
        self.default_double = ::std::option::Option::Some(v);
    }

    pub fn get_default_double(&self) -> f64 {
        self.default_double.unwrap_or(52000.0f64)
    }

    // optional bool default_bool = 73;

    pub fn clear_default_bool(&mut self) {
        self.default_bool = ::std::option::Option::None;
    }

    pub fn has_default_bool(&self) -> bool {
        self.default_bool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_bool(&mut self, v: bool) {
        self.default_bool = ::std::option::Option::Some(v);
    }

    pub fn get_default_bool(&self) -> bool {
        self.default_bool.unwrap_or(true)
    }

    // optional string default_string = 74;

    pub fn clear_default_string(&mut self) {
        self.default_string.clear();
    }

    pub fn has_default_string(&self) -> bool {
        self.default_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_string(&mut self, v: ::std::string::String) {
        self.default_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_string(&mut self) -> &mut ::std::string::String {
        if self.default_string.is_none() {
            self.default_string.set_default();
        }
        self.default_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_default_string(&mut self) -> ::std::string::String {
        self.default_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_default_string(&self) -> &str {
        match self.default_string.as_ref() {
            Some(v) => &v,
            None => "hello",
        }
    }

    // optional bytes default_bytes = 75;

    pub fn clear_default_bytes(&mut self) {
        self.default_bytes.clear();
    }

    pub fn has_default_bytes(&self) -> bool {
        self.default_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.default_bytes = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.default_bytes.is_none() {
            self.default_bytes.set_default();
        }
        self.default_bytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_default_bytes(&mut self) -> ::std::vec::Vec<u8> {
        self.default_bytes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_default_bytes(&self) -> &[u8] {
        match self.default_bytes.as_ref() {
            Some(v) => &v,
            None => b"world",
        }
    }

    // optional .protobuf_unittest.TestAllTypes.NestedEnum default_nested_enum = 81;

    pub fn clear_default_nested_enum(&mut self) {
        self.default_nested_enum = ::std::option::Option::None;
    }

    pub fn has_default_nested_enum(&self) -> bool {
        self.default_nested_enum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_nested_enum(&mut self, v: TestAllTypes_NestedEnum) {
        self.default_nested_enum = ::std::option::Option::Some(v);
    }

    pub fn get_default_nested_enum(&self) -> TestAllTypes_NestedEnum {
        self.default_nested_enum.unwrap_or(TestAllTypes_NestedEnum::BAR)
    }

    // optional .protobuf_unittest.ForeignEnum default_foreign_enum = 82;

    pub fn clear_default_foreign_enum(&mut self) {
        self.default_foreign_enum = ::std::option::Option::None;
    }

    pub fn has_default_foreign_enum(&self) -> bool {
        self.default_foreign_enum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_foreign_enum(&mut self, v: ForeignEnum) {
        self.default_foreign_enum = ::std::option::Option::Some(v);
    }

    pub fn get_default_foreign_enum(&self) -> ForeignEnum {
        self.default_foreign_enum.unwrap_or(ForeignEnum::FOREIGN_BAR)
    }

    // optional .protobuf_unittest_import.ImportEnum default_import_enum = 83;

    pub fn clear_default_import_enum(&mut self) {
        self.default_import_enum = ::std::option::Option::None;
    }

    pub fn has_default_import_enum(&self) -> bool {
        self.default_import_enum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_import_enum(&mut self, v: super::unittest_import::ImportEnum) {
        self.default_import_enum = ::std::option::Option::Some(v);
    }

    pub fn get_default_import_enum(&self) -> super::unittest_import::ImportEnum {
        self.default_import_enum.unwrap_or(super::unittest_import::ImportEnum::IMPORT_BAR)
    }

    // optional string default_string_piece = 84;

    pub fn clear_default_string_piece(&mut self) {
        self.default_string_piece.clear();
    }

    pub fn has_default_string_piece(&self) -> bool {
        self.default_string_piece.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_string_piece(&mut self, v: ::std::string::String) {
        self.default_string_piece = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_string_piece(&mut self) -> &mut ::std::string::String {
        if self.default_string_piece.is_none() {
            self.default_string_piece.set_default();
        }
        self.default_string_piece.as_mut().unwrap()
    }

    // Take field
    pub fn take_default_string_piece(&mut self) -> ::std::string::String {
        self.default_string_piece.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_default_string_piece(&self) -> &str {
        match self.default_string_piece.as_ref() {
            Some(v) => &v,
            None => "abc",
        }
    }

    // optional string default_cord = 85;

    pub fn clear_default_cord(&mut self) {
        self.default_cord.clear();
    }

    pub fn has_default_cord(&self) -> bool {
        self.default_cord.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_cord(&mut self, v: ::std::string::String) {
        self.default_cord = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_cord(&mut self) -> &mut ::std::string::String {
        if self.default_cord.is_none() {
            self.default_cord.set_default();
        }
        self.default_cord.as_mut().unwrap()
    }

    // Take field
    pub fn take_default_cord(&mut self) -> ::std::string::String {
        self.default_cord.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_default_cord(&self) -> &str {
        match self.default_cord.as_ref() {
            Some(v) => &v,
            None => "123",
        }
    }

    // optional uint32 oneof_uint32 = 111;

    pub fn clear_oneof_uint32(&mut self) {
        self.oneof_field = ::std::option::Option::None;
    }

    pub fn has_oneof_uint32(&self) -> bool {
        match self.oneof_field {
            ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_uint32(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_oneof_uint32(&mut self, v: u32) {
        self.oneof_field = ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_uint32(v))
    }

    pub fn get_oneof_uint32(&self) -> u32 {
        match self.oneof_field {
            ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_uint32(v)) => v,
            _ => 0,
        }
    }

    // optional .protobuf_unittest.TestAllTypes.NestedMessage oneof_nested_message = 112;

    pub fn clear_oneof_nested_message(&mut self) {
        self.oneof_field = ::std::option::Option::None;
    }

    pub fn has_oneof_nested_message(&self) -> bool {
        match self.oneof_field {
            ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_nested_message(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_oneof_nested_message(&mut self, v: TestAllTypes_NestedMessage) {
        self.oneof_field = ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_nested_message(v))
    }

    // Mutable pointer to the field.
    pub fn mut_oneof_nested_message(&mut self) -> &mut TestAllTypes_NestedMessage {
        if let ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_nested_message(_)) = self.oneof_field {
        } else {
            self.oneof_field = ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_nested_message(TestAllTypes_NestedMessage::new()));
        }
        match self.oneof_field {
            ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_nested_message(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_oneof_nested_message(&mut self) -> TestAllTypes_NestedMessage {
        if self.has_oneof_nested_message() {
            match self.oneof_field.take() {
                ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_nested_message(v)) => v,
                _ => panic!(),
            }
        } else {
            TestAllTypes_NestedMessage::new()
        }
    }

    pub fn get_oneof_nested_message(&self) -> &TestAllTypes_NestedMessage {
        match self.oneof_field {
            ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_nested_message(ref v)) => v,
            _ => TestAllTypes_NestedMessage::default_instance(),
        }
    }

    // optional string oneof_string = 113;

    pub fn clear_oneof_string(&mut self) {
        self.oneof_field = ::std::option::Option::None;
    }

    pub fn has_oneof_string(&self) -> bool {
        match self.oneof_field {
            ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_string(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_oneof_string(&mut self, v: ::std::string::String) {
        self.oneof_field = ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_string(v))
    }

    // Mutable pointer to the field.
    pub fn mut_oneof_string(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_string(_)) = self.oneof_field {
        } else {
            self.oneof_field = ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_string(::std::string::String::new()));
        }
        match self.oneof_field {
            ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_string(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_oneof_string(&mut self) -> ::std::string::String {
        if self.has_oneof_string() {
            match self.oneof_field.take() {
                ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_string(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_oneof_string(&self) -> &str {
        match self.oneof_field {
            ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_string(ref v)) => v,
            _ => "",
        }
    }

    // optional bytes oneof_bytes = 114;

    pub fn clear_oneof_bytes(&mut self) {
        self.oneof_field = ::std::option::Option::None;
    }

    pub fn has_oneof_bytes(&self) -> bool {
        match self.oneof_field {
            ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_bytes(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_oneof_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.oneof_field = ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_bytes(v))
    }

    // Mutable pointer to the field.
    pub fn mut_oneof_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_bytes(_)) = self.oneof_field {
        } else {
            self.oneof_field = ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_bytes(::std::vec::Vec::new()));
        }
        match self.oneof_field {
            ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_bytes(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_oneof_bytes(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_oneof_bytes() {
            match self.oneof_field.take() {
                ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_bytes(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    pub fn get_oneof_bytes(&self) -> &[u8] {
        match self.oneof_field {
            ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_bytes(ref v)) => v,
            _ => &[],
        }
    }
}

impl ::protobuf::Message for TestAllTypes {
    fn is_initialized(&self) -> bool {
        for v in &self.optional_nested_message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.optional_foreign_message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.optional_import_message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.optional_public_import_message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.optional_lazy_message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.repeated_nested_message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.repeated_foreign_message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.repeated_import_message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.repeated_lazy_message {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(TestAllTypes_oneof_oneof_field::oneof_nested_message(ref v)) = self.oneof_field {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.optional_int32 = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.optional_int64 = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.optional_uint32 = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.optional_uint64 = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.optional_sint32 = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.optional_sint64 = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.optional_fixed32 = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.optional_fixed64 = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sfixed32()?;
                    self.optional_sfixed32 = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sfixed64()?;
                    self.optional_sfixed64 = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.optional_float = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.optional_double = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.optional_bool = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.optional_string)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.optional_bytes)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.optional_nested_message)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.optional_foreign_message)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.optional_import_message)?;
                },
                21 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.optional_nested_enum, 21, &mut self.unknown_fields)?
                },
                22 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.optional_foreign_enum, 22, &mut self.unknown_fields)?
                },
                23 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.optional_import_enum, 23, &mut self.unknown_fields)?
                },
                24 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.optional_string_piece)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.optional_cord)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.optional_public_import_message)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.optional_lazy_message)?;
                },
                31 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.repeated_int32)?;
                },
                32 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.repeated_int64)?;
                },
                33 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.repeated_uint32)?;
                },
                34 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.repeated_uint64)?;
                },
                35 => {
                    ::protobuf::rt::read_repeated_sint32_into(wire_type, is, &mut self.repeated_sint32)?;
                },
                36 => {
                    ::protobuf::rt::read_repeated_sint64_into(wire_type, is, &mut self.repeated_sint64)?;
                },
                37 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.repeated_fixed32)?;
                },
                38 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.repeated_fixed64)?;
                },
                39 => {
                    ::protobuf::rt::read_repeated_sfixed32_into(wire_type, is, &mut self.repeated_sfixed32)?;
                },
                40 => {
                    ::protobuf::rt::read_repeated_sfixed64_into(wire_type, is, &mut self.repeated_sfixed64)?;
                },
                41 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.repeated_float)?;
                },
                42 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.repeated_double)?;
                },
                43 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.repeated_bool)?;
                },
                44 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.repeated_string)?;
                },
                45 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.repeated_bytes)?;
                },
                48 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.repeated_nested_message)?;
                },
                49 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.repeated_foreign_message)?;
                },
                50 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.repeated_import_message)?;
                },
                51 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.repeated_nested_enum, 51, &mut self.unknown_fields)?
                },
                52 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.repeated_foreign_enum, 52, &mut self.unknown_fields)?
                },
                53 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.repeated_import_enum, 53, &mut self.unknown_fields)?
                },
                54 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.repeated_string_piece)?;
                },
                55 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.repeated_cord)?;
                },
                57 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.repeated_lazy_message)?;
                },
                61 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.default_int32 = ::std::option::Option::Some(tmp);
                },
                62 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.default_int64 = ::std::option::Option::Some(tmp);
                },
                63 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.default_uint32 = ::std::option::Option::Some(tmp);
                },
                64 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.default_uint64 = ::std::option::Option::Some(tmp);
                },
                65 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.default_sint32 = ::std::option::Option::Some(tmp);
                },
                66 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.default_sint64 = ::std::option::Option::Some(tmp);
                },
                67 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.default_fixed32 = ::std::option::Option::Some(tmp);
                },
                68 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.default_fixed64 = ::std::option::Option::Some(tmp);
                },
                69 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sfixed32()?;
                    self.default_sfixed32 = ::std::option::Option::Some(tmp);
                },
                70 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sfixed64()?;
                    self.default_sfixed64 = ::std::option::Option::Some(tmp);
                },
                71 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.default_float = ::std::option::Option::Some(tmp);
                },
                72 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.default_double = ::std::option::Option::Some(tmp);
                },
                73 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.default_bool = ::std::option::Option::Some(tmp);
                },
                74 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.default_string)?;
                },
                75 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.default_bytes)?;
                },
                81 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.default_nested_enum, 81, &mut self.unknown_fields)?
                },
                82 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.default_foreign_enum, 82, &mut self.unknown_fields)?
                },
                83 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.default_import_enum, 83, &mut self.unknown_fields)?
                },
                84 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.default_string_piece)?;
                },
                85 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.default_cord)?;
                },
                111 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.oneof_field = ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_uint32(is.read_uint32()?));
                },
                112 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.oneof_field = ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_nested_message(is.read_message()?));
                },
                113 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.oneof_field = ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_string(is.read_string()?));
                },
                114 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.oneof_field = ::std::option::Option::Some(TestAllTypes_oneof_oneof_field::oneof_bytes(is.read_bytes()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.optional_int32 {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.optional_int64 {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.optional_uint32 {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.optional_uint64 {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.optional_sint32 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(5, v);
        }
        if let Some(v) = self.optional_sint64 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(6, v);
        }
        if let Some(v) = self.optional_fixed32 {
            my_size += 5;
        }
        if let Some(v) = self.optional_fixed64 {
            my_size += 9;
        }
        if let Some(v) = self.optional_sfixed32 {
            my_size += 5;
        }
        if let Some(v) = self.optional_sfixed64 {
            my_size += 9;
        }
        if let Some(v) = self.optional_float {
            my_size += 5;
        }
        if let Some(v) = self.optional_double {
            my_size += 9;
        }
        if let Some(v) = self.optional_bool {
            my_size += 2;
        }
        if let Some(ref v) = self.optional_string.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(ref v) = self.optional_bytes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(15, &v);
        }
        if let Some(ref v) = self.optional_nested_message.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.optional_foreign_message.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.optional_import_message.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.optional_nested_enum {
            my_size += ::protobuf::rt::enum_size(21, v);
        }
        if let Some(v) = self.optional_foreign_enum {
            my_size += ::protobuf::rt::enum_size(22, v);
        }
        if let Some(v) = self.optional_import_enum {
            my_size += ::protobuf::rt::enum_size(23, v);
        }
        if let Some(ref v) = self.optional_string_piece.as_ref() {
            my_size += ::protobuf::rt::string_size(24, &v);
        }
        if let Some(ref v) = self.optional_cord.as_ref() {
            my_size += ::protobuf::rt::string_size(25, &v);
        }
        if let Some(ref v) = self.optional_public_import_message.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.optional_lazy_message.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.repeated_int32 {
            my_size += ::protobuf::rt::value_size(31, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.repeated_int64 {
            my_size += ::protobuf::rt::value_size(32, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.repeated_uint32 {
            my_size += ::protobuf::rt::value_size(33, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.repeated_uint64 {
            my_size += ::protobuf::rt::value_size(34, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.repeated_sint32 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(35, *value);
        };
        for value in &self.repeated_sint64 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(36, *value);
        };
        my_size += 6 * self.repeated_fixed32.len() as u32;
        my_size += 10 * self.repeated_fixed64.len() as u32;
        my_size += 6 * self.repeated_sfixed32.len() as u32;
        my_size += 10 * self.repeated_sfixed64.len() as u32;
        my_size += 6 * self.repeated_float.len() as u32;
        my_size += 10 * self.repeated_double.len() as u32;
        my_size += 3 * self.repeated_bool.len() as u32;
        for value in &self.repeated_string {
            my_size += ::protobuf::rt::string_size(44, &value);
        };
        for value in &self.repeated_bytes {
            my_size += ::protobuf::rt::bytes_size(45, &value);
        };
        for value in &self.repeated_nested_message {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.repeated_foreign_message {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.repeated_import_message {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.repeated_nested_enum {
            my_size += ::protobuf::rt::enum_size(51, *value);
        };
        for value in &self.repeated_foreign_enum {
            my_size += ::protobuf::rt::enum_size(52, *value);
        };
        for value in &self.repeated_import_enum {
            my_size += ::protobuf::rt::enum_size(53, *value);
        };
        for value in &self.repeated_string_piece {
            my_size += ::protobuf::rt::string_size(54, &value);
        };
        for value in &self.repeated_cord {
            my_size += ::protobuf::rt::string_size(55, &value);
        };
        for value in &self.repeated_lazy_message {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.default_int32 {
            my_size += ::protobuf::rt::value_size(61, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.default_int64 {
            my_size += ::protobuf::rt::value_size(62, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.default_uint32 {
            my_size += ::protobuf::rt::value_size(63, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.default_uint64 {
            my_size += ::protobuf::rt::value_size(64, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.default_sint32 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(65, v);
        }
        if let Some(v) = self.default_sint64 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(66, v);
        }
        if let Some(v) = self.default_fixed32 {
            my_size += 6;
        }
        if let Some(v) = self.default_fixed64 {
            my_size += 10;
        }
        if let Some(v) = self.default_sfixed32 {
            my_size += 6;
        }
        if let Some(v) = self.default_sfixed64 {
            my_size += 10;
        }
        if let Some(v) = self.default_float {
            my_size += 6;
        }
        if let Some(v) = self.default_double {
            my_size += 10;
        }
        if let Some(v) = self.default_bool {
            my_size += 3;
        }
        if let Some(ref v) = self.default_string.as_ref() {
            my_size += ::protobuf::rt::string_size(74, &v);
        }
        if let Some(ref v) = self.default_bytes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(75, &v);
        }
        if let Some(v) = self.default_nested_enum {
            my_size += ::protobuf::rt::enum_size(81, v);
        }
        if let Some(v) = self.default_foreign_enum {
            my_size += ::protobuf::rt::enum_size(82, v);
        }
        if let Some(v) = self.default_import_enum {
            my_size += ::protobuf::rt::enum_size(83, v);
        }
        if let Some(ref v) = self.default_string_piece.as_ref() {
            my_size += ::protobuf::rt::string_size(84, &v);
        }
        if let Some(ref v) = self.default_cord.as_ref() {
            my_size += ::protobuf::rt::string_size(85, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.oneof_field {
            match v {
                &TestAllTypes_oneof_oneof_field::oneof_uint32(v) => {
                    my_size += ::protobuf::rt::value_size(111, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &TestAllTypes_oneof_oneof_field::oneof_nested_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TestAllTypes_oneof_oneof_field::oneof_string(ref v) => {
                    my_size += ::protobuf::rt::string_size(113, &v);
                },
                &TestAllTypes_oneof_oneof_field::oneof_bytes(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(114, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.optional_int32 {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.optional_int64 {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.optional_uint32 {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.optional_uint64 {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.optional_sint32 {
            os.write_sint32(5, v)?;
        }
        if let Some(v) = self.optional_sint64 {
            os.write_sint64(6, v)?;
        }
        if let Some(v) = self.optional_fixed32 {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.optional_fixed64 {
            os.write_fixed64(8, v)?;
        }
        if let Some(v) = self.optional_sfixed32 {
            os.write_sfixed32(9, v)?;
        }
        if let Some(v) = self.optional_sfixed64 {
            os.write_sfixed64(10, v)?;
        }
        if let Some(v) = self.optional_float {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.optional_double {
            os.write_double(12, v)?;
        }
        if let Some(v) = self.optional_bool {
            os.write_bool(13, v)?;
        }
        if let Some(ref v) = self.optional_string.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(ref v) = self.optional_bytes.as_ref() {
            os.write_bytes(15, &v)?;
        }
        if let Some(ref v) = self.optional_nested_message.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.optional_foreign_message.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.optional_import_message.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.optional_nested_enum {
            os.write_enum(21, v.value())?;
        }
        if let Some(v) = self.optional_foreign_enum {
            os.write_enum(22, v.value())?;
        }
        if let Some(v) = self.optional_import_enum {
            os.write_enum(23, v.value())?;
        }
        if let Some(ref v) = self.optional_string_piece.as_ref() {
            os.write_string(24, &v)?;
        }
        if let Some(ref v) = self.optional_cord.as_ref() {
            os.write_string(25, &v)?;
        }
        if let Some(ref v) = self.optional_public_import_message.as_ref() {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.optional_lazy_message.as_ref() {
            os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.repeated_int32 {
            os.write_int32(31, *v)?;
        };
        for v in &self.repeated_int64 {
            os.write_int64(32, *v)?;
        };
        for v in &self.repeated_uint32 {
            os.write_uint32(33, *v)?;
        };
        for v in &self.repeated_uint64 {
            os.write_uint64(34, *v)?;
        };
        for v in &self.repeated_sint32 {
            os.write_sint32(35, *v)?;
        };
        for v in &self.repeated_sint64 {
            os.write_sint64(36, *v)?;
        };
        for v in &self.repeated_fixed32 {
            os.write_fixed32(37, *v)?;
        };
        for v in &self.repeated_fixed64 {
            os.write_fixed64(38, *v)?;
        };
        for v in &self.repeated_sfixed32 {
            os.write_sfixed32(39, *v)?;
        };
        for v in &self.repeated_sfixed64 {
            os.write_sfixed64(40, *v)?;
        };
        for v in &self.repeated_float {
            os.write_float(41, *v)?;
        };
        for v in &self.repeated_double {
            os.write_double(42, *v)?;
        };
        for v in &self.repeated_bool {
            os.write_bool(43, *v)?;
        };
        for v in &self.repeated_string {
            os.write_string(44, &v)?;
        };
        for v in &self.repeated_bytes {
            os.write_bytes(45, &v)?;
        };
        for v in &self.repeated_nested_message {
            os.write_tag(48, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.repeated_foreign_message {
            os.write_tag(49, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.repeated_import_message {
            os.write_tag(50, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.repeated_nested_enum {
            os.write_enum(51, v.value())?;
        };
        for v in &self.repeated_foreign_enum {
            os.write_enum(52, v.value())?;
        };
        for v in &self.repeated_import_enum {
            os.write_enum(53, v.value())?;
        };
        for v in &self.repeated_string_piece {
            os.write_string(54, &v)?;
        };
        for v in &self.repeated_cord {
            os.write_string(55, &v)?;
        };
        for v in &self.repeated_lazy_message {
            os.write_tag(57, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.default_int32 {
            os.write_int32(61, v)?;
        }
        if let Some(v) = self.default_int64 {
            os.write_int64(62, v)?;
        }
        if let Some(v) = self.default_uint32 {
            os.write_uint32(63, v)?;
        }
        if let Some(v) = self.default_uint64 {
            os.write_uint64(64, v)?;
        }
        if let Some(v) = self.default_sint32 {
            os.write_sint32(65, v)?;
        }
        if let Some(v) = self.default_sint64 {
            os.write_sint64(66, v)?;
        }
        if let Some(v) = self.default_fixed32 {
            os.write_fixed32(67, v)?;
        }
        if let Some(v) = self.default_fixed64 {
            os.write_fixed64(68, v)?;
        }
        if let Some(v) = self.default_sfixed32 {
            os.write_sfixed32(69, v)?;
        }
        if let Some(v) = self.default_sfixed64 {
            os.write_sfixed64(70, v)?;
        }
        if let Some(v) = self.default_float {
            os.write_float(71, v)?;
        }
        if let Some(v) = self.default_double {
            os.write_double(72, v)?;
        }
        if let Some(v) = self.default_bool {
            os.write_bool(73, v)?;
        }
        if let Some(ref v) = self.default_string.as_ref() {
            os.write_string(74, &v)?;
        }
        if let Some(ref v) = self.default_bytes.as_ref() {
            os.write_bytes(75, &v)?;
        }
        if let Some(v) = self.default_nested_enum {
            os.write_enum(81, v.value())?;
        }
        if let Some(v) = self.default_foreign_enum {
            os.write_enum(82, v.value())?;
        }
        if let Some(v) = self.default_import_enum {
            os.write_enum(83, v.value())?;
        }
        if let Some(ref v) = self.default_string_piece.as_ref() {
            os.write_string(84, &v)?;
        }
        if let Some(ref v) = self.default_cord.as_ref() {
            os.write_string(85, &v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.oneof_field {
            match v {
                &TestAllTypes_oneof_oneof_field::oneof_uint32(v) => {
                    os.write_uint32(111, v)?;
                },
                &TestAllTypes_oneof_oneof_field::oneof_nested_message(ref v) => {
                    os.write_tag(112, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TestAllTypes_oneof_oneof_field::oneof_string(ref v) => {
                    os.write_string(113, v)?;
                },
                &TestAllTypes_oneof_oneof_field::oneof_bytes(ref v) => {
                    os.write_bytes(114, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn ::std::any::Any {
        self as &dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestAllTypes {
        TestAllTypes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "optional_int32",
                    |m: &TestAllTypes| { &m.optional_int32 },
                    |m: &mut TestAllTypes| { &mut m.optional_int32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "optional_int64",
                    |m: &TestAllTypes| { &m.optional_int64 },
                    |m: &mut TestAllTypes| { &mut m.optional_int64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "optional_uint32",
                    |m: &TestAllTypes| { &m.optional_uint32 },
                    |m: &mut TestAllTypes| { &mut m.optional_uint32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "optional_uint64",
                    |m: &TestAllTypes| { &m.optional_uint64 },
                    |m: &mut TestAllTypes| { &mut m.optional_uint64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "optional_sint32",
                    |m: &TestAllTypes| { &m.optional_sint32 },
                    |m: &mut TestAllTypes| { &mut m.optional_sint32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                    "optional_sint64",
                    |m: &TestAllTypes| { &m.optional_sint64 },
                    |m: &mut TestAllTypes| { &mut m.optional_sint64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "optional_fixed32",
                    |m: &TestAllTypes| { &m.optional_fixed32 },
                    |m: &mut TestAllTypes| { &mut m.optional_fixed32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "optional_fixed64",
                    |m: &TestAllTypes| { &m.optional_fixed64 },
                    |m: &mut TestAllTypes| { &mut m.optional_fixed64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSfixed32>(
                    "optional_sfixed32",
                    |m: &TestAllTypes| { &m.optional_sfixed32 },
                    |m: &mut TestAllTypes| { &mut m.optional_sfixed32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSfixed64>(
                    "optional_sfixed64",
                    |m: &TestAllTypes| { &m.optional_sfixed64 },
                    |m: &mut TestAllTypes| { &mut m.optional_sfixed64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "optional_float",
                    |m: &TestAllTypes| { &m.optional_float },
                    |m: &mut TestAllTypes| { &mut m.optional_float },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "optional_double",
                    |m: &TestAllTypes| { &m.optional_double },
                    |m: &mut TestAllTypes| { &mut m.optional_double },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "optional_bool",
                    |m: &TestAllTypes| { &m.optional_bool },
                    |m: &mut TestAllTypes| { &mut m.optional_bool },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "optional_string",
                    |m: &TestAllTypes| { &m.optional_string },
                    |m: &mut TestAllTypes| { &mut m.optional_string },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "optional_bytes",
                    |m: &TestAllTypes| { &m.optional_bytes },
                    |m: &mut TestAllTypes| { &mut m.optional_bytes },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestAllTypes_NestedMessage>>(
                    "optional_nested_message",
                    |m: &TestAllTypes| { &m.optional_nested_message },
                    |m: &mut TestAllTypes| { &mut m.optional_nested_message },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ForeignMessage>>(
                    "optional_foreign_message",
                    |m: &TestAllTypes| { &m.optional_foreign_message },
                    |m: &mut TestAllTypes| { &mut m.optional_foreign_message },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::unittest_import::ImportMessage>>(
                    "optional_import_message",
                    |m: &TestAllTypes| { &m.optional_import_message },
                    |m: &mut TestAllTypes| { &mut m.optional_import_message },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TestAllTypes_NestedEnum>>(
                    "optional_nested_enum",
                    |m: &TestAllTypes| { &m.optional_nested_enum },
                    |m: &mut TestAllTypes| { &mut m.optional_nested_enum },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ForeignEnum>>(
                    "optional_foreign_enum",
                    |m: &TestAllTypes| { &m.optional_foreign_enum },
                    |m: &mut TestAllTypes| { &mut m.optional_foreign_enum },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::unittest_import::ImportEnum>>(
                    "optional_import_enum",
                    |m: &TestAllTypes| { &m.optional_import_enum },
                    |m: &mut TestAllTypes| { &mut m.optional_import_enum },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "optional_string_piece",
                    |m: &TestAllTypes| { &m.optional_string_piece },
                    |m: &mut TestAllTypes| { &mut m.optional_string_piece },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "optional_cord",
                    |m: &TestAllTypes| { &m.optional_cord },
                    |m: &mut TestAllTypes| { &mut m.optional_cord },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::unittest_import_public::PublicImportMessage>>(
                    "optional_public_import_message",
                    |m: &TestAllTypes| { &m.optional_public_import_message },
                    |m: &mut TestAllTypes| { &mut m.optional_public_import_message },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestAllTypes_NestedMessage>>(
                    "optional_lazy_message",
                    |m: &TestAllTypes| { &m.optional_lazy_message },
                    |m: &mut TestAllTypes| { &mut m.optional_lazy_message },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "repeated_int32",
                    |m: &TestAllTypes| { &m.repeated_int32 },
                    |m: &mut TestAllTypes| { &mut m.repeated_int32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "repeated_int64",
                    |m: &TestAllTypes| { &m.repeated_int64 },
                    |m: &mut TestAllTypes| { &mut m.repeated_int64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "repeated_uint32",
                    |m: &TestAllTypes| { &m.repeated_uint32 },
                    |m: &mut TestAllTypes| { &mut m.repeated_uint32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "repeated_uint64",
                    |m: &TestAllTypes| { &m.repeated_uint64 },
                    |m: &mut TestAllTypes| { &mut m.repeated_uint64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "repeated_sint32",
                    |m: &TestAllTypes| { &m.repeated_sint32 },
                    |m: &mut TestAllTypes| { &mut m.repeated_sint32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                    "repeated_sint64",
                    |m: &TestAllTypes| { &m.repeated_sint64 },
                    |m: &mut TestAllTypes| { &mut m.repeated_sint64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "repeated_fixed32",
                    |m: &TestAllTypes| { &m.repeated_fixed32 },
                    |m: &mut TestAllTypes| { &mut m.repeated_fixed32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "repeated_fixed64",
                    |m: &TestAllTypes| { &m.repeated_fixed64 },
                    |m: &mut TestAllTypes| { &mut m.repeated_fixed64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSfixed32>(
                    "repeated_sfixed32",
                    |m: &TestAllTypes| { &m.repeated_sfixed32 },
                    |m: &mut TestAllTypes| { &mut m.repeated_sfixed32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSfixed64>(
                    "repeated_sfixed64",
                    |m: &TestAllTypes| { &m.repeated_sfixed64 },
                    |m: &mut TestAllTypes| { &mut m.repeated_sfixed64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "repeated_float",
                    |m: &TestAllTypes| { &m.repeated_float },
                    |m: &mut TestAllTypes| { &mut m.repeated_float },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "repeated_double",
                    |m: &TestAllTypes| { &m.repeated_double },
                    |m: &mut TestAllTypes| { &mut m.repeated_double },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "repeated_bool",
                    |m: &TestAllTypes| { &m.repeated_bool },
                    |m: &mut TestAllTypes| { &mut m.repeated_bool },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "repeated_string",
                    |m: &TestAllTypes| { &m.repeated_string },
                    |m: &mut TestAllTypes| { &mut m.repeated_string },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "repeated_bytes",
                    |m: &TestAllTypes| { &m.repeated_bytes },
                    |m: &mut TestAllTypes| { &mut m.repeated_bytes },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestAllTypes_NestedMessage>>(
                    "repeated_nested_message",
                    |m: &TestAllTypes| { &m.repeated_nested_message },
                    |m: &mut TestAllTypes| { &mut m.repeated_nested_message },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ForeignMessage>>(
                    "repeated_foreign_message",
                    |m: &TestAllTypes| { &m.repeated_foreign_message },
                    |m: &mut TestAllTypes| { &mut m.repeated_foreign_message },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::unittest_import::ImportMessage>>(
                    "repeated_import_message",
                    |m: &TestAllTypes| { &m.repeated_import_message },
                    |m: &mut TestAllTypes| { &mut m.repeated_import_message },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TestAllTypes_NestedEnum>>(
                    "repeated_nested_enum",
                    |m: &TestAllTypes| { &m.repeated_nested_enum },
                    |m: &mut TestAllTypes| { &mut m.repeated_nested_enum },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ForeignEnum>>(
                    "repeated_foreign_enum",
                    |m: &TestAllTypes| { &m.repeated_foreign_enum },
                    |m: &mut TestAllTypes| { &mut m.repeated_foreign_enum },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::unittest_import::ImportEnum>>(
                    "repeated_import_enum",
                    |m: &TestAllTypes| { &m.repeated_import_enum },
                    |m: &mut TestAllTypes| { &mut m.repeated_import_enum },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "repeated_string_piece",
                    |m: &TestAllTypes| { &m.repeated_string_piece },
                    |m: &mut TestAllTypes| { &mut m.repeated_string_piece },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "repeated_cord",
                    |m: &TestAllTypes| { &m.repeated_cord },
                    |m: &mut TestAllTypes| { &mut m.repeated_cord },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestAllTypes_NestedMessage>>(
                    "repeated_lazy_message",
                    |m: &TestAllTypes| { &m.repeated_lazy_message },
                    |m: &mut TestAllTypes| { &mut m.repeated_lazy_message },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "default_int32",
                    |m: &TestAllTypes| { &m.default_int32 },
                    |m: &mut TestAllTypes| { &mut m.default_int32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "default_int64",
                    |m: &TestAllTypes| { &m.default_int64 },
                    |m: &mut TestAllTypes| { &mut m.default_int64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "default_uint32",
                    |m: &TestAllTypes| { &m.default_uint32 },
                    |m: &mut TestAllTypes| { &mut m.default_uint32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "default_uint64",
                    |m: &TestAllTypes| { &m.default_uint64 },
                    |m: &mut TestAllTypes| { &mut m.default_uint64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "default_sint32",
                    |m: &TestAllTypes| { &m.default_sint32 },
                    |m: &mut TestAllTypes| { &mut m.default_sint32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                    "default_sint64",
                    |m: &TestAllTypes| { &m.default_sint64 },
                    |m: &mut TestAllTypes| { &mut m.default_sint64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "default_fixed32",
                    |m: &TestAllTypes| { &m.default_fixed32 },
                    |m: &mut TestAllTypes| { &mut m.default_fixed32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "default_fixed64",
                    |m: &TestAllTypes| { &m.default_fixed64 },
                    |m: &mut TestAllTypes| { &mut m.default_fixed64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSfixed32>(
                    "default_sfixed32",
                    |m: &TestAllTypes| { &m.default_sfixed32 },
                    |m: &mut TestAllTypes| { &mut m.default_sfixed32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSfixed64>(
                    "default_sfixed64",
                    |m: &TestAllTypes| { &m.default_sfixed64 },
                    |m: &mut TestAllTypes| { &mut m.default_sfixed64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "default_float",
                    |m: &TestAllTypes| { &m.default_float },
                    |m: &mut TestAllTypes| { &mut m.default_float },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "default_double",
                    |m: &TestAllTypes| { &m.default_double },
                    |m: &mut TestAllTypes| { &mut m.default_double },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "default_bool",
                    |m: &TestAllTypes| { &m.default_bool },
                    |m: &mut TestAllTypes| { &mut m.default_bool },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "default_string",
                    |m: &TestAllTypes| { &m.default_string },
                    |m: &mut TestAllTypes| { &mut m.default_string },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "default_bytes",
                    |m: &TestAllTypes| { &m.default_bytes },
                    |m: &mut TestAllTypes| { &mut m.default_bytes },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TestAllTypes_NestedEnum>>(
                    "default_nested_enum",
                    |m: &TestAllTypes| { &m.default_nested_enum },
                    |m: &mut TestAllTypes| { &mut m.default_nested_enum },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ForeignEnum>>(
                    "default_foreign_enum",
                    |m: &TestAllTypes| { &m.default_foreign_enum },
                    |m: &mut TestAllTypes| { &mut m.default_foreign_enum },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::unittest_import::ImportEnum>>(
                    "default_import_enum",
                    |m: &TestAllTypes| { &m.default_import_enum },
                    |m: &mut TestAllTypes| { &mut m.default_import_enum },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "default_string_piece",
                    |m: &TestAllTypes| { &m.default_string_piece },
                    |m: &mut TestAllTypes| { &mut m.default_string_piece },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "default_cord",
                    |m: &TestAllTypes| { &m.default_cord },
                    |m: &mut TestAllTypes| { &mut m.default_cord },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                    "oneof_uint32",
                    TestAllTypes::has_oneof_uint32,
                    TestAllTypes::get_oneof_uint32,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TestAllTypes_NestedMessage>(
                    "oneof_nested_message",
                    TestAllTypes::has_oneof_nested_message,
                    TestAllTypes::get_oneof_nested_message,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "oneof_string",
                    TestAllTypes::has_oneof_string,
                    TestAllTypes::get_oneof_string,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "oneof_bytes",
                    TestAllTypes::has_oneof_bytes,
                    TestAllTypes::get_oneof_bytes,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestAllTypes>(
                    "TestAllTypes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestAllTypes {
        static mut instance: ::protobuf::lazy::Lazy<TestAllTypes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestAllTypes,
        };
        unsafe {
            instance.get(TestAllTypes::new)
        }
    }
}

impl ::protobuf::Clear for TestAllTypes {
    fn clear(&mut self) {
        self.clear_optional_int32();
        self.clear_optional_int64();
        self.clear_optional_uint32();
        self.clear_optional_uint64();
        self.clear_optional_sint32();
        self.clear_optional_sint64();
        self.clear_optional_fixed32();
        self.clear_optional_fixed64();
        self.clear_optional_sfixed32();
        self.clear_optional_sfixed64();
        self.clear_optional_float();
        self.clear_optional_double();
        self.clear_optional_bool();
        self.clear_optional_string();
        self.clear_optional_bytes();
        self.clear_optional_nested_message();
        self.clear_optional_foreign_message();
        self.clear_optional_import_message();
        self.clear_optional_nested_enum();
        self.clear_optional_foreign_enum();
        self.clear_optional_import_enum();
        self.clear_optional_string_piece();
        self.clear_optional_cord();
        self.clear_optional_public_import_message();
        self.clear_optional_lazy_message();
        self.clear_repeated_int32();
        self.clear_repeated_int64();
        self.clear_repeated_uint32();
        self.clear_repeated_uint64();
        self.clear_repeated_sint32();
        self.clear_repeated_sint64();
        self.clear_repeated_fixed32();
        self.clear_repeated_fixed64();
        self.clear_repeated_sfixed32();
        self.clear_repeated_sfixed64();
        self.clear_repeated_float();
        self.clear_repeated_double();
        self.clear_repeated_bool();
        self.clear_repeated_string();
        self.clear_repeated_bytes();
        self.clear_repeated_nested_message();
        self.clear_repeated_foreign_message();
        self.clear_repeated_import_message();
        self.clear_repeated_nested_enum();
        self.clear_repeated_foreign_enum();
        self.clear_repeated_import_enum();
        self.clear_repeated_string_piece();
        self.clear_repeated_cord();
        self.clear_repeated_lazy_message();
        self.clear_default_int32();
        self.clear_default_int64();
        self.clear_default_uint32();
        self.clear_default_uint64();
        self.clear_default_sint32();
        self.clear_default_sint64();
        self.clear_default_fixed32();
        self.clear_default_fixed64();
        self.clear_default_sfixed32();
        self.clear_default_sfixed64();
        self.clear_default_float();
        self.clear_default_double();
        self.clear_default_bool();
        self.clear_default_string();
        self.clear_default_bytes();
        self.clear_default_nested_enum();
        self.clear_default_foreign_enum();
        self.clear_default_import_enum();
        self.clear_default_string_piece();
        self.clear_default_cord();
        self.clear_oneof_uint32();
        self.clear_oneof_nested_message();
        self.clear_oneof_string();
        self.clear_oneof_bytes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestAllTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestAllTypes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestAllTypes_NestedMessage {
    // message fields
    bb: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestAllTypes_NestedMessage {
    pub fn new() -> TestAllTypes_NestedMessage {
        ::std::default::Default::default()
    }

    // optional int32 bb = 1;

    pub fn clear_bb(&mut self) {
        self.bb = ::std::option::Option::None;
    }

    pub fn has_bb(&self) -> bool {
        self.bb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bb(&mut self, v: i32) {
        self.bb = ::std::option::Option::Some(v);
    }

    pub fn get_bb(&self) -> i32 {
        self.bb.unwrap_or(0)
    }
}

impl ::protobuf::Message for TestAllTypes_NestedMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bb = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bb {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bb {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestAllTypes_NestedMessage {
        TestAllTypes_NestedMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "bb",
                    |m: &TestAllTypes_NestedMessage| { &m.bb },
                    |m: &mut TestAllTypes_NestedMessage| { &mut m.bb },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestAllTypes_NestedMessage>(
                    "TestAllTypes_NestedMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestAllTypes_NestedMessage {
        static mut instance: ::protobuf::lazy::Lazy<TestAllTypes_NestedMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestAllTypes_NestedMessage,
        };
        unsafe {
            instance.get(TestAllTypes_NestedMessage::new)
        }
    }
}

impl ::protobuf::Clear for TestAllTypes_NestedMessage {
    fn clear(&mut self) {
        self.clear_bb();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestAllTypes_NestedMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestAllTypes_NestedMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TestAllTypes_NestedEnum {
    FOO = 1,
    BAR = 2,
    BAZ = 3,
    NEG = -1,
}

impl ::protobuf::ProtobufEnum for TestAllTypes_NestedEnum {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TestAllTypes_NestedEnum> {
        match value {
            1 => ::std::option::Option::Some(TestAllTypes_NestedEnum::FOO),
            2 => ::std::option::Option::Some(TestAllTypes_NestedEnum::BAR),
            3 => ::std::option::Option::Some(TestAllTypes_NestedEnum::BAZ),
            -1 => ::std::option::Option::Some(TestAllTypes_NestedEnum::NEG),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TestAllTypes_NestedEnum] = &[
            TestAllTypes_NestedEnum::FOO,
            TestAllTypes_NestedEnum::BAR,
            TestAllTypes_NestedEnum::BAZ,
            TestAllTypes_NestedEnum::NEG,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TestAllTypes_NestedEnum", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TestAllTypes_NestedEnum {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TestAllTypes_NestedEnum {
    fn default() -> Self {
        TestAllTypes_NestedEnum::FOO
    }
}

impl ::protobuf::reflect::ProtobufValue for TestAllTypes_NestedEnum {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NestedTestAllTypes {
    // message fields
    child: ::protobuf::SingularPtrField<NestedTestAllTypes>,
    payload: ::protobuf::SingularPtrField<TestAllTypes>,
    repeated_child: ::protobuf::RepeatedField<NestedTestAllTypes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl NestedTestAllTypes {
    pub fn new() -> NestedTestAllTypes {
        ::std::default::Default::default()
    }

    // optional .protobuf_unittest.NestedTestAllTypes child = 1;

    pub fn clear_child(&mut self) {
        self.child.clear();
    }

    pub fn has_child(&self) -> bool {
        self.child.is_some()
    }

    // Param is passed by value, moved
    pub fn set_child(&mut self, v: NestedTestAllTypes) {
        self.child = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_child(&mut self) -> &mut NestedTestAllTypes {
        if self.child.is_none() {
            self.child.set_default();
        }
        self.child.as_mut().unwrap()
    }

    // Take field
    pub fn take_child(&mut self) -> NestedTestAllTypes {
        self.child.take().unwrap_or_else(|| NestedTestAllTypes::new())
    }

    pub fn get_child(&self) -> &NestedTestAllTypes {
        self.child.as_ref().unwrap_or_else(|| NestedTestAllTypes::default_instance())
    }

    // optional .protobuf_unittest.TestAllTypes payload = 2;

    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: TestAllTypes) {
        self.payload = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut TestAllTypes {
        if self.payload.is_none() {
            self.payload.set_default();
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> TestAllTypes {
        self.payload.take().unwrap_or_else(|| TestAllTypes::new())
    }

    pub fn get_payload(&self) -> &TestAllTypes {
        self.payload.as_ref().unwrap_or_else(|| TestAllTypes::default_instance())
    }

    // repeated .protobuf_unittest.NestedTestAllTypes repeated_child = 3;

    pub fn clear_repeated_child(&mut self) {
        self.repeated_child.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_child(&mut self, v: ::protobuf::RepeatedField<NestedTestAllTypes>) {
        self.repeated_child = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_child(&mut self) -> &mut ::protobuf::RepeatedField<NestedTestAllTypes> {
        &mut self.repeated_child
    }

    // Take field
    pub fn take_repeated_child(&mut self) -> ::protobuf::RepeatedField<NestedTestAllTypes> {
        ::std::mem::replace(&mut self.repeated_child, ::protobuf::RepeatedField::new())
    }

    pub fn get_repeated_child(&self) -> &[NestedTestAllTypes] {
        &self.repeated_child
    }
}

impl ::protobuf::Message for NestedTestAllTypes {
    fn is_initialized(&self) -> bool {
        for v in &self.child {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.payload {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.repeated_child {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.child)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.payload)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.repeated_child)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.child.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.repeated_child {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.child.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.payload.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.repeated_child {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NestedTestAllTypes {
        NestedTestAllTypes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NestedTestAllTypes>>(
                    "child",
                    |m: &NestedTestAllTypes| { &m.child },
                    |m: &mut NestedTestAllTypes| { &mut m.child },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestAllTypes>>(
                    "payload",
                    |m: &NestedTestAllTypes| { &m.payload },
                    |m: &mut NestedTestAllTypes| { &mut m.payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NestedTestAllTypes>>(
                    "repeated_child",
                    |m: &NestedTestAllTypes| { &m.repeated_child },
                    |m: &mut NestedTestAllTypes| { &mut m.repeated_child },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NestedTestAllTypes>(
                    "NestedTestAllTypes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NestedTestAllTypes {
        static mut instance: ::protobuf::lazy::Lazy<NestedTestAllTypes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NestedTestAllTypes,
        };
        unsafe {
            instance.get(NestedTestAllTypes::new)
        }
    }
}

impl ::protobuf::Clear for NestedTestAllTypes {
    fn clear(&mut self) {
        self.clear_child();
        self.clear_payload();
        self.clear_repeated_child();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NestedTestAllTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NestedTestAllTypes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestDeprecatedFields {
    // message fields
    deprecated_int32: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestDeprecatedFields {
    pub fn new() -> TestDeprecatedFields {
        ::std::default::Default::default()
    }

    // optional int32 deprecated_int32 = 1;

    pub fn clear_deprecated_int32(&mut self) {
        self.deprecated_int32 = ::std::option::Option::None;
    }

    pub fn has_deprecated_int32(&self) -> bool {
        self.deprecated_int32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_int32(&mut self, v: i32) {
        self.deprecated_int32 = ::std::option::Option::Some(v);
    }

    pub fn get_deprecated_int32(&self) -> i32 {
        self.deprecated_int32.unwrap_or(0)
    }
}

impl ::protobuf::Message for TestDeprecatedFields {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.deprecated_int32 = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.deprecated_int32 {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.deprecated_int32 {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestDeprecatedFields {
        TestDeprecatedFields::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "deprecated_int32",
                    |m: &TestDeprecatedFields| { &m.deprecated_int32 },
                    |m: &mut TestDeprecatedFields| { &mut m.deprecated_int32 },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestDeprecatedFields>(
                    "TestDeprecatedFields",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestDeprecatedFields {
        static mut instance: ::protobuf::lazy::Lazy<TestDeprecatedFields> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestDeprecatedFields,
        };
        unsafe {
            instance.get(TestDeprecatedFields::new)
        }
    }
}

impl ::protobuf::Clear for TestDeprecatedFields {
    fn clear(&mut self) {
        self.clear_deprecated_int32();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestDeprecatedFields {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestDeprecatedFields {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ForeignMessage {
    // message fields
    c: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ForeignMessage {
    pub fn new() -> ForeignMessage {
        ::std::default::Default::default()
    }

    // optional int32 c = 1;

    pub fn clear_c(&mut self) {
        self.c = ::std::option::Option::None;
    }

    pub fn has_c(&self) -> bool {
        self.c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_c(&mut self, v: i32) {
        self.c = ::std::option::Option::Some(v);
    }

    pub fn get_c(&self) -> i32 {
        self.c.unwrap_or(0)
    }
}

impl ::protobuf::Message for ForeignMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.c = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.c {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.c {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ForeignMessage {
        ForeignMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "c",
                    |m: &ForeignMessage| { &m.c },
                    |m: &mut ForeignMessage| { &mut m.c },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ForeignMessage>(
                    "ForeignMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ForeignMessage {
        static mut instance: ::protobuf::lazy::Lazy<ForeignMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ForeignMessage,
        };
        unsafe {
            instance.get(ForeignMessage::new)
        }
    }
}

impl ::protobuf::Clear for ForeignMessage {
    fn clear(&mut self) {
        self.clear_c();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ForeignMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ForeignMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestReservedFields {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestReservedFields {
    pub fn new() -> TestReservedFields {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TestReservedFields {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestReservedFields {
        TestReservedFields::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<TestReservedFields>(
                    "TestReservedFields",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestReservedFields {
        static mut instance: ::protobuf::lazy::Lazy<TestReservedFields> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestReservedFields,
        };
        unsafe {
            instance.get(TestReservedFields::new)
        }
    }
}

impl ::protobuf::Clear for TestReservedFields {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestReservedFields {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestReservedFields {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestAllExtensions {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestAllExtensions {
    pub fn new() -> TestAllExtensions {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TestAllExtensions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestAllExtensions {
        TestAllExtensions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<TestAllExtensions>(
                    "TestAllExtensions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestAllExtensions {
        static mut instance: ::protobuf::lazy::Lazy<TestAllExtensions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestAllExtensions,
        };
        unsafe {
            instance.get(TestAllExtensions::new)
        }
    }
}

impl ::protobuf::Clear for TestAllExtensions {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestAllExtensions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestAllExtensions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestNestedExtension {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestNestedExtension {
    pub fn new() -> TestNestedExtension {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TestNestedExtension {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestNestedExtension {
        TestNestedExtension::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<TestNestedExtension>(
                    "TestNestedExtension",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestNestedExtension {
        static mut instance: ::protobuf::lazy::Lazy<TestNestedExtension> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestNestedExtension,
        };
        unsafe {
            instance.get(TestNestedExtension::new)
        }
    }
}

impl ::protobuf::Clear for TestNestedExtension {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestNestedExtension {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestNestedExtension {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestRequired {
    // message fields
    a: ::std::option::Option<i32>,
    dummy2: ::std::option::Option<i32>,
    b: ::std::option::Option<i32>,
    dummy4: ::std::option::Option<i32>,
    dummy5: ::std::option::Option<i32>,
    dummy6: ::std::option::Option<i32>,
    dummy7: ::std::option::Option<i32>,
    dummy8: ::std::option::Option<i32>,
    dummy9: ::std::option::Option<i32>,
    dummy10: ::std::option::Option<i32>,
    dummy11: ::std::option::Option<i32>,
    dummy12: ::std::option::Option<i32>,
    dummy13: ::std::option::Option<i32>,
    dummy14: ::std::option::Option<i32>,
    dummy15: ::std::option::Option<i32>,
    dummy16: ::std::option::Option<i32>,
    dummy17: ::std::option::Option<i32>,
    dummy18: ::std::option::Option<i32>,
    dummy19: ::std::option::Option<i32>,
    dummy20: ::std::option::Option<i32>,
    dummy21: ::std::option::Option<i32>,
    dummy22: ::std::option::Option<i32>,
    dummy23: ::std::option::Option<i32>,
    dummy24: ::std::option::Option<i32>,
    dummy25: ::std::option::Option<i32>,
    dummy26: ::std::option::Option<i32>,
    dummy27: ::std::option::Option<i32>,
    dummy28: ::std::option::Option<i32>,
    dummy29: ::std::option::Option<i32>,
    dummy30: ::std::option::Option<i32>,
    dummy31: ::std::option::Option<i32>,
    dummy32: ::std::option::Option<i32>,
    c: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestRequired {
    pub fn new() -> TestRequired {
        ::std::default::Default::default()
    }

    // required int32 a = 1;

    pub fn clear_a(&mut self) {
        self.a = ::std::option::Option::None;
    }

    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_a(&mut self, v: i32) {
        self.a = ::std::option::Option::Some(v);
    }

    pub fn get_a(&self) -> i32 {
        self.a.unwrap_or(0)
    }

    // optional int32 dummy2 = 2;

    pub fn clear_dummy2(&mut self) {
        self.dummy2 = ::std::option::Option::None;
    }

    pub fn has_dummy2(&self) -> bool {
        self.dummy2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy2(&mut self, v: i32) {
        self.dummy2 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy2(&self) -> i32 {
        self.dummy2.unwrap_or(0)
    }

    // required int32 b = 3;

    pub fn clear_b(&mut self) {
        self.b = ::std::option::Option::None;
    }

    pub fn has_b(&self) -> bool {
        self.b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b(&mut self, v: i32) {
        self.b = ::std::option::Option::Some(v);
    }

    pub fn get_b(&self) -> i32 {
        self.b.unwrap_or(0)
    }

    // optional int32 dummy4 = 4;

    pub fn clear_dummy4(&mut self) {
        self.dummy4 = ::std::option::Option::None;
    }

    pub fn has_dummy4(&self) -> bool {
        self.dummy4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy4(&mut self, v: i32) {
        self.dummy4 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy4(&self) -> i32 {
        self.dummy4.unwrap_or(0)
    }

    // optional int32 dummy5 = 5;

    pub fn clear_dummy5(&mut self) {
        self.dummy5 = ::std::option::Option::None;
    }

    pub fn has_dummy5(&self) -> bool {
        self.dummy5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy5(&mut self, v: i32) {
        self.dummy5 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy5(&self) -> i32 {
        self.dummy5.unwrap_or(0)
    }

    // optional int32 dummy6 = 6;

    pub fn clear_dummy6(&mut self) {
        self.dummy6 = ::std::option::Option::None;
    }

    pub fn has_dummy6(&self) -> bool {
        self.dummy6.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy6(&mut self, v: i32) {
        self.dummy6 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy6(&self) -> i32 {
        self.dummy6.unwrap_or(0)
    }

    // optional int32 dummy7 = 7;

    pub fn clear_dummy7(&mut self) {
        self.dummy7 = ::std::option::Option::None;
    }

    pub fn has_dummy7(&self) -> bool {
        self.dummy7.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy7(&mut self, v: i32) {
        self.dummy7 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy7(&self) -> i32 {
        self.dummy7.unwrap_or(0)
    }

    // optional int32 dummy8 = 8;

    pub fn clear_dummy8(&mut self) {
        self.dummy8 = ::std::option::Option::None;
    }

    pub fn has_dummy8(&self) -> bool {
        self.dummy8.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy8(&mut self, v: i32) {
        self.dummy8 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy8(&self) -> i32 {
        self.dummy8.unwrap_or(0)
    }

    // optional int32 dummy9 = 9;

    pub fn clear_dummy9(&mut self) {
        self.dummy9 = ::std::option::Option::None;
    }

    pub fn has_dummy9(&self) -> bool {
        self.dummy9.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy9(&mut self, v: i32) {
        self.dummy9 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy9(&self) -> i32 {
        self.dummy9.unwrap_or(0)
    }

    // optional int32 dummy10 = 10;

    pub fn clear_dummy10(&mut self) {
        self.dummy10 = ::std::option::Option::None;
    }

    pub fn has_dummy10(&self) -> bool {
        self.dummy10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy10(&mut self, v: i32) {
        self.dummy10 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy10(&self) -> i32 {
        self.dummy10.unwrap_or(0)
    }

    // optional int32 dummy11 = 11;

    pub fn clear_dummy11(&mut self) {
        self.dummy11 = ::std::option::Option::None;
    }

    pub fn has_dummy11(&self) -> bool {
        self.dummy11.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy11(&mut self, v: i32) {
        self.dummy11 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy11(&self) -> i32 {
        self.dummy11.unwrap_or(0)
    }

    // optional int32 dummy12 = 12;

    pub fn clear_dummy12(&mut self) {
        self.dummy12 = ::std::option::Option::None;
    }

    pub fn has_dummy12(&self) -> bool {
        self.dummy12.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy12(&mut self, v: i32) {
        self.dummy12 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy12(&self) -> i32 {
        self.dummy12.unwrap_or(0)
    }

    // optional int32 dummy13 = 13;

    pub fn clear_dummy13(&mut self) {
        self.dummy13 = ::std::option::Option::None;
    }

    pub fn has_dummy13(&self) -> bool {
        self.dummy13.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy13(&mut self, v: i32) {
        self.dummy13 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy13(&self) -> i32 {
        self.dummy13.unwrap_or(0)
    }

    // optional int32 dummy14 = 14;

    pub fn clear_dummy14(&mut self) {
        self.dummy14 = ::std::option::Option::None;
    }

    pub fn has_dummy14(&self) -> bool {
        self.dummy14.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy14(&mut self, v: i32) {
        self.dummy14 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy14(&self) -> i32 {
        self.dummy14.unwrap_or(0)
    }

    // optional int32 dummy15 = 15;

    pub fn clear_dummy15(&mut self) {
        self.dummy15 = ::std::option::Option::None;
    }

    pub fn has_dummy15(&self) -> bool {
        self.dummy15.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy15(&mut self, v: i32) {
        self.dummy15 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy15(&self) -> i32 {
        self.dummy15.unwrap_or(0)
    }

    // optional int32 dummy16 = 16;

    pub fn clear_dummy16(&mut self) {
        self.dummy16 = ::std::option::Option::None;
    }

    pub fn has_dummy16(&self) -> bool {
        self.dummy16.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy16(&mut self, v: i32) {
        self.dummy16 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy16(&self) -> i32 {
        self.dummy16.unwrap_or(0)
    }

    // optional int32 dummy17 = 17;

    pub fn clear_dummy17(&mut self) {
        self.dummy17 = ::std::option::Option::None;
    }

    pub fn has_dummy17(&self) -> bool {
        self.dummy17.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy17(&mut self, v: i32) {
        self.dummy17 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy17(&self) -> i32 {
        self.dummy17.unwrap_or(0)
    }

    // optional int32 dummy18 = 18;

    pub fn clear_dummy18(&mut self) {
        self.dummy18 = ::std::option::Option::None;
    }

    pub fn has_dummy18(&self) -> bool {
        self.dummy18.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy18(&mut self, v: i32) {
        self.dummy18 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy18(&self) -> i32 {
        self.dummy18.unwrap_or(0)
    }

    // optional int32 dummy19 = 19;

    pub fn clear_dummy19(&mut self) {
        self.dummy19 = ::std::option::Option::None;
    }

    pub fn has_dummy19(&self) -> bool {
        self.dummy19.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy19(&mut self, v: i32) {
        self.dummy19 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy19(&self) -> i32 {
        self.dummy19.unwrap_or(0)
    }

    // optional int32 dummy20 = 20;

    pub fn clear_dummy20(&mut self) {
        self.dummy20 = ::std::option::Option::None;
    }

    pub fn has_dummy20(&self) -> bool {
        self.dummy20.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy20(&mut self, v: i32) {
        self.dummy20 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy20(&self) -> i32 {
        self.dummy20.unwrap_or(0)
    }

    // optional int32 dummy21 = 21;

    pub fn clear_dummy21(&mut self) {
        self.dummy21 = ::std::option::Option::None;
    }

    pub fn has_dummy21(&self) -> bool {
        self.dummy21.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy21(&mut self, v: i32) {
        self.dummy21 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy21(&self) -> i32 {
        self.dummy21.unwrap_or(0)
    }

    // optional int32 dummy22 = 22;

    pub fn clear_dummy22(&mut self) {
        self.dummy22 = ::std::option::Option::None;
    }

    pub fn has_dummy22(&self) -> bool {
        self.dummy22.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy22(&mut self, v: i32) {
        self.dummy22 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy22(&self) -> i32 {
        self.dummy22.unwrap_or(0)
    }

    // optional int32 dummy23 = 23;

    pub fn clear_dummy23(&mut self) {
        self.dummy23 = ::std::option::Option::None;
    }

    pub fn has_dummy23(&self) -> bool {
        self.dummy23.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy23(&mut self, v: i32) {
        self.dummy23 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy23(&self) -> i32 {
        self.dummy23.unwrap_or(0)
    }

    // optional int32 dummy24 = 24;

    pub fn clear_dummy24(&mut self) {
        self.dummy24 = ::std::option::Option::None;
    }

    pub fn has_dummy24(&self) -> bool {
        self.dummy24.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy24(&mut self, v: i32) {
        self.dummy24 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy24(&self) -> i32 {
        self.dummy24.unwrap_or(0)
    }

    // optional int32 dummy25 = 25;

    pub fn clear_dummy25(&mut self) {
        self.dummy25 = ::std::option::Option::None;
    }

    pub fn has_dummy25(&self) -> bool {
        self.dummy25.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy25(&mut self, v: i32) {
        self.dummy25 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy25(&self) -> i32 {
        self.dummy25.unwrap_or(0)
    }

    // optional int32 dummy26 = 26;

    pub fn clear_dummy26(&mut self) {
        self.dummy26 = ::std::option::Option::None;
    }

    pub fn has_dummy26(&self) -> bool {
        self.dummy26.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy26(&mut self, v: i32) {
        self.dummy26 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy26(&self) -> i32 {
        self.dummy26.unwrap_or(0)
    }

    // optional int32 dummy27 = 27;

    pub fn clear_dummy27(&mut self) {
        self.dummy27 = ::std::option::Option::None;
    }

    pub fn has_dummy27(&self) -> bool {
        self.dummy27.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy27(&mut self, v: i32) {
        self.dummy27 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy27(&self) -> i32 {
        self.dummy27.unwrap_or(0)
    }

    // optional int32 dummy28 = 28;

    pub fn clear_dummy28(&mut self) {
        self.dummy28 = ::std::option::Option::None;
    }

    pub fn has_dummy28(&self) -> bool {
        self.dummy28.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy28(&mut self, v: i32) {
        self.dummy28 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy28(&self) -> i32 {
        self.dummy28.unwrap_or(0)
    }

    // optional int32 dummy29 = 29;

    pub fn clear_dummy29(&mut self) {
        self.dummy29 = ::std::option::Option::None;
    }

    pub fn has_dummy29(&self) -> bool {
        self.dummy29.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy29(&mut self, v: i32) {
        self.dummy29 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy29(&self) -> i32 {
        self.dummy29.unwrap_or(0)
    }

    // optional int32 dummy30 = 30;

    pub fn clear_dummy30(&mut self) {
        self.dummy30 = ::std::option::Option::None;
    }

    pub fn has_dummy30(&self) -> bool {
        self.dummy30.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy30(&mut self, v: i32) {
        self.dummy30 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy30(&self) -> i32 {
        self.dummy30.unwrap_or(0)
    }

    // optional int32 dummy31 = 31;

    pub fn clear_dummy31(&mut self) {
        self.dummy31 = ::std::option::Option::None;
    }

    pub fn has_dummy31(&self) -> bool {
        self.dummy31.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy31(&mut self, v: i32) {
        self.dummy31 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy31(&self) -> i32 {
        self.dummy31.unwrap_or(0)
    }

    // optional int32 dummy32 = 32;

    pub fn clear_dummy32(&mut self) {
        self.dummy32 = ::std::option::Option::None;
    }

    pub fn has_dummy32(&self) -> bool {
        self.dummy32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy32(&mut self, v: i32) {
        self.dummy32 = ::std::option::Option::Some(v);
    }

    pub fn get_dummy32(&self) -> i32 {
        self.dummy32.unwrap_or(0)
    }

    // required int32 c = 33;

    pub fn clear_c(&mut self) {
        self.c = ::std::option::Option::None;
    }

    pub fn has_c(&self) -> bool {
        self.c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_c(&mut self, v: i32) {
        self.c = ::std::option::Option::Some(v);
    }

    pub fn get_c(&self) -> i32 {
        self.c.unwrap_or(0)
    }
}

impl ::protobuf::Message for TestRequired {
    fn is_initialized(&self) -> bool {
        if self.a.is_none() {
            return false;
        }
        if self.b.is_none() {
            return false;
        }
        if self.c.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.a = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy2 = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.b = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy4 = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy5 = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy6 = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy7 = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy8 = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy9 = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy10 = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy11 = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy12 = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy13 = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy14 = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy15 = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy16 = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy17 = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy18 = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy19 = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy20 = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy21 = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy22 = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy23 = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy24 = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy25 = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy26 = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy27 = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy28 = ::std::option::Option::Some(tmp);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy29 = ::std::option::Option::Some(tmp);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy30 = ::std::option::Option::Some(tmp);
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy31 = ::std::option::Option::Some(tmp);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy32 = ::std::option::Option::Some(tmp);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.c = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.a {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy2 {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.b {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy4 {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy5 {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy6 {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy7 {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy8 {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy9 {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy10 {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy11 {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy12 {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy13 {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy14 {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy15 {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy16 {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy17 {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy18 {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy19 {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy20 {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy21 {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy22 {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy23 {
            my_size += ::protobuf::rt::value_size(23, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy24 {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy25 {
            my_size += ::protobuf::rt::value_size(25, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy26 {
            my_size += ::protobuf::rt::value_size(26, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy27 {
            my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy28 {
            my_size += ::protobuf::rt::value_size(28, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy29 {
            my_size += ::protobuf::rt::value_size(29, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy30 {
            my_size += ::protobuf::rt::value_size(30, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy31 {
            my_size += ::protobuf::rt::value_size(31, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dummy32 {
            my_size += ::protobuf::rt::value_size(32, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.c {
            my_size += ::protobuf::rt::value_size(33, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.a {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.dummy2 {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.b {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.dummy4 {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.dummy5 {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.dummy6 {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.dummy7 {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.dummy8 {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.dummy9 {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.dummy10 {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.dummy11 {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.dummy12 {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.dummy13 {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.dummy14 {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.dummy15 {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.dummy16 {
            os.write_int32(16, v)?;
        }
        if let Some(v) = self.dummy17 {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.dummy18 {
            os.write_int32(18, v)?;
        }
        if let Some(v) = self.dummy19 {
            os.write_int32(19, v)?;
        }
        if let Some(v) = self.dummy20 {
            os.write_int32(20, v)?;
        }
        if let Some(v) = self.dummy21 {
            os.write_int32(21, v)?;
        }
        if let Some(v) = self.dummy22 {
            os.write_int32(22, v)?;
        }
        if let Some(v) = self.dummy23 {
            os.write_int32(23, v)?;
        }
        if let Some(v) = self.dummy24 {
            os.write_int32(24, v)?;
        }
        if let Some(v) = self.dummy25 {
            os.write_int32(25, v)?;
        }
        if let Some(v) = self.dummy26 {
            os.write_int32(26, v)?;
        }
        if let Some(v) = self.dummy27 {
            os.write_int32(27, v)?;
        }
        if let Some(v) = self.dummy28 {
            os.write_int32(28, v)?;
        }
        if let Some(v) = self.dummy29 {
            os.write_int32(29, v)?;
        }
        if let Some(v) = self.dummy30 {
            os.write_int32(30, v)?;
        }
        if let Some(v) = self.dummy31 {
            os.write_int32(31, v)?;
        }
        if let Some(v) = self.dummy32 {
            os.write_int32(32, v)?;
        }
        if let Some(v) = self.c {
            os.write_int32(33, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestRequired {
        TestRequired::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "a",
                    |m: &TestRequired| { &m.a },
                    |m: &mut TestRequired| { &mut m.a },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy2",
                    |m: &TestRequired| { &m.dummy2 },
                    |m: &mut TestRequired| { &mut m.dummy2 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "b",
                    |m: &TestRequired| { &m.b },
                    |m: &mut TestRequired| { &mut m.b },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy4",
                    |m: &TestRequired| { &m.dummy4 },
                    |m: &mut TestRequired| { &mut m.dummy4 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy5",
                    |m: &TestRequired| { &m.dummy5 },
                    |m: &mut TestRequired| { &mut m.dummy5 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy6",
                    |m: &TestRequired| { &m.dummy6 },
                    |m: &mut TestRequired| { &mut m.dummy6 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy7",
                    |m: &TestRequired| { &m.dummy7 },
                    |m: &mut TestRequired| { &mut m.dummy7 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy8",
                    |m: &TestRequired| { &m.dummy8 },
                    |m: &mut TestRequired| { &mut m.dummy8 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy9",
                    |m: &TestRequired| { &m.dummy9 },
                    |m: &mut TestRequired| { &mut m.dummy9 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy10",
                    |m: &TestRequired| { &m.dummy10 },
                    |m: &mut TestRequired| { &mut m.dummy10 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy11",
                    |m: &TestRequired| { &m.dummy11 },
                    |m: &mut TestRequired| { &mut m.dummy11 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy12",
                    |m: &TestRequired| { &m.dummy12 },
                    |m: &mut TestRequired| { &mut m.dummy12 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy13",
                    |m: &TestRequired| { &m.dummy13 },
                    |m: &mut TestRequired| { &mut m.dummy13 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy14",
                    |m: &TestRequired| { &m.dummy14 },
                    |m: &mut TestRequired| { &mut m.dummy14 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy15",
                    |m: &TestRequired| { &m.dummy15 },
                    |m: &mut TestRequired| { &mut m.dummy15 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy16",
                    |m: &TestRequired| { &m.dummy16 },
                    |m: &mut TestRequired| { &mut m.dummy16 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy17",
                    |m: &TestRequired| { &m.dummy17 },
                    |m: &mut TestRequired| { &mut m.dummy17 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy18",
                    |m: &TestRequired| { &m.dummy18 },
                    |m: &mut TestRequired| { &mut m.dummy18 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy19",
                    |m: &TestRequired| { &m.dummy19 },
                    |m: &mut TestRequired| { &mut m.dummy19 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy20",
                    |m: &TestRequired| { &m.dummy20 },
                    |m: &mut TestRequired| { &mut m.dummy20 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy21",
                    |m: &TestRequired| { &m.dummy21 },
                    |m: &mut TestRequired| { &mut m.dummy21 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy22",
                    |m: &TestRequired| { &m.dummy22 },
                    |m: &mut TestRequired| { &mut m.dummy22 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy23",
                    |m: &TestRequired| { &m.dummy23 },
                    |m: &mut TestRequired| { &mut m.dummy23 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy24",
                    |m: &TestRequired| { &m.dummy24 },
                    |m: &mut TestRequired| { &mut m.dummy24 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy25",
                    |m: &TestRequired| { &m.dummy25 },
                    |m: &mut TestRequired| { &mut m.dummy25 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy26",
                    |m: &TestRequired| { &m.dummy26 },
                    |m: &mut TestRequired| { &mut m.dummy26 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy27",
                    |m: &TestRequired| { &m.dummy27 },
                    |m: &mut TestRequired| { &mut m.dummy27 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy28",
                    |m: &TestRequired| { &m.dummy28 },
                    |m: &mut TestRequired| { &mut m.dummy28 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy29",
                    |m: &TestRequired| { &m.dummy29 },
                    |m: &mut TestRequired| { &mut m.dummy29 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy30",
                    |m: &TestRequired| { &m.dummy30 },
                    |m: &mut TestRequired| { &mut m.dummy30 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy31",
                    |m: &TestRequired| { &m.dummy31 },
                    |m: &mut TestRequired| { &mut m.dummy31 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy32",
                    |m: &TestRequired| { &m.dummy32 },
                    |m: &mut TestRequired| { &mut m.dummy32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "c",
                    |m: &TestRequired| { &m.c },
                    |m: &mut TestRequired| { &mut m.c },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestRequired>(
                    "TestRequired",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestRequired {
        static mut instance: ::protobuf::lazy::Lazy<TestRequired> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestRequired,
        };
        unsafe {
            instance.get(TestRequired::new)
        }
    }
}

impl ::protobuf::Clear for TestRequired {
    fn clear(&mut self) {
        self.clear_a();
        self.clear_dummy2();
        self.clear_b();
        self.clear_dummy4();
        self.clear_dummy5();
        self.clear_dummy6();
        self.clear_dummy7();
        self.clear_dummy8();
        self.clear_dummy9();
        self.clear_dummy10();
        self.clear_dummy11();
        self.clear_dummy12();
        self.clear_dummy13();
        self.clear_dummy14();
        self.clear_dummy15();
        self.clear_dummy16();
        self.clear_dummy17();
        self.clear_dummy18();
        self.clear_dummy19();
        self.clear_dummy20();
        self.clear_dummy21();
        self.clear_dummy22();
        self.clear_dummy23();
        self.clear_dummy24();
        self.clear_dummy25();
        self.clear_dummy26();
        self.clear_dummy27();
        self.clear_dummy28();
        self.clear_dummy29();
        self.clear_dummy30();
        self.clear_dummy31();
        self.clear_dummy32();
        self.clear_c();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestRequired {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestRequired {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestRequiredForeign {
    // message fields
    optional_message: ::protobuf::SingularPtrField<TestRequired>,
    repeated_message: ::protobuf::RepeatedField<TestRequired>,
    dummy: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestRequiredForeign {
    pub fn new() -> TestRequiredForeign {
        ::std::default::Default::default()
    }

    // optional .protobuf_unittest.TestRequired optional_message = 1;

    pub fn clear_optional_message(&mut self) {
        self.optional_message.clear();
    }

    pub fn has_optional_message(&self) -> bool {
        self.optional_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_message(&mut self, v: TestRequired) {
        self.optional_message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_optional_message(&mut self) -> &mut TestRequired {
        if self.optional_message.is_none() {
            self.optional_message.set_default();
        }
        self.optional_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_optional_message(&mut self) -> TestRequired {
        self.optional_message.take().unwrap_or_else(|| TestRequired::new())
    }

    pub fn get_optional_message(&self) -> &TestRequired {
        self.optional_message.as_ref().unwrap_or_else(|| TestRequired::default_instance())
    }

    // repeated .protobuf_unittest.TestRequired repeated_message = 2;

    pub fn clear_repeated_message(&mut self) {
        self.repeated_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_message(&mut self, v: ::protobuf::RepeatedField<TestRequired>) {
        self.repeated_message = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_message(&mut self) -> &mut ::protobuf::RepeatedField<TestRequired> {
        &mut self.repeated_message
    }

    // Take field
    pub fn take_repeated_message(&mut self) -> ::protobuf::RepeatedField<TestRequired> {
        ::std::mem::replace(&mut self.repeated_message, ::protobuf::RepeatedField::new())
    }

    pub fn get_repeated_message(&self) -> &[TestRequired] {
        &self.repeated_message
    }

    // optional int32 dummy = 3;

    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }

    pub fn get_dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }
}

impl ::protobuf::Message for TestRequiredForeign {
    fn is_initialized(&self) -> bool {
        for v in &self.optional_message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.repeated_message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.optional_message)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.repeated_message)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.optional_message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.repeated_message {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.optional_message.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.repeated_message {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.dummy {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestRequiredForeign {
        TestRequiredForeign::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestRequired>>(
                    "optional_message",
                    |m: &TestRequiredForeign| { &m.optional_message },
                    |m: &mut TestRequiredForeign| { &mut m.optional_message },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestRequired>>(
                    "repeated_message",
                    |m: &TestRequiredForeign| { &m.repeated_message },
                    |m: &mut TestRequiredForeign| { &mut m.repeated_message },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy",
                    |m: &TestRequiredForeign| { &m.dummy },
                    |m: &mut TestRequiredForeign| { &mut m.dummy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestRequiredForeign>(
                    "TestRequiredForeign",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestRequiredForeign {
        static mut instance: ::protobuf::lazy::Lazy<TestRequiredForeign> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestRequiredForeign,
        };
        unsafe {
            instance.get(TestRequiredForeign::new)
        }
    }
}

impl ::protobuf::Clear for TestRequiredForeign {
    fn clear(&mut self) {
        self.clear_optional_message();
        self.clear_repeated_message();
        self.clear_dummy();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestRequiredForeign {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestRequiredForeign {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestForeignNested {
    // message fields
    foreign_nested: ::protobuf::SingularPtrField<TestAllTypes_NestedMessage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestForeignNested {
    pub fn new() -> TestForeignNested {
        ::std::default::Default::default()
    }

    // optional .protobuf_unittest.TestAllTypes.NestedMessage foreign_nested = 1;

    pub fn clear_foreign_nested(&mut self) {
        self.foreign_nested.clear();
    }

    pub fn has_foreign_nested(&self) -> bool {
        self.foreign_nested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_foreign_nested(&mut self, v: TestAllTypes_NestedMessage) {
        self.foreign_nested = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_foreign_nested(&mut self) -> &mut TestAllTypes_NestedMessage {
        if self.foreign_nested.is_none() {
            self.foreign_nested.set_default();
        }
        self.foreign_nested.as_mut().unwrap()
    }

    // Take field
    pub fn take_foreign_nested(&mut self) -> TestAllTypes_NestedMessage {
        self.foreign_nested.take().unwrap_or_else(|| TestAllTypes_NestedMessage::new())
    }

    pub fn get_foreign_nested(&self) -> &TestAllTypes_NestedMessage {
        self.foreign_nested.as_ref().unwrap_or_else(|| TestAllTypes_NestedMessage::default_instance())
    }
}

impl ::protobuf::Message for TestForeignNested {
    fn is_initialized(&self) -> bool {
        for v in &self.foreign_nested {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.foreign_nested)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.foreign_nested.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.foreign_nested.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestForeignNested {
        TestForeignNested::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestAllTypes_NestedMessage>>(
                    "foreign_nested",
                    |m: &TestForeignNested| { &m.foreign_nested },
                    |m: &mut TestForeignNested| { &mut m.foreign_nested },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestForeignNested>(
                    "TestForeignNested",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestForeignNested {
        static mut instance: ::protobuf::lazy::Lazy<TestForeignNested> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestForeignNested,
        };
        unsafe {
            instance.get(TestForeignNested::new)
        }
    }
}

impl ::protobuf::Clear for TestForeignNested {
    fn clear(&mut self) {
        self.clear_foreign_nested();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestForeignNested {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestForeignNested {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestEmptyMessage {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestEmptyMessage {
    pub fn new() -> TestEmptyMessage {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TestEmptyMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestEmptyMessage {
        TestEmptyMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<TestEmptyMessage>(
                    "TestEmptyMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestEmptyMessage {
        static mut instance: ::protobuf::lazy::Lazy<TestEmptyMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestEmptyMessage,
        };
        unsafe {
            instance.get(TestEmptyMessage::new)
        }
    }
}

impl ::protobuf::Clear for TestEmptyMessage {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestEmptyMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestEmptyMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestEmptyMessageWithExtensions {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestEmptyMessageWithExtensions {
    pub fn new() -> TestEmptyMessageWithExtensions {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TestEmptyMessageWithExtensions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestEmptyMessageWithExtensions {
        TestEmptyMessageWithExtensions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<TestEmptyMessageWithExtensions>(
                    "TestEmptyMessageWithExtensions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestEmptyMessageWithExtensions {
        static mut instance: ::protobuf::lazy::Lazy<TestEmptyMessageWithExtensions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestEmptyMessageWithExtensions,
        };
        unsafe {
            instance.get(TestEmptyMessageWithExtensions::new)
        }
    }
}

impl ::protobuf::Clear for TestEmptyMessageWithExtensions {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestEmptyMessageWithExtensions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestEmptyMessageWithExtensions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestMultipleExtensionRanges {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestMultipleExtensionRanges {
    pub fn new() -> TestMultipleExtensionRanges {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TestMultipleExtensionRanges {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestMultipleExtensionRanges {
        TestMultipleExtensionRanges::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<TestMultipleExtensionRanges>(
                    "TestMultipleExtensionRanges",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestMultipleExtensionRanges {
        static mut instance: ::protobuf::lazy::Lazy<TestMultipleExtensionRanges> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestMultipleExtensionRanges,
        };
        unsafe {
            instance.get(TestMultipleExtensionRanges::new)
        }
    }
}

impl ::protobuf::Clear for TestMultipleExtensionRanges {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestMultipleExtensionRanges {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestMultipleExtensionRanges {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestReallyLargeTagNumber {
    // message fields
    a: ::std::option::Option<i32>,
    bb: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestReallyLargeTagNumber {
    pub fn new() -> TestReallyLargeTagNumber {
        ::std::default::Default::default()
    }

    // optional int32 a = 1;

    pub fn clear_a(&mut self) {
        self.a = ::std::option::Option::None;
    }

    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_a(&mut self, v: i32) {
        self.a = ::std::option::Option::Some(v);
    }

    pub fn get_a(&self) -> i32 {
        self.a.unwrap_or(0)
    }

    // optional int32 bb = 268435455;

    pub fn clear_bb(&mut self) {
        self.bb = ::std::option::Option::None;
    }

    pub fn has_bb(&self) -> bool {
        self.bb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bb(&mut self, v: i32) {
        self.bb = ::std::option::Option::Some(v);
    }

    pub fn get_bb(&self) -> i32 {
        self.bb.unwrap_or(0)
    }
}

impl ::protobuf::Message for TestReallyLargeTagNumber {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.a = ::std::option::Option::Some(tmp);
                },
                268435455 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bb = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.a {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bb {
            my_size += ::protobuf::rt::value_size(268435455, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.a {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.bb {
            os.write_int32(268435455, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestReallyLargeTagNumber {
        TestReallyLargeTagNumber::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "a",
                    |m: &TestReallyLargeTagNumber| { &m.a },
                    |m: &mut TestReallyLargeTagNumber| { &mut m.a },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "bb",
                    |m: &TestReallyLargeTagNumber| { &m.bb },
                    |m: &mut TestReallyLargeTagNumber| { &mut m.bb },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestReallyLargeTagNumber>(
                    "TestReallyLargeTagNumber",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestReallyLargeTagNumber {
        static mut instance: ::protobuf::lazy::Lazy<TestReallyLargeTagNumber> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestReallyLargeTagNumber,
        };
        unsafe {
            instance.get(TestReallyLargeTagNumber::new)
        }
    }
}

impl ::protobuf::Clear for TestReallyLargeTagNumber {
    fn clear(&mut self) {
        self.clear_a();
        self.clear_bb();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestReallyLargeTagNumber {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestReallyLargeTagNumber {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestRecursiveMessage {
    // message fields
    a: ::protobuf::SingularPtrField<TestRecursiveMessage>,
    i: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestRecursiveMessage {
    pub fn new() -> TestRecursiveMessage {
        ::std::default::Default::default()
    }

    // optional .protobuf_unittest.TestRecursiveMessage a = 1;

    pub fn clear_a(&mut self) {
        self.a.clear();
    }

    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_a(&mut self, v: TestRecursiveMessage) {
        self.a = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_a(&mut self) -> &mut TestRecursiveMessage {
        if self.a.is_none() {
            self.a.set_default();
        }
        self.a.as_mut().unwrap()
    }

    // Take field
    pub fn take_a(&mut self) -> TestRecursiveMessage {
        self.a.take().unwrap_or_else(|| TestRecursiveMessage::new())
    }

    pub fn get_a(&self) -> &TestRecursiveMessage {
        self.a.as_ref().unwrap_or_else(|| TestRecursiveMessage::default_instance())
    }

    // optional int32 i = 2;

    pub fn clear_i(&mut self) {
        self.i = ::std::option::Option::None;
    }

    pub fn has_i(&self) -> bool {
        self.i.is_some()
    }

    // Param is passed by value, moved
    pub fn set_i(&mut self, v: i32) {
        self.i = ::std::option::Option::Some(v);
    }

    pub fn get_i(&self) -> i32 {
        self.i.unwrap_or(0)
    }
}

impl ::protobuf::Message for TestRecursiveMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.a {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.a)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.i = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.a.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.i {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.a.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.i {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestRecursiveMessage {
        TestRecursiveMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestRecursiveMessage>>(
                    "a",
                    |m: &TestRecursiveMessage| { &m.a },
                    |m: &mut TestRecursiveMessage| { &mut m.a },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "i",
                    |m: &TestRecursiveMessage| { &m.i },
                    |m: &mut TestRecursiveMessage| { &mut m.i },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestRecursiveMessage>(
                    "TestRecursiveMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestRecursiveMessage {
        static mut instance: ::protobuf::lazy::Lazy<TestRecursiveMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestRecursiveMessage,
        };
        unsafe {
            instance.get(TestRecursiveMessage::new)
        }
    }
}

impl ::protobuf::Clear for TestRecursiveMessage {
    fn clear(&mut self) {
        self.clear_a();
        self.clear_i();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestRecursiveMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestRecursiveMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestMutualRecursionA {
    // message fields
    bb: ::protobuf::SingularPtrField<TestMutualRecursionB>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestMutualRecursionA {
    pub fn new() -> TestMutualRecursionA {
        ::std::default::Default::default()
    }

    // optional .protobuf_unittest.TestMutualRecursionB bb = 1;

    pub fn clear_bb(&mut self) {
        self.bb.clear();
    }

    pub fn has_bb(&self) -> bool {
        self.bb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bb(&mut self, v: TestMutualRecursionB) {
        self.bb = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bb(&mut self) -> &mut TestMutualRecursionB {
        if self.bb.is_none() {
            self.bb.set_default();
        }
        self.bb.as_mut().unwrap()
    }

    // Take field
    pub fn take_bb(&mut self) -> TestMutualRecursionB {
        self.bb.take().unwrap_or_else(|| TestMutualRecursionB::new())
    }

    pub fn get_bb(&self) -> &TestMutualRecursionB {
        self.bb.as_ref().unwrap_or_else(|| TestMutualRecursionB::default_instance())
    }
}

impl ::protobuf::Message for TestMutualRecursionA {
    fn is_initialized(&self) -> bool {
        for v in &self.bb {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bb)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.bb.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.bb.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestMutualRecursionA {
        TestMutualRecursionA::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestMutualRecursionB>>(
                    "bb",
                    |m: &TestMutualRecursionA| { &m.bb },
                    |m: &mut TestMutualRecursionA| { &mut m.bb },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestMutualRecursionA>(
                    "TestMutualRecursionA",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestMutualRecursionA {
        static mut instance: ::protobuf::lazy::Lazy<TestMutualRecursionA> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestMutualRecursionA,
        };
        unsafe {
            instance.get(TestMutualRecursionA::new)
        }
    }
}

impl ::protobuf::Clear for TestMutualRecursionA {
    fn clear(&mut self) {
        self.clear_bb();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestMutualRecursionA {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestMutualRecursionA {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestMutualRecursionB {
    // message fields
    a: ::protobuf::SingularPtrField<TestMutualRecursionA>,
    optional_int32: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestMutualRecursionB {
    pub fn new() -> TestMutualRecursionB {
        ::std::default::Default::default()
    }

    // optional .protobuf_unittest.TestMutualRecursionA a = 1;

    pub fn clear_a(&mut self) {
        self.a.clear();
    }

    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_a(&mut self, v: TestMutualRecursionA) {
        self.a = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_a(&mut self) -> &mut TestMutualRecursionA {
        if self.a.is_none() {
            self.a.set_default();
        }
        self.a.as_mut().unwrap()
    }

    // Take field
    pub fn take_a(&mut self) -> TestMutualRecursionA {
        self.a.take().unwrap_or_else(|| TestMutualRecursionA::new())
    }

    pub fn get_a(&self) -> &TestMutualRecursionA {
        self.a.as_ref().unwrap_or_else(|| TestMutualRecursionA::default_instance())
    }

    // optional int32 optional_int32 = 2;

    pub fn clear_optional_int32(&mut self) {
        self.optional_int32 = ::std::option::Option::None;
    }

    pub fn has_optional_int32(&self) -> bool {
        self.optional_int32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_int32(&mut self, v: i32) {
        self.optional_int32 = ::std::option::Option::Some(v);
    }

    pub fn get_optional_int32(&self) -> i32 {
        self.optional_int32.unwrap_or(0)
    }
}

impl ::protobuf::Message for TestMutualRecursionB {
    fn is_initialized(&self) -> bool {
        for v in &self.a {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.a)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.optional_int32 = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.a.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.optional_int32 {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.a.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.optional_int32 {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestMutualRecursionB {
        TestMutualRecursionB::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestMutualRecursionA>>(
                    "a",
                    |m: &TestMutualRecursionB| { &m.a },
                    |m: &mut TestMutualRecursionB| { &mut m.a },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "optional_int32",
                    |m: &TestMutualRecursionB| { &m.optional_int32 },
                    |m: &mut TestMutualRecursionB| { &mut m.optional_int32 },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestMutualRecursionB>(
                    "TestMutualRecursionB",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestMutualRecursionB {
        static mut instance: ::protobuf::lazy::Lazy<TestMutualRecursionB> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestMutualRecursionB,
        };
        unsafe {
            instance.get(TestMutualRecursionB::new)
        }
    }
}

impl ::protobuf::Clear for TestMutualRecursionB {
    fn clear(&mut self) {
        self.clear_a();
        self.clear_optional_int32();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestMutualRecursionB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestMutualRecursionB {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestDupFieldNumber {
    // message fields
    a: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestDupFieldNumber {
    pub fn new() -> TestDupFieldNumber {
        ::std::default::Default::default()
    }

    // optional int32 a = 1;

    pub fn clear_a(&mut self) {
        self.a = ::std::option::Option::None;
    }

    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_a(&mut self, v: i32) {
        self.a = ::std::option::Option::Some(v);
    }

    pub fn get_a(&self) -> i32 {
        self.a.unwrap_or(0)
    }
}

impl ::protobuf::Message for TestDupFieldNumber {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.a = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.a {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.a {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestDupFieldNumber {
        TestDupFieldNumber::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "a",
                    |m: &TestDupFieldNumber| { &m.a },
                    |m: &mut TestDupFieldNumber| { &mut m.a },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestDupFieldNumber>(
                    "TestDupFieldNumber",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestDupFieldNumber {
        static mut instance: ::protobuf::lazy::Lazy<TestDupFieldNumber> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestDupFieldNumber,
        };
        unsafe {
            instance.get(TestDupFieldNumber::new)
        }
    }
}

impl ::protobuf::Clear for TestDupFieldNumber {
    fn clear(&mut self) {
        self.clear_a();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestDupFieldNumber {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestDupFieldNumber {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestEagerMessage {
    // message fields
    sub_message: ::protobuf::SingularPtrField<TestAllTypes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestEagerMessage {
    pub fn new() -> TestEagerMessage {
        ::std::default::Default::default()
    }

    // optional .protobuf_unittest.TestAllTypes sub_message = 1;

    pub fn clear_sub_message(&mut self) {
        self.sub_message.clear();
    }

    pub fn has_sub_message(&self) -> bool {
        self.sub_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sub_message(&mut self, v: TestAllTypes) {
        self.sub_message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sub_message(&mut self) -> &mut TestAllTypes {
        if self.sub_message.is_none() {
            self.sub_message.set_default();
        }
        self.sub_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_sub_message(&mut self) -> TestAllTypes {
        self.sub_message.take().unwrap_or_else(|| TestAllTypes::new())
    }

    pub fn get_sub_message(&self) -> &TestAllTypes {
        self.sub_message.as_ref().unwrap_or_else(|| TestAllTypes::default_instance())
    }
}

impl ::protobuf::Message for TestEagerMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.sub_message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sub_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.sub_message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.sub_message.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestEagerMessage {
        TestEagerMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestAllTypes>>(
                    "sub_message",
                    |m: &TestEagerMessage| { &m.sub_message },
                    |m: &mut TestEagerMessage| { &mut m.sub_message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestEagerMessage>(
                    "TestEagerMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestEagerMessage {
        static mut instance: ::protobuf::lazy::Lazy<TestEagerMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestEagerMessage,
        };
        unsafe {
            instance.get(TestEagerMessage::new)
        }
    }
}

impl ::protobuf::Clear for TestEagerMessage {
    fn clear(&mut self) {
        self.clear_sub_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestEagerMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestEagerMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestLazyMessage {
    // message fields
    sub_message: ::protobuf::SingularPtrField<TestAllTypes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestLazyMessage {
    pub fn new() -> TestLazyMessage {
        ::std::default::Default::default()
    }

    // optional .protobuf_unittest.TestAllTypes sub_message = 1;

    pub fn clear_sub_message(&mut self) {
        self.sub_message.clear();
    }

    pub fn has_sub_message(&self) -> bool {
        self.sub_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sub_message(&mut self, v: TestAllTypes) {
        self.sub_message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sub_message(&mut self) -> &mut TestAllTypes {
        if self.sub_message.is_none() {
            self.sub_message.set_default();
        }
        self.sub_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_sub_message(&mut self) -> TestAllTypes {
        self.sub_message.take().unwrap_or_else(|| TestAllTypes::new())
    }

    pub fn get_sub_message(&self) -> &TestAllTypes {
        self.sub_message.as_ref().unwrap_or_else(|| TestAllTypes::default_instance())
    }
}

impl ::protobuf::Message for TestLazyMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.sub_message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sub_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.sub_message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.sub_message.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestLazyMessage {
        TestLazyMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestAllTypes>>(
                    "sub_message",
                    |m: &TestLazyMessage| { &m.sub_message },
                    |m: &mut TestLazyMessage| { &mut m.sub_message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestLazyMessage>(
                    "TestLazyMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestLazyMessage {
        static mut instance: ::protobuf::lazy::Lazy<TestLazyMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestLazyMessage,
        };
        unsafe {
            instance.get(TestLazyMessage::new)
        }
    }
}

impl ::protobuf::Clear for TestLazyMessage {
    fn clear(&mut self) {
        self.clear_sub_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestLazyMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestLazyMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestNestedMessageHasBits {
    // message fields
    optional_nested_message: ::protobuf::SingularPtrField<TestNestedMessageHasBits_NestedMessage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestNestedMessageHasBits {
    pub fn new() -> TestNestedMessageHasBits {
        ::std::default::Default::default()
    }

    // optional .protobuf_unittest.TestNestedMessageHasBits.NestedMessage optional_nested_message = 1;

    pub fn clear_optional_nested_message(&mut self) {
        self.optional_nested_message.clear();
    }

    pub fn has_optional_nested_message(&self) -> bool {
        self.optional_nested_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_nested_message(&mut self, v: TestNestedMessageHasBits_NestedMessage) {
        self.optional_nested_message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_optional_nested_message(&mut self) -> &mut TestNestedMessageHasBits_NestedMessage {
        if self.optional_nested_message.is_none() {
            self.optional_nested_message.set_default();
        }
        self.optional_nested_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_optional_nested_message(&mut self) -> TestNestedMessageHasBits_NestedMessage {
        self.optional_nested_message.take().unwrap_or_else(|| TestNestedMessageHasBits_NestedMessage::new())
    }

    pub fn get_optional_nested_message(&self) -> &TestNestedMessageHasBits_NestedMessage {
        self.optional_nested_message.as_ref().unwrap_or_else(|| TestNestedMessageHasBits_NestedMessage::default_instance())
    }
}

impl ::protobuf::Message for TestNestedMessageHasBits {
    fn is_initialized(&self) -> bool {
        for v in &self.optional_nested_message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.optional_nested_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.optional_nested_message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.optional_nested_message.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestNestedMessageHasBits {
        TestNestedMessageHasBits::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestNestedMessageHasBits_NestedMessage>>(
                    "optional_nested_message",
                    |m: &TestNestedMessageHasBits| { &m.optional_nested_message },
                    |m: &mut TestNestedMessageHasBits| { &mut m.optional_nested_message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestNestedMessageHasBits>(
                    "TestNestedMessageHasBits",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestNestedMessageHasBits {
        static mut instance: ::protobuf::lazy::Lazy<TestNestedMessageHasBits> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestNestedMessageHasBits,
        };
        unsafe {
            instance.get(TestNestedMessageHasBits::new)
        }
    }
}

impl ::protobuf::Clear for TestNestedMessageHasBits {
    fn clear(&mut self) {
        self.clear_optional_nested_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestNestedMessageHasBits {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestNestedMessageHasBits {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestNestedMessageHasBits_NestedMessage {
    // message fields
    nestedmessage_repeated_int32: ::std::vec::Vec<i32>,
    nestedmessage_repeated_foreignmessage: ::protobuf::RepeatedField<ForeignMessage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestNestedMessageHasBits_NestedMessage {
    pub fn new() -> TestNestedMessageHasBits_NestedMessage {
        ::std::default::Default::default()
    }

    // repeated int32 nestedmessage_repeated_int32 = 1;

    pub fn clear_nestedmessage_repeated_int32(&mut self) {
        self.nestedmessage_repeated_int32.clear();
    }

    // Param is passed by value, moved
    pub fn set_nestedmessage_repeated_int32(&mut self, v: ::std::vec::Vec<i32>) {
        self.nestedmessage_repeated_int32 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nestedmessage_repeated_int32(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.nestedmessage_repeated_int32
    }

    // Take field
    pub fn take_nestedmessage_repeated_int32(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.nestedmessage_repeated_int32, ::std::vec::Vec::new())
    }

    pub fn get_nestedmessage_repeated_int32(&self) -> &[i32] {
        &self.nestedmessage_repeated_int32
    }

    // repeated .protobuf_unittest.ForeignMessage nestedmessage_repeated_foreignmessage = 2;

    pub fn clear_nestedmessage_repeated_foreignmessage(&mut self) {
        self.nestedmessage_repeated_foreignmessage.clear();
    }

    // Param is passed by value, moved
    pub fn set_nestedmessage_repeated_foreignmessage(&mut self, v: ::protobuf::RepeatedField<ForeignMessage>) {
        self.nestedmessage_repeated_foreignmessage = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nestedmessage_repeated_foreignmessage(&mut self) -> &mut ::protobuf::RepeatedField<ForeignMessage> {
        &mut self.nestedmessage_repeated_foreignmessage
    }

    // Take field
    pub fn take_nestedmessage_repeated_foreignmessage(&mut self) -> ::protobuf::RepeatedField<ForeignMessage> {
        ::std::mem::replace(&mut self.nestedmessage_repeated_foreignmessage, ::protobuf::RepeatedField::new())
    }

    pub fn get_nestedmessage_repeated_foreignmessage(&self) -> &[ForeignMessage] {
        &self.nestedmessage_repeated_foreignmessage
    }
}

impl ::protobuf::Message for TestNestedMessageHasBits_NestedMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.nestedmessage_repeated_foreignmessage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.nestedmessage_repeated_int32)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nestedmessage_repeated_foreignmessage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.nestedmessage_repeated_int32 {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.nestedmessage_repeated_foreignmessage {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.nestedmessage_repeated_int32 {
            os.write_int32(1, *v)?;
        };
        for v in &self.nestedmessage_repeated_foreignmessage {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestNestedMessageHasBits_NestedMessage {
        TestNestedMessageHasBits_NestedMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "nestedmessage_repeated_int32",
                    |m: &TestNestedMessageHasBits_NestedMessage| { &m.nestedmessage_repeated_int32 },
                    |m: &mut TestNestedMessageHasBits_NestedMessage| { &mut m.nestedmessage_repeated_int32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ForeignMessage>>(
                    "nestedmessage_repeated_foreignmessage",
                    |m: &TestNestedMessageHasBits_NestedMessage| { &m.nestedmessage_repeated_foreignmessage },
                    |m: &mut TestNestedMessageHasBits_NestedMessage| { &mut m.nestedmessage_repeated_foreignmessage },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestNestedMessageHasBits_NestedMessage>(
                    "TestNestedMessageHasBits_NestedMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestNestedMessageHasBits_NestedMessage {
        static mut instance: ::protobuf::lazy::Lazy<TestNestedMessageHasBits_NestedMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestNestedMessageHasBits_NestedMessage,
        };
        unsafe {
            instance.get(TestNestedMessageHasBits_NestedMessage::new)
        }
    }
}

impl ::protobuf::Clear for TestNestedMessageHasBits_NestedMessage {
    fn clear(&mut self) {
        self.clear_nestedmessage_repeated_int32();
        self.clear_nestedmessage_repeated_foreignmessage();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestNestedMessageHasBits_NestedMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestNestedMessageHasBits_NestedMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestCamelCaseFieldNames {
    // message fields
    PrimitiveField: ::std::option::Option<i32>,
    StringField: ::protobuf::SingularField<::std::string::String>,
    EnumField: ::std::option::Option<ForeignEnum>,
    MessageField: ::protobuf::SingularPtrField<ForeignMessage>,
    StringPieceField: ::protobuf::SingularField<::std::string::String>,
    CordField: ::protobuf::SingularField<::std::string::String>,
    RepeatedPrimitiveField: ::std::vec::Vec<i32>,
    RepeatedStringField: ::protobuf::RepeatedField<::std::string::String>,
    RepeatedEnumField: ::std::vec::Vec<ForeignEnum>,
    RepeatedMessageField: ::protobuf::RepeatedField<ForeignMessage>,
    RepeatedStringPieceField: ::protobuf::RepeatedField<::std::string::String>,
    RepeatedCordField: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestCamelCaseFieldNames {
    pub fn new() -> TestCamelCaseFieldNames {
        ::std::default::Default::default()
    }

    // optional int32 PrimitiveField = 1;

    pub fn clear_PrimitiveField(&mut self) {
        self.PrimitiveField = ::std::option::Option::None;
    }

    pub fn has_PrimitiveField(&self) -> bool {
        self.PrimitiveField.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PrimitiveField(&mut self, v: i32) {
        self.PrimitiveField = ::std::option::Option::Some(v);
    }

    pub fn get_PrimitiveField(&self) -> i32 {
        self.PrimitiveField.unwrap_or(0)
    }

    // optional string StringField = 2;

    pub fn clear_StringField(&mut self) {
        self.StringField.clear();
    }

    pub fn has_StringField(&self) -> bool {
        self.StringField.is_some()
    }

    // Param is passed by value, moved
    pub fn set_StringField(&mut self, v: ::std::string::String) {
        self.StringField = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_StringField(&mut self) -> &mut ::std::string::String {
        if self.StringField.is_none() {
            self.StringField.set_default();
        }
        self.StringField.as_mut().unwrap()
    }

    // Take field
    pub fn take_StringField(&mut self) -> ::std::string::String {
        self.StringField.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_StringField(&self) -> &str {
        match self.StringField.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .protobuf_unittest.ForeignEnum EnumField = 3;

    pub fn clear_EnumField(&mut self) {
        self.EnumField = ::std::option::Option::None;
    }

    pub fn has_EnumField(&self) -> bool {
        self.EnumField.is_some()
    }

    // Param is passed by value, moved
    pub fn set_EnumField(&mut self, v: ForeignEnum) {
        self.EnumField = ::std::option::Option::Some(v);
    }

    pub fn get_EnumField(&self) -> ForeignEnum {
        self.EnumField.unwrap_or(ForeignEnum::FOREIGN_FOO)
    }

    // optional .protobuf_unittest.ForeignMessage MessageField = 4;

    pub fn clear_MessageField(&mut self) {
        self.MessageField.clear();
    }

    pub fn has_MessageField(&self) -> bool {
        self.MessageField.is_some()
    }

    // Param is passed by value, moved
    pub fn set_MessageField(&mut self, v: ForeignMessage) {
        self.MessageField = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_MessageField(&mut self) -> &mut ForeignMessage {
        if self.MessageField.is_none() {
            self.MessageField.set_default();
        }
        self.MessageField.as_mut().unwrap()
    }

    // Take field
    pub fn take_MessageField(&mut self) -> ForeignMessage {
        self.MessageField.take().unwrap_or_else(|| ForeignMessage::new())
    }

    pub fn get_MessageField(&self) -> &ForeignMessage {
        self.MessageField.as_ref().unwrap_or_else(|| ForeignMessage::default_instance())
    }

    // optional string StringPieceField = 5;

    pub fn clear_StringPieceField(&mut self) {
        self.StringPieceField.clear();
    }

    pub fn has_StringPieceField(&self) -> bool {
        self.StringPieceField.is_some()
    }

    // Param is passed by value, moved
    pub fn set_StringPieceField(&mut self, v: ::std::string::String) {
        self.StringPieceField = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_StringPieceField(&mut self) -> &mut ::std::string::String {
        if self.StringPieceField.is_none() {
            self.StringPieceField.set_default();
        }
        self.StringPieceField.as_mut().unwrap()
    }

    // Take field
    pub fn take_StringPieceField(&mut self) -> ::std::string::String {
        self.StringPieceField.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_StringPieceField(&self) -> &str {
        match self.StringPieceField.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string CordField = 6;

    pub fn clear_CordField(&mut self) {
        self.CordField.clear();
    }

    pub fn has_CordField(&self) -> bool {
        self.CordField.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CordField(&mut self, v: ::std::string::String) {
        self.CordField = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CordField(&mut self) -> &mut ::std::string::String {
        if self.CordField.is_none() {
            self.CordField.set_default();
        }
        self.CordField.as_mut().unwrap()
    }

    // Take field
    pub fn take_CordField(&mut self) -> ::std::string::String {
        self.CordField.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_CordField(&self) -> &str {
        match self.CordField.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated int32 RepeatedPrimitiveField = 7;

    pub fn clear_RepeatedPrimitiveField(&mut self) {
        self.RepeatedPrimitiveField.clear();
    }

    // Param is passed by value, moved
    pub fn set_RepeatedPrimitiveField(&mut self, v: ::std::vec::Vec<i32>) {
        self.RepeatedPrimitiveField = v;
    }

    // Mutable pointer to the field.
    pub fn mut_RepeatedPrimitiveField(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.RepeatedPrimitiveField
    }

    // Take field
    pub fn take_RepeatedPrimitiveField(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.RepeatedPrimitiveField, ::std::vec::Vec::new())
    }

    pub fn get_RepeatedPrimitiveField(&self) -> &[i32] {
        &self.RepeatedPrimitiveField
    }

    // repeated string RepeatedStringField = 8;

    pub fn clear_RepeatedStringField(&mut self) {
        self.RepeatedStringField.clear();
    }

    // Param is passed by value, moved
    pub fn set_RepeatedStringField(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.RepeatedStringField = v;
    }

    // Mutable pointer to the field.
    pub fn mut_RepeatedStringField(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.RepeatedStringField
    }

    // Take field
    pub fn take_RepeatedStringField(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.RepeatedStringField, ::protobuf::RepeatedField::new())
    }

    pub fn get_RepeatedStringField(&self) -> &[::std::string::String] {
        &self.RepeatedStringField
    }

    // repeated .protobuf_unittest.ForeignEnum RepeatedEnumField = 9;

    pub fn clear_RepeatedEnumField(&mut self) {
        self.RepeatedEnumField.clear();
    }

    // Param is passed by value, moved
    pub fn set_RepeatedEnumField(&mut self, v: ::std::vec::Vec<ForeignEnum>) {
        self.RepeatedEnumField = v;
    }

    // Mutable pointer to the field.
    pub fn mut_RepeatedEnumField(&mut self) -> &mut ::std::vec::Vec<ForeignEnum> {
        &mut self.RepeatedEnumField
    }

    // Take field
    pub fn take_RepeatedEnumField(&mut self) -> ::std::vec::Vec<ForeignEnum> {
        ::std::mem::replace(&mut self.RepeatedEnumField, ::std::vec::Vec::new())
    }

    pub fn get_RepeatedEnumField(&self) -> &[ForeignEnum] {
        &self.RepeatedEnumField
    }

    // repeated .protobuf_unittest.ForeignMessage RepeatedMessageField = 10;

    pub fn clear_RepeatedMessageField(&mut self) {
        self.RepeatedMessageField.clear();
    }

    // Param is passed by value, moved
    pub fn set_RepeatedMessageField(&mut self, v: ::protobuf::RepeatedField<ForeignMessage>) {
        self.RepeatedMessageField = v;
    }

    // Mutable pointer to the field.
    pub fn mut_RepeatedMessageField(&mut self) -> &mut ::protobuf::RepeatedField<ForeignMessage> {
        &mut self.RepeatedMessageField
    }

    // Take field
    pub fn take_RepeatedMessageField(&mut self) -> ::protobuf::RepeatedField<ForeignMessage> {
        ::std::mem::replace(&mut self.RepeatedMessageField, ::protobuf::RepeatedField::new())
    }

    pub fn get_RepeatedMessageField(&self) -> &[ForeignMessage] {
        &self.RepeatedMessageField
    }

    // repeated string RepeatedStringPieceField = 11;

    pub fn clear_RepeatedStringPieceField(&mut self) {
        self.RepeatedStringPieceField.clear();
    }

    // Param is passed by value, moved
    pub fn set_RepeatedStringPieceField(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.RepeatedStringPieceField = v;
    }

    // Mutable pointer to the field.
    pub fn mut_RepeatedStringPieceField(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.RepeatedStringPieceField
    }

    // Take field
    pub fn take_RepeatedStringPieceField(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.RepeatedStringPieceField, ::protobuf::RepeatedField::new())
    }

    pub fn get_RepeatedStringPieceField(&self) -> &[::std::string::String] {
        &self.RepeatedStringPieceField
    }

    // repeated string RepeatedCordField = 12;

    pub fn clear_RepeatedCordField(&mut self) {
        self.RepeatedCordField.clear();
    }

    // Param is passed by value, moved
    pub fn set_RepeatedCordField(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.RepeatedCordField = v;
    }

    // Mutable pointer to the field.
    pub fn mut_RepeatedCordField(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.RepeatedCordField
    }

    // Take field
    pub fn take_RepeatedCordField(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.RepeatedCordField, ::protobuf::RepeatedField::new())
    }

    pub fn get_RepeatedCordField(&self) -> &[::std::string::String] {
        &self.RepeatedCordField
    }
}

impl ::protobuf::Message for TestCamelCaseFieldNames {
    fn is_initialized(&self) -> bool {
        for v in &self.MessageField {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.RepeatedMessageField {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.PrimitiveField = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.StringField)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.EnumField, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.MessageField)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.StringPieceField)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.CordField)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.RepeatedPrimitiveField)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.RepeatedStringField)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.RepeatedEnumField, 9, &mut self.unknown_fields)?
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.RepeatedMessageField)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.RepeatedStringPieceField)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.RepeatedCordField)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.PrimitiveField {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.StringField.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.EnumField {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(ref v) = self.MessageField.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.StringPieceField.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.CordField.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.RepeatedPrimitiveField {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.RepeatedStringField {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in &self.RepeatedEnumField {
            my_size += ::protobuf::rt::enum_size(9, *value);
        };
        for value in &self.RepeatedMessageField {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.RepeatedStringPieceField {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        for value in &self.RepeatedCordField {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.PrimitiveField {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.StringField.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.EnumField {
            os.write_enum(3, v.value())?;
        }
        if let Some(ref v) = self.MessageField.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.StringPieceField.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.CordField.as_ref() {
            os.write_string(6, &v)?;
        }
        for v in &self.RepeatedPrimitiveField {
            os.write_int32(7, *v)?;
        };
        for v in &self.RepeatedStringField {
            os.write_string(8, &v)?;
        };
        for v in &self.RepeatedEnumField {
            os.write_enum(9, v.value())?;
        };
        for v in &self.RepeatedMessageField {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.RepeatedStringPieceField {
            os.write_string(11, &v)?;
        };
        for v in &self.RepeatedCordField {
            os.write_string(12, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestCamelCaseFieldNames {
        TestCamelCaseFieldNames::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "PrimitiveField",
                    |m: &TestCamelCaseFieldNames| { &m.PrimitiveField },
                    |m: &mut TestCamelCaseFieldNames| { &mut m.PrimitiveField },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "StringField",
                    |m: &TestCamelCaseFieldNames| { &m.StringField },
                    |m: &mut TestCamelCaseFieldNames| { &mut m.StringField },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ForeignEnum>>(
                    "EnumField",
                    |m: &TestCamelCaseFieldNames| { &m.EnumField },
                    |m: &mut TestCamelCaseFieldNames| { &mut m.EnumField },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ForeignMessage>>(
                    "MessageField",
                    |m: &TestCamelCaseFieldNames| { &m.MessageField },
                    |m: &mut TestCamelCaseFieldNames| { &mut m.MessageField },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "StringPieceField",
                    |m: &TestCamelCaseFieldNames| { &m.StringPieceField },
                    |m: &mut TestCamelCaseFieldNames| { &mut m.StringPieceField },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "CordField",
                    |m: &TestCamelCaseFieldNames| { &m.CordField },
                    |m: &mut TestCamelCaseFieldNames| { &mut m.CordField },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "RepeatedPrimitiveField",
                    |m: &TestCamelCaseFieldNames| { &m.RepeatedPrimitiveField },
                    |m: &mut TestCamelCaseFieldNames| { &mut m.RepeatedPrimitiveField },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "RepeatedStringField",
                    |m: &TestCamelCaseFieldNames| { &m.RepeatedStringField },
                    |m: &mut TestCamelCaseFieldNames| { &mut m.RepeatedStringField },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ForeignEnum>>(
                    "RepeatedEnumField",
                    |m: &TestCamelCaseFieldNames| { &m.RepeatedEnumField },
                    |m: &mut TestCamelCaseFieldNames| { &mut m.RepeatedEnumField },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ForeignMessage>>(
                    "RepeatedMessageField",
                    |m: &TestCamelCaseFieldNames| { &m.RepeatedMessageField },
                    |m: &mut TestCamelCaseFieldNames| { &mut m.RepeatedMessageField },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "RepeatedStringPieceField",
                    |m: &TestCamelCaseFieldNames| { &m.RepeatedStringPieceField },
                    |m: &mut TestCamelCaseFieldNames| { &mut m.RepeatedStringPieceField },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "RepeatedCordField",
                    |m: &TestCamelCaseFieldNames| { &m.RepeatedCordField },
                    |m: &mut TestCamelCaseFieldNames| { &mut m.RepeatedCordField },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestCamelCaseFieldNames>(
                    "TestCamelCaseFieldNames",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestCamelCaseFieldNames {
        static mut instance: ::protobuf::lazy::Lazy<TestCamelCaseFieldNames> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestCamelCaseFieldNames,
        };
        unsafe {
            instance.get(TestCamelCaseFieldNames::new)
        }
    }
}

impl ::protobuf::Clear for TestCamelCaseFieldNames {
    fn clear(&mut self) {
        self.clear_PrimitiveField();
        self.clear_StringField();
        self.clear_EnumField();
        self.clear_MessageField();
        self.clear_StringPieceField();
        self.clear_CordField();
        self.clear_RepeatedPrimitiveField();
        self.clear_RepeatedStringField();
        self.clear_RepeatedEnumField();
        self.clear_RepeatedMessageField();
        self.clear_RepeatedStringPieceField();
        self.clear_RepeatedCordField();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestCamelCaseFieldNames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestCamelCaseFieldNames {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestFieldOrderings {
    // message fields
    my_string: ::protobuf::SingularField<::std::string::String>,
    my_int: ::std::option::Option<i64>,
    my_float: ::std::option::Option<f32>,
    optional_nested_message: ::protobuf::SingularPtrField<TestFieldOrderings_NestedMessage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestFieldOrderings {
    pub fn new() -> TestFieldOrderings {
        ::std::default::Default::default()
    }

    // optional string my_string = 11;

    pub fn clear_my_string(&mut self) {
        self.my_string.clear();
    }

    pub fn has_my_string(&self) -> bool {
        self.my_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_string(&mut self, v: ::std::string::String) {
        self.my_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_my_string(&mut self) -> &mut ::std::string::String {
        if self.my_string.is_none() {
            self.my_string.set_default();
        }
        self.my_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_my_string(&mut self) -> ::std::string::String {
        self.my_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_my_string(&self) -> &str {
        match self.my_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 my_int = 1;

    pub fn clear_my_int(&mut self) {
        self.my_int = ::std::option::Option::None;
    }

    pub fn has_my_int(&self) -> bool {
        self.my_int.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_int(&mut self, v: i64) {
        self.my_int = ::std::option::Option::Some(v);
    }

    pub fn get_my_int(&self) -> i64 {
        self.my_int.unwrap_or(0)
    }

    // optional float my_float = 101;

    pub fn clear_my_float(&mut self) {
        self.my_float = ::std::option::Option::None;
    }

    pub fn has_my_float(&self) -> bool {
        self.my_float.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_float(&mut self, v: f32) {
        self.my_float = ::std::option::Option::Some(v);
    }

    pub fn get_my_float(&self) -> f32 {
        self.my_float.unwrap_or(0.)
    }

    // optional .protobuf_unittest.TestFieldOrderings.NestedMessage optional_nested_message = 200;

    pub fn clear_optional_nested_message(&mut self) {
        self.optional_nested_message.clear();
    }

    pub fn has_optional_nested_message(&self) -> bool {
        self.optional_nested_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_nested_message(&mut self, v: TestFieldOrderings_NestedMessage) {
        self.optional_nested_message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_optional_nested_message(&mut self) -> &mut TestFieldOrderings_NestedMessage {
        if self.optional_nested_message.is_none() {
            self.optional_nested_message.set_default();
        }
        self.optional_nested_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_optional_nested_message(&mut self) -> TestFieldOrderings_NestedMessage {
        self.optional_nested_message.take().unwrap_or_else(|| TestFieldOrderings_NestedMessage::new())
    }

    pub fn get_optional_nested_message(&self) -> &TestFieldOrderings_NestedMessage {
        self.optional_nested_message.as_ref().unwrap_or_else(|| TestFieldOrderings_NestedMessage::default_instance())
    }
}

impl ::protobuf::Message for TestFieldOrderings {
    fn is_initialized(&self) -> bool {
        for v in &self.optional_nested_message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.my_string)?;
                },
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.my_int = ::std::option::Option::Some(tmp);
                },
                101 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.my_float = ::std::option::Option::Some(tmp);
                },
                200 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.optional_nested_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.my_string.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.my_int {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.my_float {
            my_size += 6;
        }
        if let Some(ref v) = self.optional_nested_message.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.my_string.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(v) = self.my_int {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.my_float {
            os.write_float(101, v)?;
        }
        if let Some(ref v) = self.optional_nested_message.as_ref() {
            os.write_tag(200, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestFieldOrderings {
        TestFieldOrderings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "my_string",
                    |m: &TestFieldOrderings| { &m.my_string },
                    |m: &mut TestFieldOrderings| { &mut m.my_string },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "my_int",
                    |m: &TestFieldOrderings| { &m.my_int },
                    |m: &mut TestFieldOrderings| { &mut m.my_int },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "my_float",
                    |m: &TestFieldOrderings| { &m.my_float },
                    |m: &mut TestFieldOrderings| { &mut m.my_float },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestFieldOrderings_NestedMessage>>(
                    "optional_nested_message",
                    |m: &TestFieldOrderings| { &m.optional_nested_message },
                    |m: &mut TestFieldOrderings| { &mut m.optional_nested_message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestFieldOrderings>(
                    "TestFieldOrderings",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestFieldOrderings {
        static mut instance: ::protobuf::lazy::Lazy<TestFieldOrderings> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestFieldOrderings,
        };
        unsafe {
            instance.get(TestFieldOrderings::new)
        }
    }
}

impl ::protobuf::Clear for TestFieldOrderings {
    fn clear(&mut self) {
        self.clear_my_string();
        self.clear_my_int();
        self.clear_my_float();
        self.clear_optional_nested_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestFieldOrderings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestFieldOrderings {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestFieldOrderings_NestedMessage {
    // message fields
    oo: ::std::option::Option<i64>,
    bb: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestFieldOrderings_NestedMessage {
    pub fn new() -> TestFieldOrderings_NestedMessage {
        ::std::default::Default::default()
    }

    // optional int64 oo = 2;

    pub fn clear_oo(&mut self) {
        self.oo = ::std::option::Option::None;
    }

    pub fn has_oo(&self) -> bool {
        self.oo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oo(&mut self, v: i64) {
        self.oo = ::std::option::Option::Some(v);
    }

    pub fn get_oo(&self) -> i64 {
        self.oo.unwrap_or(0)
    }

    // optional int32 bb = 1;

    pub fn clear_bb(&mut self) {
        self.bb = ::std::option::Option::None;
    }

    pub fn has_bb(&self) -> bool {
        self.bb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bb(&mut self, v: i32) {
        self.bb = ::std::option::Option::Some(v);
    }

    pub fn get_bb(&self) -> i32 {
        self.bb.unwrap_or(0)
    }
}

impl ::protobuf::Message for TestFieldOrderings_NestedMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.oo = ::std::option::Option::Some(tmp);
                },
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bb = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.oo {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bb {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.oo {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.bb {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestFieldOrderings_NestedMessage {
        TestFieldOrderings_NestedMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "oo",
                    |m: &TestFieldOrderings_NestedMessage| { &m.oo },
                    |m: &mut TestFieldOrderings_NestedMessage| { &mut m.oo },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "bb",
                    |m: &TestFieldOrderings_NestedMessage| { &m.bb },
                    |m: &mut TestFieldOrderings_NestedMessage| { &mut m.bb },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestFieldOrderings_NestedMessage>(
                    "TestFieldOrderings_NestedMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestFieldOrderings_NestedMessage {
        static mut instance: ::protobuf::lazy::Lazy<TestFieldOrderings_NestedMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestFieldOrderings_NestedMessage,
        };
        unsafe {
            instance.get(TestFieldOrderings_NestedMessage::new)
        }
    }
}

impl ::protobuf::Clear for TestFieldOrderings_NestedMessage {
    fn clear(&mut self) {
        self.clear_oo();
        self.clear_bb();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestFieldOrderings_NestedMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestFieldOrderings_NestedMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestExtremeDefaultValues {
    // message fields
    large_uint32: ::std::option::Option<u32>,
    large_uint64: ::std::option::Option<u64>,
    small_int32: ::std::option::Option<i32>,
    small_int64: ::std::option::Option<i64>,
    really_small_int32: ::std::option::Option<i32>,
    really_small_int64: ::std::option::Option<i64>,
    utf8_string: ::protobuf::SingularField<::std::string::String>,
    zero_float: ::std::option::Option<f32>,
    one_float: ::std::option::Option<f32>,
    small_float: ::std::option::Option<f32>,
    negative_one_float: ::std::option::Option<f32>,
    negative_float: ::std::option::Option<f32>,
    large_float: ::std::option::Option<f32>,
    small_negative_float: ::std::option::Option<f32>,
    cpp_trigraph: ::protobuf::SingularField<::std::string::String>,
    string_with_zero: ::protobuf::SingularField<::std::string::String>,
    bytes_with_zero: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    string_piece_with_zero: ::protobuf::SingularField<::std::string::String>,
    cord_with_zero: ::protobuf::SingularField<::std::string::String>,
    replacement_string: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestExtremeDefaultValues {
    pub fn new() -> TestExtremeDefaultValues {
        ::std::default::Default::default()
    }

    // optional uint32 large_uint32 = 2;

    pub fn clear_large_uint32(&mut self) {
        self.large_uint32 = ::std::option::Option::None;
    }

    pub fn has_large_uint32(&self) -> bool {
        self.large_uint32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_large_uint32(&mut self, v: u32) {
        self.large_uint32 = ::std::option::Option::Some(v);
    }

    pub fn get_large_uint32(&self) -> u32 {
        self.large_uint32.unwrap_or(4294967295u32)
    }

    // optional uint64 large_uint64 = 3;

    pub fn clear_large_uint64(&mut self) {
        self.large_uint64 = ::std::option::Option::None;
    }

    pub fn has_large_uint64(&self) -> bool {
        self.large_uint64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_large_uint64(&mut self, v: u64) {
        self.large_uint64 = ::std::option::Option::Some(v);
    }

    pub fn get_large_uint64(&self) -> u64 {
        self.large_uint64.unwrap_or(18446744073709551615u64)
    }

    // optional int32 small_int32 = 4;

    pub fn clear_small_int32(&mut self) {
        self.small_int32 = ::std::option::Option::None;
    }

    pub fn has_small_int32(&self) -> bool {
        self.small_int32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_small_int32(&mut self, v: i32) {
        self.small_int32 = ::std::option::Option::Some(v);
    }

    pub fn get_small_int32(&self) -> i32 {
        self.small_int32.unwrap_or(-2147483647i32)
    }

    // optional int64 small_int64 = 5;

    pub fn clear_small_int64(&mut self) {
        self.small_int64 = ::std::option::Option::None;
    }

    pub fn has_small_int64(&self) -> bool {
        self.small_int64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_small_int64(&mut self, v: i64) {
        self.small_int64 = ::std::option::Option::Some(v);
    }

    pub fn get_small_int64(&self) -> i64 {
        self.small_int64.unwrap_or(-9223372036854775807i64)
    }

    // optional int32 really_small_int32 = 21;

    pub fn clear_really_small_int32(&mut self) {
        self.really_small_int32 = ::std::option::Option::None;
    }

    pub fn has_really_small_int32(&self) -> bool {
        self.really_small_int32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_really_small_int32(&mut self, v: i32) {
        self.really_small_int32 = ::std::option::Option::Some(v);
    }

    pub fn get_really_small_int32(&self) -> i32 {
        self.really_small_int32.unwrap_or(-2147483648i32)
    }

    // optional int64 really_small_int64 = 22;

    pub fn clear_really_small_int64(&mut self) {
        self.really_small_int64 = ::std::option::Option::None;
    }

    pub fn has_really_small_int64(&self) -> bool {
        self.really_small_int64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_really_small_int64(&mut self, v: i64) {
        self.really_small_int64 = ::std::option::Option::Some(v);
    }

    pub fn get_really_small_int64(&self) -> i64 {
        self.really_small_int64.unwrap_or(-9223372036854775808i64)
    }

    // optional string utf8_string = 6;

    pub fn clear_utf8_string(&mut self) {
        self.utf8_string.clear();
    }

    pub fn has_utf8_string(&self) -> bool {
        self.utf8_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_utf8_string(&mut self, v: ::std::string::String) {
        self.utf8_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_utf8_string(&mut self) -> &mut ::std::string::String {
        if self.utf8_string.is_none() {
            self.utf8_string.set_default();
        }
        self.utf8_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_utf8_string(&mut self) -> ::std::string::String {
        self.utf8_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_utf8_string(&self) -> &str {
        match self.utf8_string.as_ref() {
            Some(v) => &v,
            None => "\u{1234}",
        }
    }

    // optional float zero_float = 7;

    pub fn clear_zero_float(&mut self) {
        self.zero_float = ::std::option::Option::None;
    }

    pub fn has_zero_float(&self) -> bool {
        self.zero_float.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zero_float(&mut self, v: f32) {
        self.zero_float = ::std::option::Option::Some(v);
    }

    pub fn get_zero_float(&self) -> f32 {
        self.zero_float.unwrap_or(0.0f32)
    }

    // optional float one_float = 8;

    pub fn clear_one_float(&mut self) {
        self.one_float = ::std::option::Option::None;
    }

    pub fn has_one_float(&self) -> bool {
        self.one_float.is_some()
    }

    // Param is passed by value, moved
    pub fn set_one_float(&mut self, v: f32) {
        self.one_float = ::std::option::Option::Some(v);
    }

    pub fn get_one_float(&self) -> f32 {
        self.one_float.unwrap_or(1.0f32)
    }

    // optional float small_float = 9;

    pub fn clear_small_float(&mut self) {
        self.small_float = ::std::option::Option::None;
    }

    pub fn has_small_float(&self) -> bool {
        self.small_float.is_some()
    }

    // Param is passed by value, moved
    pub fn set_small_float(&mut self, v: f32) {
        self.small_float = ::std::option::Option::Some(v);
    }

    pub fn get_small_float(&self) -> f32 {
        self.small_float.unwrap_or(1.5f32)
    }

    // optional float negative_one_float = 10;

    pub fn clear_negative_one_float(&mut self) {
        self.negative_one_float = ::std::option::Option::None;
    }

    pub fn has_negative_one_float(&self) -> bool {
        self.negative_one_float.is_some()
    }

    // Param is passed by value, moved
    pub fn set_negative_one_float(&mut self, v: f32) {
        self.negative_one_float = ::std::option::Option::Some(v);
    }

    pub fn get_negative_one_float(&self) -> f32 {
        self.negative_one_float.unwrap_or(-1.0f32)
    }

    // optional float negative_float = 11;

    pub fn clear_negative_float(&mut self) {
        self.negative_float = ::std::option::Option::None;
    }

    pub fn has_negative_float(&self) -> bool {
        self.negative_float.is_some()
    }

    // Param is passed by value, moved
    pub fn set_negative_float(&mut self, v: f32) {
        self.negative_float = ::std::option::Option::Some(v);
    }

    pub fn get_negative_float(&self) -> f32 {
        self.negative_float.unwrap_or(-1.5f32)
    }

    // optional float large_float = 12;

    pub fn clear_large_float(&mut self) {
        self.large_float = ::std::option::Option::None;
    }

    pub fn has_large_float(&self) -> bool {
        self.large_float.is_some()
    }

    // Param is passed by value, moved
    pub fn set_large_float(&mut self, v: f32) {
        self.large_float = ::std::option::Option::Some(v);
    }

    pub fn get_large_float(&self) -> f32 {
        self.large_float.unwrap_or(200000000.0f32)
    }

    // optional float small_negative_float = 13;

    pub fn clear_small_negative_float(&mut self) {
        self.small_negative_float = ::std::option::Option::None;
    }

    pub fn has_small_negative_float(&self) -> bool {
        self.small_negative_float.is_some()
    }

    // Param is passed by value, moved
    pub fn set_small_negative_float(&mut self, v: f32) {
        self.small_negative_float = ::std::option::Option::Some(v);
    }

    pub fn get_small_negative_float(&self) -> f32 {
        self.small_negative_float.unwrap_or(-0.0000000000000000000000000008f32)
    }

    // optional string cpp_trigraph = 20;

    pub fn clear_cpp_trigraph(&mut self) {
        self.cpp_trigraph.clear();
    }

    pub fn has_cpp_trigraph(&self) -> bool {
        self.cpp_trigraph.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpp_trigraph(&mut self, v: ::std::string::String) {
        self.cpp_trigraph = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cpp_trigraph(&mut self) -> &mut ::std::string::String {
        if self.cpp_trigraph.is_none() {
            self.cpp_trigraph.set_default();
        }
        self.cpp_trigraph.as_mut().unwrap()
    }

    // Take field
    pub fn take_cpp_trigraph(&mut self) -> ::std::string::String {
        self.cpp_trigraph.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_cpp_trigraph(&self) -> &str {
        match self.cpp_trigraph.as_ref() {
            Some(v) => &v,
            None => "? ? ?? ?? ??? ??/ ??-",
        }
    }

    // optional string string_with_zero = 23;

    pub fn clear_string_with_zero(&mut self) {
        self.string_with_zero.clear();
    }

    pub fn has_string_with_zero(&self) -> bool {
        self.string_with_zero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_with_zero(&mut self, v: ::std::string::String) {
        self.string_with_zero = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_with_zero(&mut self) -> &mut ::std::string::String {
        if self.string_with_zero.is_none() {
            self.string_with_zero.set_default();
        }
        self.string_with_zero.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_with_zero(&mut self) -> ::std::string::String {
        self.string_with_zero.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_string_with_zero(&self) -> &str {
        match self.string_with_zero.as_ref() {
            Some(v) => &v,
            None => "hel\u{0}lo",
        }
    }

    // optional bytes bytes_with_zero = 24;

    pub fn clear_bytes_with_zero(&mut self) {
        self.bytes_with_zero.clear();
    }

    pub fn has_bytes_with_zero(&self) -> bool {
        self.bytes_with_zero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_with_zero(&mut self, v: ::std::vec::Vec<u8>) {
        self.bytes_with_zero = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes_with_zero(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.bytes_with_zero.is_none() {
            self.bytes_with_zero.set_default();
        }
        self.bytes_with_zero.as_mut().unwrap()
    }

    // Take field
    pub fn take_bytes_with_zero(&mut self) -> ::std::vec::Vec<u8> {
        self.bytes_with_zero.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_bytes_with_zero(&self) -> &[u8] {
        match self.bytes_with_zero.as_ref() {
            Some(v) => &v,
            None => b"wor\x00ld",
        }
    }

    // optional string string_piece_with_zero = 25;

    pub fn clear_string_piece_with_zero(&mut self) {
        self.string_piece_with_zero.clear();
    }

    pub fn has_string_piece_with_zero(&self) -> bool {
        self.string_piece_with_zero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_piece_with_zero(&mut self, v: ::std::string::String) {
        self.string_piece_with_zero = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_piece_with_zero(&mut self) -> &mut ::std::string::String {
        if self.string_piece_with_zero.is_none() {
            self.string_piece_with_zero.set_default();
        }
        self.string_piece_with_zero.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_piece_with_zero(&mut self) -> ::std::string::String {
        self.string_piece_with_zero.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_string_piece_with_zero(&self) -> &str {
        match self.string_piece_with_zero.as_ref() {
            Some(v) => &v,
            None => "ab\u{0}c",
        }
    }

    // optional string cord_with_zero = 26;

    pub fn clear_cord_with_zero(&mut self) {
        self.cord_with_zero.clear();
    }

    pub fn has_cord_with_zero(&self) -> bool {
        self.cord_with_zero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cord_with_zero(&mut self, v: ::std::string::String) {
        self.cord_with_zero = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cord_with_zero(&mut self) -> &mut ::std::string::String {
        if self.cord_with_zero.is_none() {
            self.cord_with_zero.set_default();
        }
        self.cord_with_zero.as_mut().unwrap()
    }

    // Take field
    pub fn take_cord_with_zero(&mut self) -> ::std::string::String {
        self.cord_with_zero.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_cord_with_zero(&self) -> &str {
        match self.cord_with_zero.as_ref() {
            Some(v) => &v,
            None => "12\u{0}3",
        }
    }

    // optional string replacement_string = 27;

    pub fn clear_replacement_string(&mut self) {
        self.replacement_string.clear();
    }

    pub fn has_replacement_string(&self) -> bool {
        self.replacement_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replacement_string(&mut self, v: ::std::string::String) {
        self.replacement_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_replacement_string(&mut self) -> &mut ::std::string::String {
        if self.replacement_string.is_none() {
            self.replacement_string.set_default();
        }
        self.replacement_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_replacement_string(&mut self) -> ::std::string::String {
        self.replacement_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_replacement_string(&self) -> &str {
        match self.replacement_string.as_ref() {
            Some(v) => &v,
            None => "${unknown}",
        }
    }
}

impl ::protobuf::Message for TestExtremeDefaultValues {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.large_uint32 = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.large_uint64 = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.small_int32 = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.small_int64 = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.really_small_int32 = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.really_small_int64 = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.utf8_string)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.zero_float = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.one_float = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.small_float = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.negative_one_float = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.negative_float = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.large_float = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.small_negative_float = ::std::option::Option::Some(tmp);
                },
                20 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cpp_trigraph)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.string_with_zero)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.bytes_with_zero)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.string_piece_with_zero)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cord_with_zero)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.replacement_string)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.large_uint32 {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.large_uint64 {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.small_int32 {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.small_int64 {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.really_small_int32 {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.really_small_int64 {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.utf8_string.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.zero_float {
            my_size += 5;
        }
        if let Some(v) = self.one_float {
            my_size += 5;
        }
        if let Some(v) = self.small_float {
            my_size += 5;
        }
        if let Some(v) = self.negative_one_float {
            my_size += 5;
        }
        if let Some(v) = self.negative_float {
            my_size += 5;
        }
        if let Some(v) = self.large_float {
            my_size += 5;
        }
        if let Some(v) = self.small_negative_float {
            my_size += 5;
        }
        if let Some(ref v) = self.cpp_trigraph.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(ref v) = self.string_with_zero.as_ref() {
            my_size += ::protobuf::rt::string_size(23, &v);
        }
        if let Some(ref v) = self.bytes_with_zero.as_ref() {
            my_size += ::protobuf::rt::bytes_size(24, &v);
        }
        if let Some(ref v) = self.string_piece_with_zero.as_ref() {
            my_size += ::protobuf::rt::string_size(25, &v);
        }
        if let Some(ref v) = self.cord_with_zero.as_ref() {
            my_size += ::protobuf::rt::string_size(26, &v);
        }
        if let Some(ref v) = self.replacement_string.as_ref() {
            my_size += ::protobuf::rt::string_size(27, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.large_uint32 {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.large_uint64 {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.small_int32 {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.small_int64 {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.really_small_int32 {
            os.write_int32(21, v)?;
        }
        if let Some(v) = self.really_small_int64 {
            os.write_int64(22, v)?;
        }
        if let Some(ref v) = self.utf8_string.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.zero_float {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.one_float {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.small_float {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.negative_one_float {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.negative_float {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.large_float {
            os.write_float(12, v)?;
        }
        if let Some(v) = self.small_negative_float {
            os.write_float(13, v)?;
        }
        if let Some(ref v) = self.cpp_trigraph.as_ref() {
            os.write_string(20, &v)?;
        }
        if let Some(ref v) = self.string_with_zero.as_ref() {
            os.write_string(23, &v)?;
        }
        if let Some(ref v) = self.bytes_with_zero.as_ref() {
            os.write_bytes(24, &v)?;
        }
        if let Some(ref v) = self.string_piece_with_zero.as_ref() {
            os.write_string(25, &v)?;
        }
        if let Some(ref v) = self.cord_with_zero.as_ref() {
            os.write_string(26, &v)?;
        }
        if let Some(ref v) = self.replacement_string.as_ref() {
            os.write_string(27, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestExtremeDefaultValues {
        TestExtremeDefaultValues::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "large_uint32",
                    |m: &TestExtremeDefaultValues| { &m.large_uint32 },
                    |m: &mut TestExtremeDefaultValues| { &mut m.large_uint32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "large_uint64",
                    |m: &TestExtremeDefaultValues| { &m.large_uint64 },
                    |m: &mut TestExtremeDefaultValues| { &mut m.large_uint64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "small_int32",
                    |m: &TestExtremeDefaultValues| { &m.small_int32 },
                    |m: &mut TestExtremeDefaultValues| { &mut m.small_int32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "small_int64",
                    |m: &TestExtremeDefaultValues| { &m.small_int64 },
                    |m: &mut TestExtremeDefaultValues| { &mut m.small_int64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "really_small_int32",
                    |m: &TestExtremeDefaultValues| { &m.really_small_int32 },
                    |m: &mut TestExtremeDefaultValues| { &mut m.really_small_int32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "really_small_int64",
                    |m: &TestExtremeDefaultValues| { &m.really_small_int64 },
                    |m: &mut TestExtremeDefaultValues| { &mut m.really_small_int64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "utf8_string",
                    |m: &TestExtremeDefaultValues| { &m.utf8_string },
                    |m: &mut TestExtremeDefaultValues| { &mut m.utf8_string },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "zero_float",
                    |m: &TestExtremeDefaultValues| { &m.zero_float },
                    |m: &mut TestExtremeDefaultValues| { &mut m.zero_float },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "one_float",
                    |m: &TestExtremeDefaultValues| { &m.one_float },
                    |m: &mut TestExtremeDefaultValues| { &mut m.one_float },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "small_float",
                    |m: &TestExtremeDefaultValues| { &m.small_float },
                    |m: &mut TestExtremeDefaultValues| { &mut m.small_float },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "negative_one_float",
                    |m: &TestExtremeDefaultValues| { &m.negative_one_float },
                    |m: &mut TestExtremeDefaultValues| { &mut m.negative_one_float },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "negative_float",
                    |m: &TestExtremeDefaultValues| { &m.negative_float },
                    |m: &mut TestExtremeDefaultValues| { &mut m.negative_float },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "large_float",
                    |m: &TestExtremeDefaultValues| { &m.large_float },
                    |m: &mut TestExtremeDefaultValues| { &mut m.large_float },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "small_negative_float",
                    |m: &TestExtremeDefaultValues| { &m.small_negative_float },
                    |m: &mut TestExtremeDefaultValues| { &mut m.small_negative_float },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cpp_trigraph",
                    |m: &TestExtremeDefaultValues| { &m.cpp_trigraph },
                    |m: &mut TestExtremeDefaultValues| { &mut m.cpp_trigraph },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "string_with_zero",
                    |m: &TestExtremeDefaultValues| { &m.string_with_zero },
                    |m: &mut TestExtremeDefaultValues| { &mut m.string_with_zero },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "bytes_with_zero",
                    |m: &TestExtremeDefaultValues| { &m.bytes_with_zero },
                    |m: &mut TestExtremeDefaultValues| { &mut m.bytes_with_zero },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "string_piece_with_zero",
                    |m: &TestExtremeDefaultValues| { &m.string_piece_with_zero },
                    |m: &mut TestExtremeDefaultValues| { &mut m.string_piece_with_zero },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cord_with_zero",
                    |m: &TestExtremeDefaultValues| { &m.cord_with_zero },
                    |m: &mut TestExtremeDefaultValues| { &mut m.cord_with_zero },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "replacement_string",
                    |m: &TestExtremeDefaultValues| { &m.replacement_string },
                    |m: &mut TestExtremeDefaultValues| { &mut m.replacement_string },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestExtremeDefaultValues>(
                    "TestExtremeDefaultValues",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestExtremeDefaultValues {
        static mut instance: ::protobuf::lazy::Lazy<TestExtremeDefaultValues> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestExtremeDefaultValues,
        };
        unsafe {
            instance.get(TestExtremeDefaultValues::new)
        }
    }
}

impl ::protobuf::Clear for TestExtremeDefaultValues {
    fn clear(&mut self) {
        self.clear_large_uint32();
        self.clear_large_uint64();
        self.clear_small_int32();
        self.clear_small_int64();
        self.clear_really_small_int32();
        self.clear_really_small_int64();
        self.clear_utf8_string();
        self.clear_zero_float();
        self.clear_one_float();
        self.clear_small_float();
        self.clear_negative_one_float();
        self.clear_negative_float();
        self.clear_large_float();
        self.clear_small_negative_float();
        self.clear_cpp_trigraph();
        self.clear_string_with_zero();
        self.clear_bytes_with_zero();
        self.clear_string_piece_with_zero();
        self.clear_cord_with_zero();
        self.clear_replacement_string();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestExtremeDefaultValues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestExtremeDefaultValues {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SparseEnumMessage {
    // message fields
    sparse_enum: ::std::option::Option<TestSparseEnum>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SparseEnumMessage {
    pub fn new() -> SparseEnumMessage {
        ::std::default::Default::default()
    }

    // optional .protobuf_unittest.TestSparseEnum sparse_enum = 1;

    pub fn clear_sparse_enum(&mut self) {
        self.sparse_enum = ::std::option::Option::None;
    }

    pub fn has_sparse_enum(&self) -> bool {
        self.sparse_enum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sparse_enum(&mut self, v: TestSparseEnum) {
        self.sparse_enum = ::std::option::Option::Some(v);
    }

    pub fn get_sparse_enum(&self) -> TestSparseEnum {
        self.sparse_enum.unwrap_or(TestSparseEnum::SPARSE_A)
    }
}

impl ::protobuf::Message for SparseEnumMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.sparse_enum, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sparse_enum {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sparse_enum {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SparseEnumMessage {
        SparseEnumMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TestSparseEnum>>(
                    "sparse_enum",
                    |m: &SparseEnumMessage| { &m.sparse_enum },
                    |m: &mut SparseEnumMessage| { &mut m.sparse_enum },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SparseEnumMessage>(
                    "SparseEnumMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SparseEnumMessage {
        static mut instance: ::protobuf::lazy::Lazy<SparseEnumMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SparseEnumMessage,
        };
        unsafe {
            instance.get(SparseEnumMessage::new)
        }
    }
}

impl ::protobuf::Clear for SparseEnumMessage {
    fn clear(&mut self) {
        self.clear_sparse_enum();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SparseEnumMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SparseEnumMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OneString {
    // message fields
    data: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl OneString {
    pub fn new() -> OneString {
        ::std::default::Default::default()
    }

    // optional string data = 1;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::string::String) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::string::String {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::string::String {
        self.data.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_data(&self) -> &str {
        match self.data.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for OneString {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OneString {
        OneString::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "data",
                    |m: &OneString| { &m.data },
                    |m: &mut OneString| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OneString>(
                    "OneString",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OneString {
        static mut instance: ::protobuf::lazy::Lazy<OneString> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OneString,
        };
        unsafe {
            instance.get(OneString::new)
        }
    }
}

impl ::protobuf::Clear for OneString {
    fn clear(&mut self) {
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OneString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OneString {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoreString {
    // message fields
    data: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MoreString {
    pub fn new() -> MoreString {
        ::std::default::Default::default()
    }

    // repeated string data = 1;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }

    pub fn get_data(&self) -> &[::std::string::String] {
        &self.data
    }
}

impl ::protobuf::Message for MoreString {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.data {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.data {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoreString {
        MoreString::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "data",
                    |m: &MoreString| { &m.data },
                    |m: &mut MoreString| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoreString>(
                    "MoreString",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoreString {
        static mut instance: ::protobuf::lazy::Lazy<MoreString> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoreString,
        };
        unsafe {
            instance.get(MoreString::new)
        }
    }
}

impl ::protobuf::Clear for MoreString {
    fn clear(&mut self) {
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoreString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoreString {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OneBytes {
    // message fields
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl OneBytes {
    pub fn new() -> OneBytes {
        ::std::default::Default::default()
    }

    // optional bytes data = 1;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for OneBytes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OneBytes {
        OneBytes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &OneBytes| { &m.data },
                    |m: &mut OneBytes| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OneBytes>(
                    "OneBytes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OneBytes {
        static mut instance: ::protobuf::lazy::Lazy<OneBytes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OneBytes,
        };
        unsafe {
            instance.get(OneBytes::new)
        }
    }
}

impl ::protobuf::Clear for OneBytes {
    fn clear(&mut self) {
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OneBytes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OneBytes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoreBytes {
    // message fields
    data: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MoreBytes {
    pub fn new() -> MoreBytes {
        ::std::default::Default::default()
    }

    // repeated bytes data = 1;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }

    pub fn get_data(&self) -> &[::std::vec::Vec<u8>] {
        &self.data
    }
}

impl ::protobuf::Message for MoreBytes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.data {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.data {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoreBytes {
        MoreBytes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &MoreBytes| { &m.data },
                    |m: &mut MoreBytes| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoreBytes>(
                    "MoreBytes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoreBytes {
        static mut instance: ::protobuf::lazy::Lazy<MoreBytes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoreBytes,
        };
        unsafe {
            instance.get(MoreBytes::new)
        }
    }
}

impl ::protobuf::Clear for MoreBytes {
    fn clear(&mut self) {
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoreBytes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoreBytes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Int32Message {
    // message fields
    data: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Int32Message {
    pub fn new() -> Int32Message {
        ::std::default::Default::default()
    }

    // optional int32 data = 1;

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: i32) {
        self.data = ::std::option::Option::Some(v);
    }

    pub fn get_data(&self) -> i32 {
        self.data.unwrap_or(0)
    }
}

impl ::protobuf::Message for Int32Message {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.data = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.data {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.data {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Int32Message {
        Int32Message::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "data",
                    |m: &Int32Message| { &m.data },
                    |m: &mut Int32Message| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Int32Message>(
                    "Int32Message",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Int32Message {
        static mut instance: ::protobuf::lazy::Lazy<Int32Message> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Int32Message,
        };
        unsafe {
            instance.get(Int32Message::new)
        }
    }
}

impl ::protobuf::Clear for Int32Message {
    fn clear(&mut self) {
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Int32Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Int32Message {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Uint32Message {
    // message fields
    data: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Uint32Message {
    pub fn new() -> Uint32Message {
        ::std::default::Default::default()
    }

    // optional uint32 data = 1;

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: u32) {
        self.data = ::std::option::Option::Some(v);
    }

    pub fn get_data(&self) -> u32 {
        self.data.unwrap_or(0)
    }
}

impl ::protobuf::Message for Uint32Message {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.data = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.data {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.data {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Uint32Message {
        Uint32Message::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "data",
                    |m: &Uint32Message| { &m.data },
                    |m: &mut Uint32Message| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Uint32Message>(
                    "Uint32Message",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Uint32Message {
        static mut instance: ::protobuf::lazy::Lazy<Uint32Message> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Uint32Message,
        };
        unsafe {
            instance.get(Uint32Message::new)
        }
    }
}

impl ::protobuf::Clear for Uint32Message {
    fn clear(&mut self) {
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Uint32Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Uint32Message {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Int64Message {
    // message fields
    data: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Int64Message {
    pub fn new() -> Int64Message {
        ::std::default::Default::default()
    }

    // optional int64 data = 1;

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: i64) {
        self.data = ::std::option::Option::Some(v);
    }

    pub fn get_data(&self) -> i64 {
        self.data.unwrap_or(0)
    }
}

impl ::protobuf::Message for Int64Message {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.data = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.data {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.data {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Int64Message {
        Int64Message::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "data",
                    |m: &Int64Message| { &m.data },
                    |m: &mut Int64Message| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Int64Message>(
                    "Int64Message",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Int64Message {
        static mut instance: ::protobuf::lazy::Lazy<Int64Message> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Int64Message,
        };
        unsafe {
            instance.get(Int64Message::new)
        }
    }
}

impl ::protobuf::Clear for Int64Message {
    fn clear(&mut self) {
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Int64Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Int64Message {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Uint64Message {
    // message fields
    data: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Uint64Message {
    pub fn new() -> Uint64Message {
        ::std::default::Default::default()
    }

    // optional uint64 data = 1;

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: u64) {
        self.data = ::std::option::Option::Some(v);
    }

    pub fn get_data(&self) -> u64 {
        self.data.unwrap_or(0)
    }
}

impl ::protobuf::Message for Uint64Message {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.data = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.data {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.data {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Uint64Message {
        Uint64Message::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "data",
                    |m: &Uint64Message| { &m.data },
                    |m: &mut Uint64Message| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Uint64Message>(
                    "Uint64Message",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Uint64Message {
        static mut instance: ::protobuf::lazy::Lazy<Uint64Message> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Uint64Message,
        };
        unsafe {
            instance.get(Uint64Message::new)
        }
    }
}

impl ::protobuf::Clear for Uint64Message {
    fn clear(&mut self) {
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Uint64Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Uint64Message {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BoolMessage {
    // message fields
    data: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl BoolMessage {
    pub fn new() -> BoolMessage {
        ::std::default::Default::default()
    }

    // optional bool data = 1;

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: bool) {
        self.data = ::std::option::Option::Some(v);
    }

    pub fn get_data(&self) -> bool {
        self.data.unwrap_or(false)
    }
}

impl ::protobuf::Message for BoolMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.data = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.data {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.data {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BoolMessage {
        BoolMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "data",
                    |m: &BoolMessage| { &m.data },
                    |m: &mut BoolMessage| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BoolMessage>(
                    "BoolMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BoolMessage {
        static mut instance: ::protobuf::lazy::Lazy<BoolMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BoolMessage,
        };
        unsafe {
            instance.get(BoolMessage::new)
        }
    }
}

impl ::protobuf::Clear for BoolMessage {
    fn clear(&mut self) {
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BoolMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BoolMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestOneof {
    // message oneof groups
    pub foo: ::std::option::Option<TestOneof_oneof_foo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum TestOneof_oneof_foo {
    foo_int(i32),
    foo_string(::std::string::String),
    foo_message(TestAllTypes),
}

impl TestOneof {
    pub fn new() -> TestOneof {
        ::std::default::Default::default()
    }

    // optional int32 foo_int = 1;

    pub fn clear_foo_int(&mut self) {
        self.foo = ::std::option::Option::None;
    }

    pub fn has_foo_int(&self) -> bool {
        match self.foo {
            ::std::option::Option::Some(TestOneof_oneof_foo::foo_int(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_foo_int(&mut self, v: i32) {
        self.foo = ::std::option::Option::Some(TestOneof_oneof_foo::foo_int(v))
    }

    pub fn get_foo_int(&self) -> i32 {
        match self.foo {
            ::std::option::Option::Some(TestOneof_oneof_foo::foo_int(v)) => v,
            _ => 0,
        }
    }

    // optional string foo_string = 2;

    pub fn clear_foo_string(&mut self) {
        self.foo = ::std::option::Option::None;
    }

    pub fn has_foo_string(&self) -> bool {
        match self.foo {
            ::std::option::Option::Some(TestOneof_oneof_foo::foo_string(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_foo_string(&mut self, v: ::std::string::String) {
        self.foo = ::std::option::Option::Some(TestOneof_oneof_foo::foo_string(v))
    }

    // Mutable pointer to the field.
    pub fn mut_foo_string(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(TestOneof_oneof_foo::foo_string(_)) = self.foo {
        } else {
            self.foo = ::std::option::Option::Some(TestOneof_oneof_foo::foo_string(::std::string::String::new()));
        }
        match self.foo {
            ::std::option::Option::Some(TestOneof_oneof_foo::foo_string(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_foo_string(&mut self) -> ::std::string::String {
        if self.has_foo_string() {
            match self.foo.take() {
                ::std::option::Option::Some(TestOneof_oneof_foo::foo_string(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_foo_string(&self) -> &str {
        match self.foo {
            ::std::option::Option::Some(TestOneof_oneof_foo::foo_string(ref v)) => v,
            _ => "",
        }
    }

    // optional .protobuf_unittest.TestAllTypes foo_message = 3;

    pub fn clear_foo_message(&mut self) {
        self.foo = ::std::option::Option::None;
    }

    pub fn has_foo_message(&self) -> bool {
        match self.foo {
            ::std::option::Option::Some(TestOneof_oneof_foo::foo_message(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_foo_message(&mut self, v: TestAllTypes) {
        self.foo = ::std::option::Option::Some(TestOneof_oneof_foo::foo_message(v))
    }

    // Mutable pointer to the field.
    pub fn mut_foo_message(&mut self) -> &mut TestAllTypes {
        if let ::std::option::Option::Some(TestOneof_oneof_foo::foo_message(_)) = self.foo {
        } else {
            self.foo = ::std::option::Option::Some(TestOneof_oneof_foo::foo_message(TestAllTypes::new()));
        }
        match self.foo {
            ::std::option::Option::Some(TestOneof_oneof_foo::foo_message(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_foo_message(&mut self) -> TestAllTypes {
        if self.has_foo_message() {
            match self.foo.take() {
                ::std::option::Option::Some(TestOneof_oneof_foo::foo_message(v)) => v,
                _ => panic!(),
            }
        } else {
            TestAllTypes::new()
        }
    }

    pub fn get_foo_message(&self) -> &TestAllTypes {
        match self.foo {
            ::std::option::Option::Some(TestOneof_oneof_foo::foo_message(ref v)) => v,
            _ => TestAllTypes::default_instance(),
        }
    }
}

impl ::protobuf::Message for TestOneof {
    fn is_initialized(&self) -> bool {
        if let Some(TestOneof_oneof_foo::foo_message(ref v)) = self.foo {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.foo = ::std::option::Option::Some(TestOneof_oneof_foo::foo_int(is.read_int32()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.foo = ::std::option::Option::Some(TestOneof_oneof_foo::foo_string(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.foo = ::std::option::Option::Some(TestOneof_oneof_foo::foo_message(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.foo {
            match v {
                &TestOneof_oneof_foo::foo_int(v) => {
                    my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &TestOneof_oneof_foo::foo_string(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &TestOneof_oneof_foo::foo_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.foo {
            match v {
                &TestOneof_oneof_foo::foo_int(v) => {
                    os.write_int32(1, v)?;
                },
                &TestOneof_oneof_foo::foo_string(ref v) => {
                    os.write_string(2, v)?;
                },
                &TestOneof_oneof_foo::foo_message(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestOneof {
        TestOneof::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                    "foo_int",
                    TestOneof::has_foo_int,
                    TestOneof::get_foo_int,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "foo_string",
                    TestOneof::has_foo_string,
                    TestOneof::get_foo_string,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TestAllTypes>(
                    "foo_message",
                    TestOneof::has_foo_message,
                    TestOneof::get_foo_message,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestOneof>(
                    "TestOneof",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestOneof {
        static mut instance: ::protobuf::lazy::Lazy<TestOneof> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestOneof,
        };
        unsafe {
            instance.get(TestOneof::new)
        }
    }
}

impl ::protobuf::Clear for TestOneof {
    fn clear(&mut self) {
        self.clear_foo_int();
        self.clear_foo_string();
        self.clear_foo_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestOneof {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestOneof {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestOneofBackwardsCompatible {
    // message fields
    foo_int: ::std::option::Option<i32>,
    foo_string: ::protobuf::SingularField<::std::string::String>,
    foo_message: ::protobuf::SingularPtrField<TestAllTypes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestOneofBackwardsCompatible {
    pub fn new() -> TestOneofBackwardsCompatible {
        ::std::default::Default::default()
    }

    // optional int32 foo_int = 1;

    pub fn clear_foo_int(&mut self) {
        self.foo_int = ::std::option::Option::None;
    }

    pub fn has_foo_int(&self) -> bool {
        self.foo_int.is_some()
    }

    // Param is passed by value, moved
    pub fn set_foo_int(&mut self, v: i32) {
        self.foo_int = ::std::option::Option::Some(v);
    }

    pub fn get_foo_int(&self) -> i32 {
        self.foo_int.unwrap_or(0)
    }

    // optional string foo_string = 2;

    pub fn clear_foo_string(&mut self) {
        self.foo_string.clear();
    }

    pub fn has_foo_string(&self) -> bool {
        self.foo_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_foo_string(&mut self, v: ::std::string::String) {
        self.foo_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_foo_string(&mut self) -> &mut ::std::string::String {
        if self.foo_string.is_none() {
            self.foo_string.set_default();
        }
        self.foo_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_foo_string(&mut self) -> ::std::string::String {
        self.foo_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_foo_string(&self) -> &str {
        match self.foo_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .protobuf_unittest.TestAllTypes foo_message = 3;

    pub fn clear_foo_message(&mut self) {
        self.foo_message.clear();
    }

    pub fn has_foo_message(&self) -> bool {
        self.foo_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_foo_message(&mut self, v: TestAllTypes) {
        self.foo_message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_foo_message(&mut self) -> &mut TestAllTypes {
        if self.foo_message.is_none() {
            self.foo_message.set_default();
        }
        self.foo_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_foo_message(&mut self) -> TestAllTypes {
        self.foo_message.take().unwrap_or_else(|| TestAllTypes::new())
    }

    pub fn get_foo_message(&self) -> &TestAllTypes {
        self.foo_message.as_ref().unwrap_or_else(|| TestAllTypes::default_instance())
    }
}

impl ::protobuf::Message for TestOneofBackwardsCompatible {
    fn is_initialized(&self) -> bool {
        for v in &self.foo_message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.foo_int = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.foo_string)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.foo_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.foo_int {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.foo_string.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.foo_message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.foo_int {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.foo_string.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.foo_message.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestOneofBackwardsCompatible {
        TestOneofBackwardsCompatible::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "foo_int",
                    |m: &TestOneofBackwardsCompatible| { &m.foo_int },
                    |m: &mut TestOneofBackwardsCompatible| { &mut m.foo_int },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "foo_string",
                    |m: &TestOneofBackwardsCompatible| { &m.foo_string },
                    |m: &mut TestOneofBackwardsCompatible| { &mut m.foo_string },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestAllTypes>>(
                    "foo_message",
                    |m: &TestOneofBackwardsCompatible| { &m.foo_message },
                    |m: &mut TestOneofBackwardsCompatible| { &mut m.foo_message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestOneofBackwardsCompatible>(
                    "TestOneofBackwardsCompatible",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestOneofBackwardsCompatible {
        static mut instance: ::protobuf::lazy::Lazy<TestOneofBackwardsCompatible> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestOneofBackwardsCompatible,
        };
        unsafe {
            instance.get(TestOneofBackwardsCompatible::new)
        }
    }
}

impl ::protobuf::Clear for TestOneofBackwardsCompatible {
    fn clear(&mut self) {
        self.clear_foo_int();
        self.clear_foo_string();
        self.clear_foo_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestOneofBackwardsCompatible {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestOneofBackwardsCompatible {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestOneof2 {
    // message fields
    baz_int: ::std::option::Option<i32>,
    baz_string: ::protobuf::SingularField<::std::string::String>,
    // message oneof groups
    pub foo: ::std::option::Option<TestOneof2_oneof_foo>,
    pub bar: ::std::option::Option<TestOneof2_oneof_bar>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum TestOneof2_oneof_foo {
    foo_int(i32),
    foo_string(::std::string::String),
    foo_cord(::std::string::String),
    foo_string_piece(::std::string::String),
    foo_bytes(::std::vec::Vec<u8>),
    foo_enum(TestOneof2_NestedEnum),
    foo_message(TestOneof2_NestedMessage),
    foo_lazy_message(TestOneof2_NestedMessage),
}

#[derive(Clone,PartialEq)]
pub enum TestOneof2_oneof_bar {
    bar_int(i32),
    bar_enum(TestOneof2_NestedEnum),
}

impl TestOneof2 {
    pub fn new() -> TestOneof2 {
        ::std::default::Default::default()
    }

    // optional int32 foo_int = 1;

    pub fn clear_foo_int(&mut self) {
        self.foo = ::std::option::Option::None;
    }

    pub fn has_foo_int(&self) -> bool {
        match self.foo {
            ::std::option::Option::Some(TestOneof2_oneof_foo::foo_int(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_foo_int(&mut self, v: i32) {
        self.foo = ::std::option::Option::Some(TestOneof2_oneof_foo::foo_int(v))
    }

    pub fn get_foo_int(&self) -> i32 {
        match self.foo {
            ::std::option::Option::Some(TestOneof2_oneof_foo::foo_int(v)) => v,
            _ => 0,
        }
    }

    // optional string foo_string = 2;

    pub fn clear_foo_string(&mut self) {
        self.foo = ::std::option::Option::None;
    }

    pub fn has_foo_string(&self) -> bool {
        match self.foo {
            ::std::option::Option::Some(TestOneof2_oneof_foo::foo_string(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_foo_string(&mut self, v: ::std::string::String) {
        self.foo = ::std::option::Option::Some(TestOneof2_oneof_foo::foo_string(v))
    }

    // Mutable pointer to the field.
    pub fn mut_foo_string(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(TestOneof2_oneof_foo::foo_string(_)) = self.foo {
        } else {
            self.foo = ::std::option::Option::Some(TestOneof2_oneof_foo::foo_string(::std::string::String::new()));
        }
        match self.foo {
            ::std::option::Option::Some(TestOneof2_oneof_foo::foo_string(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_foo_string(&mut self) -> ::std::string::String {
        if self.has_foo_string() {
            match self.foo.take() {
                ::std::option::Option::Some(TestOneof2_oneof_foo::foo_string(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_foo_string(&self) -> &str {
        match self.foo {
            ::std::option::Option::Some(TestOneof2_oneof_foo::foo_string(ref v)) => v,
            _ => "",
        }
    }

    // optional string foo_cord = 3;

    pub fn clear_foo_cord(&mut self) {
        self.foo = ::std::option::Option::None;
    }

    pub fn has_foo_cord(&self) -> bool {
        match self.foo {
            ::std::option::Option::Some(TestOneof2_oneof_foo::foo_cord(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_foo_cord(&mut self, v: ::std::string::String) {
        self.foo = ::std::option::Option::Some(TestOneof2_oneof_foo::foo_cord(v))
    }

    // Mutable pointer to the field.
    pub fn mut_foo_cord(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(TestOneof2_oneof_foo::foo_cord(_)) = self.foo {
        } else {
            self.foo = ::std::option::Option::Some(TestOneof2_oneof_foo::foo_cord(::std::string::String::new()));
        }
        match self.foo {
            ::std::option::Option::Some(TestOneof2_oneof_foo::foo_cord(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_foo_cord(&mut self) -> ::std::string::String {
        if self.has_foo_cord() {
            match self.foo.take() {
                ::std::option::Option::Some(TestOneof2_oneof_foo::foo_cord(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_foo_cord(&self) -> &str {
        match self.foo {
            ::std::option::Option::Some(TestOneof2_oneof_foo::foo_cord(ref v)) => v,
            _ => "",
        }
    }

    // optional string foo_string_piece = 4;

    pub fn clear_foo_string_piece(&mut self) {
        self.foo = ::std::option::Option::None;
    }

    pub fn has_foo_string_piece(&self) -> bool {
        match self.foo {
            ::std::option::Option::Some(TestOneof2_oneof_foo::foo_string_piece(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_foo_string_piece(&mut self, v: ::std::string::String) {
        self.foo = ::std::option::Option::Some(TestOneof2_oneof_foo::foo_string_piece(v))
    }

    // Mutable pointer to the field.
    pub fn mut_foo_string_piece(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(TestOneof2_oneof_foo::foo_string_piece(_)) = self.foo {
        } else {
            self.foo = ::std::option::Option::Some(TestOneof2_oneof_foo::foo_string_piece(::std::string::String::new()));
        }
        match self.foo {
            ::std::option::Option::Some(TestOneof2_oneof_foo::foo_string_piece(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_foo_string_piece(&mut self) -> ::std::string::String {
        if self.has_foo_string_piece() {
            match self.foo.take() {
                ::std::option::Option::Some(TestOneof2_oneof_foo::foo_string_piece(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_foo_string_piece(&self) -> &str {
        match self.foo {
            ::std::option::Option::Some(TestOneof2_oneof_foo::foo_string_piece(ref v)) => v,
            _ => "",
        }
    }

    // optional bytes foo_bytes = 5;

    pub fn clear_foo_bytes(&mut self) {
        self.foo = ::std::option::Option::None;
    }

    pub fn has_foo_bytes(&self) -> bool {
        match self.foo {
            ::std::option::Option::Some(TestOneof2_oneof_foo::foo_bytes(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_foo_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.foo = ::std::option::Option::Some(TestOneof2_oneof_foo::foo_bytes(v))
    }

    // Mutable pointer to the field.
    pub fn mut_foo_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(TestOneof2_oneof_foo::foo_bytes(_)) = self.foo {
        } else {
            self.foo = ::std::option::Option::Some(TestOneof2_oneof_foo::foo_bytes(::std::vec::Vec::new()));
        }
        match self.foo {
            ::std::option::Option::Some(TestOneof2_oneof_foo::foo_bytes(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_foo_bytes(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_foo_bytes() {
            match self.foo.take() {
                ::std::option::Option::Some(TestOneof2_oneof_foo::foo_bytes(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    pub fn get_foo_bytes(&self) -> &[u8] {
        match self.foo {
            ::std::option::Option::Some(TestOneof2_oneof_foo::foo_bytes(ref v)) => v,
            _ => &[],
        }
    }

    // optional .protobuf_unittest.TestOneof2.NestedEnum foo_enum = 6;

    pub fn clear_foo_enum(&mut self) {
        self.foo = ::std::option::Option::None;
    }

    pub fn has_foo_enum(&self) -> bool {
        match self.foo {
            ::std::option::Option::Some(TestOneof2_oneof_foo::foo_enum(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_foo_enum(&mut self, v: TestOneof2_NestedEnum) {
        self.foo = ::std::option::Option::Some(TestOneof2_oneof_foo::foo_enum(v))
    }

    pub fn get_foo_enum(&self) -> TestOneof2_NestedEnum {
        match self.foo {
            ::std::option::Option::Some(TestOneof2_oneof_foo::foo_enum(v)) => v,
            _ => TestOneof2_NestedEnum::FOO,
        }
    }

    // optional .protobuf_unittest.TestOneof2.NestedMessage foo_message = 7;

    pub fn clear_foo_message(&mut self) {
        self.foo = ::std::option::Option::None;
    }

    pub fn has_foo_message(&self) -> bool {
        match self.foo {
            ::std::option::Option::Some(TestOneof2_oneof_foo::foo_message(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_foo_message(&mut self, v: TestOneof2_NestedMessage) {
        self.foo = ::std::option::Option::Some(TestOneof2_oneof_foo::foo_message(v))
    }

    // Mutable pointer to the field.
    pub fn mut_foo_message(&mut self) -> &mut TestOneof2_NestedMessage {
        if let ::std::option::Option::Some(TestOneof2_oneof_foo::foo_message(_)) = self.foo {
        } else {
            self.foo = ::std::option::Option::Some(TestOneof2_oneof_foo::foo_message(TestOneof2_NestedMessage::new()));
        }
        match self.foo {
            ::std::option::Option::Some(TestOneof2_oneof_foo::foo_message(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_foo_message(&mut self) -> TestOneof2_NestedMessage {
        if self.has_foo_message() {
            match self.foo.take() {
                ::std::option::Option::Some(TestOneof2_oneof_foo::foo_message(v)) => v,
                _ => panic!(),
            }
        } else {
            TestOneof2_NestedMessage::new()
        }
    }

    pub fn get_foo_message(&self) -> &TestOneof2_NestedMessage {
        match self.foo {
            ::std::option::Option::Some(TestOneof2_oneof_foo::foo_message(ref v)) => v,
            _ => TestOneof2_NestedMessage::default_instance(),
        }
    }

    // optional .protobuf_unittest.TestOneof2.NestedMessage foo_lazy_message = 11;

    pub fn clear_foo_lazy_message(&mut self) {
        self.foo = ::std::option::Option::None;
    }

    pub fn has_foo_lazy_message(&self) -> bool {
        match self.foo {
            ::std::option::Option::Some(TestOneof2_oneof_foo::foo_lazy_message(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_foo_lazy_message(&mut self, v: TestOneof2_NestedMessage) {
        self.foo = ::std::option::Option::Some(TestOneof2_oneof_foo::foo_lazy_message(v))
    }

    // Mutable pointer to the field.
    pub fn mut_foo_lazy_message(&mut self) -> &mut TestOneof2_NestedMessage {
        if let ::std::option::Option::Some(TestOneof2_oneof_foo::foo_lazy_message(_)) = self.foo {
        } else {
            self.foo = ::std::option::Option::Some(TestOneof2_oneof_foo::foo_lazy_message(TestOneof2_NestedMessage::new()));
        }
        match self.foo {
            ::std::option::Option::Some(TestOneof2_oneof_foo::foo_lazy_message(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_foo_lazy_message(&mut self) -> TestOneof2_NestedMessage {
        if self.has_foo_lazy_message() {
            match self.foo.take() {
                ::std::option::Option::Some(TestOneof2_oneof_foo::foo_lazy_message(v)) => v,
                _ => panic!(),
            }
        } else {
            TestOneof2_NestedMessage::new()
        }
    }

    pub fn get_foo_lazy_message(&self) -> &TestOneof2_NestedMessage {
        match self.foo {
            ::std::option::Option::Some(TestOneof2_oneof_foo::foo_lazy_message(ref v)) => v,
            _ => TestOneof2_NestedMessage::default_instance(),
        }
    }

    // optional int32 bar_int = 12;

    pub fn clear_bar_int(&mut self) {
        self.bar = ::std::option::Option::None;
    }

    pub fn has_bar_int(&self) -> bool {
        match self.bar {
            ::std::option::Option::Some(TestOneof2_oneof_bar::bar_int(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bar_int(&mut self, v: i32) {
        self.bar = ::std::option::Option::Some(TestOneof2_oneof_bar::bar_int(v))
    }

    pub fn get_bar_int(&self) -> i32 {
        match self.bar {
            ::std::option::Option::Some(TestOneof2_oneof_bar::bar_int(v)) => v,
            _ => 5i32,
        }
    }

    // optional .protobuf_unittest.TestOneof2.NestedEnum bar_enum = 17;

    pub fn clear_bar_enum(&mut self) {
        self.bar = ::std::option::Option::None;
    }

    pub fn has_bar_enum(&self) -> bool {
        match self.bar {
            ::std::option::Option::Some(TestOneof2_oneof_bar::bar_enum(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bar_enum(&mut self, v: TestOneof2_NestedEnum) {
        self.bar = ::std::option::Option::Some(TestOneof2_oneof_bar::bar_enum(v))
    }

    pub fn get_bar_enum(&self) -> TestOneof2_NestedEnum {
        match self.bar {
            ::std::option::Option::Some(TestOneof2_oneof_bar::bar_enum(v)) => v,
            _ => TestOneof2_NestedEnum::BAR,
        }
    }

    // optional int32 baz_int = 18;

    pub fn clear_baz_int(&mut self) {
        self.baz_int = ::std::option::Option::None;
    }

    pub fn has_baz_int(&self) -> bool {
        self.baz_int.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baz_int(&mut self, v: i32) {
        self.baz_int = ::std::option::Option::Some(v);
    }

    pub fn get_baz_int(&self) -> i32 {
        self.baz_int.unwrap_or(0)
    }

    // optional string baz_string = 19;

    pub fn clear_baz_string(&mut self) {
        self.baz_string.clear();
    }

    pub fn has_baz_string(&self) -> bool {
        self.baz_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baz_string(&mut self, v: ::std::string::String) {
        self.baz_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_baz_string(&mut self) -> &mut ::std::string::String {
        if self.baz_string.is_none() {
            self.baz_string.set_default();
        }
        self.baz_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_baz_string(&mut self) -> ::std::string::String {
        self.baz_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_baz_string(&self) -> &str {
        match self.baz_string.as_ref() {
            Some(v) => &v,
            None => "BAZ",
        }
    }
}

impl ::protobuf::Message for TestOneof2 {
    fn is_initialized(&self) -> bool {
        if let Some(TestOneof2_oneof_foo::foo_message(ref v)) = self.foo {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TestOneof2_oneof_foo::foo_lazy_message(ref v)) = self.foo {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.foo = ::std::option::Option::Some(TestOneof2_oneof_foo::foo_int(is.read_int32()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.foo = ::std::option::Option::Some(TestOneof2_oneof_foo::foo_string(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.foo = ::std::option::Option::Some(TestOneof2_oneof_foo::foo_cord(is.read_string()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.foo = ::std::option::Option::Some(TestOneof2_oneof_foo::foo_string_piece(is.read_string()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.foo = ::std::option::Option::Some(TestOneof2_oneof_foo::foo_bytes(is.read_bytes()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.foo = ::std::option::Option::Some(TestOneof2_oneof_foo::foo_enum(is.read_enum()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.foo = ::std::option::Option::Some(TestOneof2_oneof_foo::foo_message(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.foo = ::std::option::Option::Some(TestOneof2_oneof_foo::foo_lazy_message(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bar = ::std::option::Option::Some(TestOneof2_oneof_bar::bar_int(is.read_int32()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bar = ::std::option::Option::Some(TestOneof2_oneof_bar::bar_enum(is.read_enum()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.baz_int = ::std::option::Option::Some(tmp);
                },
                19 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.baz_string)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.baz_int {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.baz_string.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.foo {
            match v {
                &TestOneof2_oneof_foo::foo_int(v) => {
                    my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &TestOneof2_oneof_foo::foo_string(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &TestOneof2_oneof_foo::foo_cord(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
                &TestOneof2_oneof_foo::foo_string_piece(ref v) => {
                    my_size += ::protobuf::rt::string_size(4, &v);
                },
                &TestOneof2_oneof_foo::foo_bytes(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(5, &v);
                },
                &TestOneof2_oneof_foo::foo_enum(v) => {
                    my_size += ::protobuf::rt::enum_size(6, v);
                },
                &TestOneof2_oneof_foo::foo_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TestOneof2_oneof_foo::foo_lazy_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.bar {
            match v {
                &TestOneof2_oneof_bar::bar_int(v) => {
                    my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &TestOneof2_oneof_bar::bar_enum(v) => {
                    my_size += ::protobuf::rt::enum_size(17, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.baz_int {
            os.write_int32(18, v)?;
        }
        if let Some(ref v) = self.baz_string.as_ref() {
            os.write_string(19, &v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.foo {
            match v {
                &TestOneof2_oneof_foo::foo_int(v) => {
                    os.write_int32(1, v)?;
                },
                &TestOneof2_oneof_foo::foo_string(ref v) => {
                    os.write_string(2, v)?;
                },
                &TestOneof2_oneof_foo::foo_cord(ref v) => {
                    os.write_string(3, v)?;
                },
                &TestOneof2_oneof_foo::foo_string_piece(ref v) => {
                    os.write_string(4, v)?;
                },
                &TestOneof2_oneof_foo::foo_bytes(ref v) => {
                    os.write_bytes(5, v)?;
                },
                &TestOneof2_oneof_foo::foo_enum(v) => {
                    os.write_enum(6, v.value())?;
                },
                &TestOneof2_oneof_foo::foo_message(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TestOneof2_oneof_foo::foo_lazy_message(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.bar {
            match v {
                &TestOneof2_oneof_bar::bar_int(v) => {
                    os.write_int32(12, v)?;
                },
                &TestOneof2_oneof_bar::bar_enum(v) => {
                    os.write_enum(17, v.value())?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestOneof2 {
        TestOneof2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                    "foo_int",
                    TestOneof2::has_foo_int,
                    TestOneof2::get_foo_int,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "foo_string",
                    TestOneof2::has_foo_string,
                    TestOneof2::get_foo_string,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "foo_cord",
                    TestOneof2::has_foo_cord,
                    TestOneof2::get_foo_cord,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "foo_string_piece",
                    TestOneof2::has_foo_string_piece,
                    TestOneof2::get_foo_string_piece,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "foo_bytes",
                    TestOneof2::has_foo_bytes,
                    TestOneof2::get_foo_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, TestOneof2_NestedEnum>(
                    "foo_enum",
                    TestOneof2::has_foo_enum,
                    TestOneof2::get_foo_enum,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TestOneof2_NestedMessage>(
                    "foo_message",
                    TestOneof2::has_foo_message,
                    TestOneof2::get_foo_message,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TestOneof2_NestedMessage>(
                    "foo_lazy_message",
                    TestOneof2::has_foo_lazy_message,
                    TestOneof2::get_foo_lazy_message,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                    "bar_int",
                    TestOneof2::has_bar_int,
                    TestOneof2::get_bar_int,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, TestOneof2_NestedEnum>(
                    "bar_enum",
                    TestOneof2::has_bar_enum,
                    TestOneof2::get_bar_enum,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "baz_int",
                    |m: &TestOneof2| { &m.baz_int },
                    |m: &mut TestOneof2| { &mut m.baz_int },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "baz_string",
                    |m: &TestOneof2| { &m.baz_string },
                    |m: &mut TestOneof2| { &mut m.baz_string },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestOneof2>(
                    "TestOneof2",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestOneof2 {
        static mut instance: ::protobuf::lazy::Lazy<TestOneof2> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestOneof2,
        };
        unsafe {
            instance.get(TestOneof2::new)
        }
    }
}

impl ::protobuf::Clear for TestOneof2 {
    fn clear(&mut self) {
        self.clear_foo_int();
        self.clear_foo_string();
        self.clear_foo_cord();
        self.clear_foo_string_piece();
        self.clear_foo_bytes();
        self.clear_foo_enum();
        self.clear_foo_message();
        self.clear_foo_lazy_message();
        self.clear_bar_int();
        self.clear_bar_enum();
        self.clear_baz_int();
        self.clear_baz_string();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestOneof2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestOneof2 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestOneof2_NestedMessage {
    // message fields
    qux_int: ::std::option::Option<i64>,
    corge_int: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestOneof2_NestedMessage {
    pub fn new() -> TestOneof2_NestedMessage {
        ::std::default::Default::default()
    }

    // optional int64 qux_int = 1;

    pub fn clear_qux_int(&mut self) {
        self.qux_int = ::std::option::Option::None;
    }

    pub fn has_qux_int(&self) -> bool {
        self.qux_int.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qux_int(&mut self, v: i64) {
        self.qux_int = ::std::option::Option::Some(v);
    }

    pub fn get_qux_int(&self) -> i64 {
        self.qux_int.unwrap_or(0)
    }

    // repeated int32 corge_int = 2;

    pub fn clear_corge_int(&mut self) {
        self.corge_int.clear();
    }

    // Param is passed by value, moved
    pub fn set_corge_int(&mut self, v: ::std::vec::Vec<i32>) {
        self.corge_int = v;
    }

    // Mutable pointer to the field.
    pub fn mut_corge_int(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.corge_int
    }

    // Take field
    pub fn take_corge_int(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.corge_int, ::std::vec::Vec::new())
    }

    pub fn get_corge_int(&self) -> &[i32] {
        &self.corge_int
    }
}

impl ::protobuf::Message for TestOneof2_NestedMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.qux_int = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.corge_int)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.qux_int {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.corge_int {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.qux_int {
            os.write_int64(1, v)?;
        }
        for v in &self.corge_int {
            os.write_int32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestOneof2_NestedMessage {
        TestOneof2_NestedMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "qux_int",
                    |m: &TestOneof2_NestedMessage| { &m.qux_int },
                    |m: &mut TestOneof2_NestedMessage| { &mut m.qux_int },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "corge_int",
                    |m: &TestOneof2_NestedMessage| { &m.corge_int },
                    |m: &mut TestOneof2_NestedMessage| { &mut m.corge_int },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestOneof2_NestedMessage>(
                    "TestOneof2_NestedMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestOneof2_NestedMessage {
        static mut instance: ::protobuf::lazy::Lazy<TestOneof2_NestedMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestOneof2_NestedMessage,
        };
        unsafe {
            instance.get(TestOneof2_NestedMessage::new)
        }
    }
}

impl ::protobuf::Clear for TestOneof2_NestedMessage {
    fn clear(&mut self) {
        self.clear_qux_int();
        self.clear_corge_int();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestOneof2_NestedMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestOneof2_NestedMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TestOneof2_NestedEnum {
    FOO = 1,
    BAR = 2,
    BAZ = 3,
}

impl ::protobuf::ProtobufEnum for TestOneof2_NestedEnum {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TestOneof2_NestedEnum> {
        match value {
            1 => ::std::option::Option::Some(TestOneof2_NestedEnum::FOO),
            2 => ::std::option::Option::Some(TestOneof2_NestedEnum::BAR),
            3 => ::std::option::Option::Some(TestOneof2_NestedEnum::BAZ),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TestOneof2_NestedEnum] = &[
            TestOneof2_NestedEnum::FOO,
            TestOneof2_NestedEnum::BAR,
            TestOneof2_NestedEnum::BAZ,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TestOneof2_NestedEnum", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TestOneof2_NestedEnum {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TestOneof2_NestedEnum {
    fn default() -> Self {
        TestOneof2_NestedEnum::FOO
    }
}

impl ::protobuf::reflect::ProtobufValue for TestOneof2_NestedEnum {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestRequiredOneof {
    // message oneof groups
    pub foo: ::std::option::Option<TestRequiredOneof_oneof_foo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum TestRequiredOneof_oneof_foo {
    foo_int(i32),
    foo_string(::std::string::String),
    foo_message(TestRequiredOneof_NestedMessage),
}

impl TestRequiredOneof {
    pub fn new() -> TestRequiredOneof {
        ::std::default::Default::default()
    }

    // optional int32 foo_int = 1;

    pub fn clear_foo_int(&mut self) {
        self.foo = ::std::option::Option::None;
    }

    pub fn has_foo_int(&self) -> bool {
        match self.foo {
            ::std::option::Option::Some(TestRequiredOneof_oneof_foo::foo_int(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_foo_int(&mut self, v: i32) {
        self.foo = ::std::option::Option::Some(TestRequiredOneof_oneof_foo::foo_int(v))
    }

    pub fn get_foo_int(&self) -> i32 {
        match self.foo {
            ::std::option::Option::Some(TestRequiredOneof_oneof_foo::foo_int(v)) => v,
            _ => 0,
        }
    }

    // optional string foo_string = 2;

    pub fn clear_foo_string(&mut self) {
        self.foo = ::std::option::Option::None;
    }

    pub fn has_foo_string(&self) -> bool {
        match self.foo {
            ::std::option::Option::Some(TestRequiredOneof_oneof_foo::foo_string(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_foo_string(&mut self, v: ::std::string::String) {
        self.foo = ::std::option::Option::Some(TestRequiredOneof_oneof_foo::foo_string(v))
    }

    // Mutable pointer to the field.
    pub fn mut_foo_string(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(TestRequiredOneof_oneof_foo::foo_string(_)) = self.foo {
        } else {
            self.foo = ::std::option::Option::Some(TestRequiredOneof_oneof_foo::foo_string(::std::string::String::new()));
        }
        match self.foo {
            ::std::option::Option::Some(TestRequiredOneof_oneof_foo::foo_string(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_foo_string(&mut self) -> ::std::string::String {
        if self.has_foo_string() {
            match self.foo.take() {
                ::std::option::Option::Some(TestRequiredOneof_oneof_foo::foo_string(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_foo_string(&self) -> &str {
        match self.foo {
            ::std::option::Option::Some(TestRequiredOneof_oneof_foo::foo_string(ref v)) => v,
            _ => "",
        }
    }

    // optional .protobuf_unittest.TestRequiredOneof.NestedMessage foo_message = 3;

    pub fn clear_foo_message(&mut self) {
        self.foo = ::std::option::Option::None;
    }

    pub fn has_foo_message(&self) -> bool {
        match self.foo {
            ::std::option::Option::Some(TestRequiredOneof_oneof_foo::foo_message(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_foo_message(&mut self, v: TestRequiredOneof_NestedMessage) {
        self.foo = ::std::option::Option::Some(TestRequiredOneof_oneof_foo::foo_message(v))
    }

    // Mutable pointer to the field.
    pub fn mut_foo_message(&mut self) -> &mut TestRequiredOneof_NestedMessage {
        if let ::std::option::Option::Some(TestRequiredOneof_oneof_foo::foo_message(_)) = self.foo {
        } else {
            self.foo = ::std::option::Option::Some(TestRequiredOneof_oneof_foo::foo_message(TestRequiredOneof_NestedMessage::new()));
        }
        match self.foo {
            ::std::option::Option::Some(TestRequiredOneof_oneof_foo::foo_message(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_foo_message(&mut self) -> TestRequiredOneof_NestedMessage {
        if self.has_foo_message() {
            match self.foo.take() {
                ::std::option::Option::Some(TestRequiredOneof_oneof_foo::foo_message(v)) => v,
                _ => panic!(),
            }
        } else {
            TestRequiredOneof_NestedMessage::new()
        }
    }

    pub fn get_foo_message(&self) -> &TestRequiredOneof_NestedMessage {
        match self.foo {
            ::std::option::Option::Some(TestRequiredOneof_oneof_foo::foo_message(ref v)) => v,
            _ => TestRequiredOneof_NestedMessage::default_instance(),
        }
    }
}

impl ::protobuf::Message for TestRequiredOneof {
    fn is_initialized(&self) -> bool {
        if let Some(TestRequiredOneof_oneof_foo::foo_message(ref v)) = self.foo {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.foo = ::std::option::Option::Some(TestRequiredOneof_oneof_foo::foo_int(is.read_int32()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.foo = ::std::option::Option::Some(TestRequiredOneof_oneof_foo::foo_string(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.foo = ::std::option::Option::Some(TestRequiredOneof_oneof_foo::foo_message(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.foo {
            match v {
                &TestRequiredOneof_oneof_foo::foo_int(v) => {
                    my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &TestRequiredOneof_oneof_foo::foo_string(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &TestRequiredOneof_oneof_foo::foo_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.foo {
            match v {
                &TestRequiredOneof_oneof_foo::foo_int(v) => {
                    os.write_int32(1, v)?;
                },
                &TestRequiredOneof_oneof_foo::foo_string(ref v) => {
                    os.write_string(2, v)?;
                },
                &TestRequiredOneof_oneof_foo::foo_message(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestRequiredOneof {
        TestRequiredOneof::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                    "foo_int",
                    TestRequiredOneof::has_foo_int,
                    TestRequiredOneof::get_foo_int,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "foo_string",
                    TestRequiredOneof::has_foo_string,
                    TestRequiredOneof::get_foo_string,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TestRequiredOneof_NestedMessage>(
                    "foo_message",
                    TestRequiredOneof::has_foo_message,
                    TestRequiredOneof::get_foo_message,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestRequiredOneof>(
                    "TestRequiredOneof",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestRequiredOneof {
        static mut instance: ::protobuf::lazy::Lazy<TestRequiredOneof> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestRequiredOneof,
        };
        unsafe {
            instance.get(TestRequiredOneof::new)
        }
    }
}

impl ::protobuf::Clear for TestRequiredOneof {
    fn clear(&mut self) {
        self.clear_foo_int();
        self.clear_foo_string();
        self.clear_foo_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestRequiredOneof {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestRequiredOneof {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestRequiredOneof_NestedMessage {
    // message fields
    required_double: ::std::option::Option<f64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestRequiredOneof_NestedMessage {
    pub fn new() -> TestRequiredOneof_NestedMessage {
        ::std::default::Default::default()
    }

    // required double required_double = 1;

    pub fn clear_required_double(&mut self) {
        self.required_double = ::std::option::Option::None;
    }

    pub fn has_required_double(&self) -> bool {
        self.required_double.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_double(&mut self, v: f64) {
        self.required_double = ::std::option::Option::Some(v);
    }

    pub fn get_required_double(&self) -> f64 {
        self.required_double.unwrap_or(0.)
    }
}

impl ::protobuf::Message for TestRequiredOneof_NestedMessage {
    fn is_initialized(&self) -> bool {
        if self.required_double.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.required_double = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.required_double {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.required_double {
            os.write_double(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestRequiredOneof_NestedMessage {
        TestRequiredOneof_NestedMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "required_double",
                    |m: &TestRequiredOneof_NestedMessage| { &m.required_double },
                    |m: &mut TestRequiredOneof_NestedMessage| { &mut m.required_double },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestRequiredOneof_NestedMessage>(
                    "TestRequiredOneof_NestedMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestRequiredOneof_NestedMessage {
        static mut instance: ::protobuf::lazy::Lazy<TestRequiredOneof_NestedMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestRequiredOneof_NestedMessage,
        };
        unsafe {
            instance.get(TestRequiredOneof_NestedMessage::new)
        }
    }
}

impl ::protobuf::Clear for TestRequiredOneof_NestedMessage {
    fn clear(&mut self) {
        self.clear_required_double();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestRequiredOneof_NestedMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestRequiredOneof_NestedMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestPackedTypes {
    // message fields
    packed_int32: ::std::vec::Vec<i32>,
    packed_int64: ::std::vec::Vec<i64>,
    packed_uint32: ::std::vec::Vec<u32>,
    packed_uint64: ::std::vec::Vec<u64>,
    packed_sint32: ::std::vec::Vec<i32>,
    packed_sint64: ::std::vec::Vec<i64>,
    packed_fixed32: ::std::vec::Vec<u32>,
    packed_fixed64: ::std::vec::Vec<u64>,
    packed_sfixed32: ::std::vec::Vec<i32>,
    packed_sfixed64: ::std::vec::Vec<i64>,
    packed_float: ::std::vec::Vec<f32>,
    packed_double: ::std::vec::Vec<f64>,
    packed_bool: ::std::vec::Vec<bool>,
    packed_enum: ::std::vec::Vec<ForeignEnum>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestPackedTypes {
    pub fn new() -> TestPackedTypes {
        ::std::default::Default::default()
    }

    // repeated int32 packed_int32 = 90;

    pub fn clear_packed_int32(&mut self) {
        self.packed_int32.clear();
    }

    // Param is passed by value, moved
    pub fn set_packed_int32(&mut self, v: ::std::vec::Vec<i32>) {
        self.packed_int32 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packed_int32(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.packed_int32
    }

    // Take field
    pub fn take_packed_int32(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.packed_int32, ::std::vec::Vec::new())
    }

    pub fn get_packed_int32(&self) -> &[i32] {
        &self.packed_int32
    }

    // repeated int64 packed_int64 = 91;

    pub fn clear_packed_int64(&mut self) {
        self.packed_int64.clear();
    }

    // Param is passed by value, moved
    pub fn set_packed_int64(&mut self, v: ::std::vec::Vec<i64>) {
        self.packed_int64 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packed_int64(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.packed_int64
    }

    // Take field
    pub fn take_packed_int64(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.packed_int64, ::std::vec::Vec::new())
    }

    pub fn get_packed_int64(&self) -> &[i64] {
        &self.packed_int64
    }

    // repeated uint32 packed_uint32 = 92;

    pub fn clear_packed_uint32(&mut self) {
        self.packed_uint32.clear();
    }

    // Param is passed by value, moved
    pub fn set_packed_uint32(&mut self, v: ::std::vec::Vec<u32>) {
        self.packed_uint32 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packed_uint32(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.packed_uint32
    }

    // Take field
    pub fn take_packed_uint32(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.packed_uint32, ::std::vec::Vec::new())
    }

    pub fn get_packed_uint32(&self) -> &[u32] {
        &self.packed_uint32
    }

    // repeated uint64 packed_uint64 = 93;

    pub fn clear_packed_uint64(&mut self) {
        self.packed_uint64.clear();
    }

    // Param is passed by value, moved
    pub fn set_packed_uint64(&mut self, v: ::std::vec::Vec<u64>) {
        self.packed_uint64 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packed_uint64(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.packed_uint64
    }

    // Take field
    pub fn take_packed_uint64(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.packed_uint64, ::std::vec::Vec::new())
    }

    pub fn get_packed_uint64(&self) -> &[u64] {
        &self.packed_uint64
    }

    // repeated sint32 packed_sint32 = 94;

    pub fn clear_packed_sint32(&mut self) {
        self.packed_sint32.clear();
    }

    // Param is passed by value, moved
    pub fn set_packed_sint32(&mut self, v: ::std::vec::Vec<i32>) {
        self.packed_sint32 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packed_sint32(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.packed_sint32
    }

    // Take field
    pub fn take_packed_sint32(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.packed_sint32, ::std::vec::Vec::new())
    }

    pub fn get_packed_sint32(&self) -> &[i32] {
        &self.packed_sint32
    }

    // repeated sint64 packed_sint64 = 95;

    pub fn clear_packed_sint64(&mut self) {
        self.packed_sint64.clear();
    }

    // Param is passed by value, moved
    pub fn set_packed_sint64(&mut self, v: ::std::vec::Vec<i64>) {
        self.packed_sint64 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packed_sint64(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.packed_sint64
    }

    // Take field
    pub fn take_packed_sint64(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.packed_sint64, ::std::vec::Vec::new())
    }

    pub fn get_packed_sint64(&self) -> &[i64] {
        &self.packed_sint64
    }

    // repeated fixed32 packed_fixed32 = 96;

    pub fn clear_packed_fixed32(&mut self) {
        self.packed_fixed32.clear();
    }

    // Param is passed by value, moved
    pub fn set_packed_fixed32(&mut self, v: ::std::vec::Vec<u32>) {
        self.packed_fixed32 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packed_fixed32(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.packed_fixed32
    }

    // Take field
    pub fn take_packed_fixed32(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.packed_fixed32, ::std::vec::Vec::new())
    }

    pub fn get_packed_fixed32(&self) -> &[u32] {
        &self.packed_fixed32
    }

    // repeated fixed64 packed_fixed64 = 97;

    pub fn clear_packed_fixed64(&mut self) {
        self.packed_fixed64.clear();
    }

    // Param is passed by value, moved
    pub fn set_packed_fixed64(&mut self, v: ::std::vec::Vec<u64>) {
        self.packed_fixed64 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packed_fixed64(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.packed_fixed64
    }

    // Take field
    pub fn take_packed_fixed64(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.packed_fixed64, ::std::vec::Vec::new())
    }

    pub fn get_packed_fixed64(&self) -> &[u64] {
        &self.packed_fixed64
    }

    // repeated sfixed32 packed_sfixed32 = 98;

    pub fn clear_packed_sfixed32(&mut self) {
        self.packed_sfixed32.clear();
    }

    // Param is passed by value, moved
    pub fn set_packed_sfixed32(&mut self, v: ::std::vec::Vec<i32>) {
        self.packed_sfixed32 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packed_sfixed32(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.packed_sfixed32
    }

    // Take field
    pub fn take_packed_sfixed32(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.packed_sfixed32, ::std::vec::Vec::new())
    }

    pub fn get_packed_sfixed32(&self) -> &[i32] {
        &self.packed_sfixed32
    }

    // repeated sfixed64 packed_sfixed64 = 99;

    pub fn clear_packed_sfixed64(&mut self) {
        self.packed_sfixed64.clear();
    }

    // Param is passed by value, moved
    pub fn set_packed_sfixed64(&mut self, v: ::std::vec::Vec<i64>) {
        self.packed_sfixed64 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packed_sfixed64(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.packed_sfixed64
    }

    // Take field
    pub fn take_packed_sfixed64(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.packed_sfixed64, ::std::vec::Vec::new())
    }

    pub fn get_packed_sfixed64(&self) -> &[i64] {
        &self.packed_sfixed64
    }

    // repeated float packed_float = 100;

    pub fn clear_packed_float(&mut self) {
        self.packed_float.clear();
    }

    // Param is passed by value, moved
    pub fn set_packed_float(&mut self, v: ::std::vec::Vec<f32>) {
        self.packed_float = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packed_float(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.packed_float
    }

    // Take field
    pub fn take_packed_float(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.packed_float, ::std::vec::Vec::new())
    }

    pub fn get_packed_float(&self) -> &[f32] {
        &self.packed_float
    }

    // repeated double packed_double = 101;

    pub fn clear_packed_double(&mut self) {
        self.packed_double.clear();
    }

    // Param is passed by value, moved
    pub fn set_packed_double(&mut self, v: ::std::vec::Vec<f64>) {
        self.packed_double = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packed_double(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.packed_double
    }

    // Take field
    pub fn take_packed_double(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.packed_double, ::std::vec::Vec::new())
    }

    pub fn get_packed_double(&self) -> &[f64] {
        &self.packed_double
    }

    // repeated bool packed_bool = 102;

    pub fn clear_packed_bool(&mut self) {
        self.packed_bool.clear();
    }

    // Param is passed by value, moved
    pub fn set_packed_bool(&mut self, v: ::std::vec::Vec<bool>) {
        self.packed_bool = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packed_bool(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.packed_bool
    }

    // Take field
    pub fn take_packed_bool(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.packed_bool, ::std::vec::Vec::new())
    }

    pub fn get_packed_bool(&self) -> &[bool] {
        &self.packed_bool
    }

    // repeated .protobuf_unittest.ForeignEnum packed_enum = 103;

    pub fn clear_packed_enum(&mut self) {
        self.packed_enum.clear();
    }

    // Param is passed by value, moved
    pub fn set_packed_enum(&mut self, v: ::std::vec::Vec<ForeignEnum>) {
        self.packed_enum = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packed_enum(&mut self) -> &mut ::std::vec::Vec<ForeignEnum> {
        &mut self.packed_enum
    }

    // Take field
    pub fn take_packed_enum(&mut self) -> ::std::vec::Vec<ForeignEnum> {
        ::std::mem::replace(&mut self.packed_enum, ::std::vec::Vec::new())
    }

    pub fn get_packed_enum(&self) -> &[ForeignEnum] {
        &self.packed_enum
    }
}

impl ::protobuf::Message for TestPackedTypes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                90 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.packed_int32)?;
                },
                91 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.packed_int64)?;
                },
                92 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.packed_uint32)?;
                },
                93 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.packed_uint64)?;
                },
                94 => {
                    ::protobuf::rt::read_repeated_sint32_into(wire_type, is, &mut self.packed_sint32)?;
                },
                95 => {
                    ::protobuf::rt::read_repeated_sint64_into(wire_type, is, &mut self.packed_sint64)?;
                },
                96 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.packed_fixed32)?;
                },
                97 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.packed_fixed64)?;
                },
                98 => {
                    ::protobuf::rt::read_repeated_sfixed32_into(wire_type, is, &mut self.packed_sfixed32)?;
                },
                99 => {
                    ::protobuf::rt::read_repeated_sfixed64_into(wire_type, is, &mut self.packed_sfixed64)?;
                },
                100 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.packed_float)?;
                },
                101 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.packed_double)?;
                },
                102 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.packed_bool)?;
                },
                103 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.packed_enum, 103, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.packed_int32.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(90, &self.packed_int32);
        }
        if !self.packed_int64.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(91, &self.packed_int64);
        }
        if !self.packed_uint32.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(92, &self.packed_uint32);
        }
        if !self.packed_uint64.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(93, &self.packed_uint64);
        }
        if !self.packed_sint32.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(94, &self.packed_sint32);
        }
        if !self.packed_sint64.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(95, &self.packed_sint64);
        }
        if !self.packed_fixed32.is_empty() {
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size((self.packed_fixed32.len() * 4) as u32) + (self.packed_fixed32.len() * 4) as u32;
        }
        if !self.packed_fixed64.is_empty() {
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size((self.packed_fixed64.len() * 8) as u32) + (self.packed_fixed64.len() * 8) as u32;
        }
        if !self.packed_sfixed32.is_empty() {
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size((self.packed_sfixed32.len() * 4) as u32) + (self.packed_sfixed32.len() * 4) as u32;
        }
        if !self.packed_sfixed64.is_empty() {
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size((self.packed_sfixed64.len() * 8) as u32) + (self.packed_sfixed64.len() * 8) as u32;
        }
        if !self.packed_float.is_empty() {
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size((self.packed_float.len() * 4) as u32) + (self.packed_float.len() * 4) as u32;
        }
        if !self.packed_double.is_empty() {
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size((self.packed_double.len() * 8) as u32) + (self.packed_double.len() * 8) as u32;
        }
        if !self.packed_bool.is_empty() {
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size((self.packed_bool.len() * 1) as u32) + (self.packed_bool.len() * 1) as u32;
        }
        if !self.packed_enum.is_empty() {
            my_size += ::protobuf::rt::vec_packed_enum_size(103, &self.packed_enum);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.packed_int32.is_empty() {
            os.write_tag(90, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.packed_int32))?;
            for v in &self.packed_int32 {
                os.write_int32_no_tag(*v)?;
            };
        }
        if !self.packed_int64.is_empty() {
            os.write_tag(91, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.packed_int64))?;
            for v in &self.packed_int64 {
                os.write_int64_no_tag(*v)?;
            };
        }
        if !self.packed_uint32.is_empty() {
            os.write_tag(92, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.packed_uint32))?;
            for v in &self.packed_uint32 {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.packed_uint64.is_empty() {
            os.write_tag(93, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.packed_uint64))?;
            for v in &self.packed_uint64 {
                os.write_uint64_no_tag(*v)?;
            };
        }
        if !self.packed_sint32.is_empty() {
            os.write_tag(94, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(&self.packed_sint32))?;
            for v in &self.packed_sint32 {
                os.write_sint32_no_tag(*v)?;
            };
        }
        if !self.packed_sint64.is_empty() {
            os.write_tag(95, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(&self.packed_sint64))?;
            for v in &self.packed_sint64 {
                os.write_sint64_no_tag(*v)?;
            };
        }
        if !self.packed_fixed32.is_empty() {
            os.write_tag(96, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.packed_fixed32.len() * 4) as u32)?;
            for v in &self.packed_fixed32 {
                os.write_fixed32_no_tag(*v)?;
            };
        }
        if !self.packed_fixed64.is_empty() {
            os.write_tag(97, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.packed_fixed64.len() * 8) as u32)?;
            for v in &self.packed_fixed64 {
                os.write_fixed64_no_tag(*v)?;
            };
        }
        if !self.packed_sfixed32.is_empty() {
            os.write_tag(98, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.packed_sfixed32.len() * 4) as u32)?;
            for v in &self.packed_sfixed32 {
                os.write_sfixed32_no_tag(*v)?;
            };
        }
        if !self.packed_sfixed64.is_empty() {
            os.write_tag(99, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.packed_sfixed64.len() * 8) as u32)?;
            for v in &self.packed_sfixed64 {
                os.write_sfixed64_no_tag(*v)?;
            };
        }
        if !self.packed_float.is_empty() {
            os.write_tag(100, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.packed_float.len() * 4) as u32)?;
            for v in &self.packed_float {
                os.write_float_no_tag(*v)?;
            };
        }
        if !self.packed_double.is_empty() {
            os.write_tag(101, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.packed_double.len() * 8) as u32)?;
            for v in &self.packed_double {
                os.write_double_no_tag(*v)?;
            };
        }
        if !self.packed_bool.is_empty() {
            os.write_tag(102, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.packed_bool.len() * 1) as u32)?;
            for v in &self.packed_bool {
                os.write_bool_no_tag(*v)?;
            };
        }
        if !self.packed_enum.is_empty() {
            os.write_tag(103, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_enum_data_size(&self.packed_enum))?;
            for v in &self.packed_enum {
                os.write_enum_no_tag(v.value())?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestPackedTypes {
        TestPackedTypes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "packed_int32",
                    |m: &TestPackedTypes| { &m.packed_int32 },
                    |m: &mut TestPackedTypes| { &mut m.packed_int32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "packed_int64",
                    |m: &TestPackedTypes| { &m.packed_int64 },
                    |m: &mut TestPackedTypes| { &mut m.packed_int64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "packed_uint32",
                    |m: &TestPackedTypes| { &m.packed_uint32 },
                    |m: &mut TestPackedTypes| { &mut m.packed_uint32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "packed_uint64",
                    |m: &TestPackedTypes| { &m.packed_uint64 },
                    |m: &mut TestPackedTypes| { &mut m.packed_uint64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "packed_sint32",
                    |m: &TestPackedTypes| { &m.packed_sint32 },
                    |m: &mut TestPackedTypes| { &mut m.packed_sint32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                    "packed_sint64",
                    |m: &TestPackedTypes| { &m.packed_sint64 },
                    |m: &mut TestPackedTypes| { &mut m.packed_sint64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "packed_fixed32",
                    |m: &TestPackedTypes| { &m.packed_fixed32 },
                    |m: &mut TestPackedTypes| { &mut m.packed_fixed32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "packed_fixed64",
                    |m: &TestPackedTypes| { &m.packed_fixed64 },
                    |m: &mut TestPackedTypes| { &mut m.packed_fixed64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSfixed32>(
                    "packed_sfixed32",
                    |m: &TestPackedTypes| { &m.packed_sfixed32 },
                    |m: &mut TestPackedTypes| { &mut m.packed_sfixed32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSfixed64>(
                    "packed_sfixed64",
                    |m: &TestPackedTypes| { &m.packed_sfixed64 },
                    |m: &mut TestPackedTypes| { &mut m.packed_sfixed64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "packed_float",
                    |m: &TestPackedTypes| { &m.packed_float },
                    |m: &mut TestPackedTypes| { &mut m.packed_float },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "packed_double",
                    |m: &TestPackedTypes| { &m.packed_double },
                    |m: &mut TestPackedTypes| { &mut m.packed_double },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "packed_bool",
                    |m: &TestPackedTypes| { &m.packed_bool },
                    |m: &mut TestPackedTypes| { &mut m.packed_bool },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ForeignEnum>>(
                    "packed_enum",
                    |m: &TestPackedTypes| { &m.packed_enum },
                    |m: &mut TestPackedTypes| { &mut m.packed_enum },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestPackedTypes>(
                    "TestPackedTypes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestPackedTypes {
        static mut instance: ::protobuf::lazy::Lazy<TestPackedTypes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestPackedTypes,
        };
        unsafe {
            instance.get(TestPackedTypes::new)
        }
    }
}

impl ::protobuf::Clear for TestPackedTypes {
    fn clear(&mut self) {
        self.clear_packed_int32();
        self.clear_packed_int64();
        self.clear_packed_uint32();
        self.clear_packed_uint64();
        self.clear_packed_sint32();
        self.clear_packed_sint64();
        self.clear_packed_fixed32();
        self.clear_packed_fixed64();
        self.clear_packed_sfixed32();
        self.clear_packed_sfixed64();
        self.clear_packed_float();
        self.clear_packed_double();
        self.clear_packed_bool();
        self.clear_packed_enum();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestPackedTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestPackedTypes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestUnpackedTypes {
    // message fields
    unpacked_int32: ::std::vec::Vec<i32>,
    unpacked_int64: ::std::vec::Vec<i64>,
    unpacked_uint32: ::std::vec::Vec<u32>,
    unpacked_uint64: ::std::vec::Vec<u64>,
    unpacked_sint32: ::std::vec::Vec<i32>,
    unpacked_sint64: ::std::vec::Vec<i64>,
    unpacked_fixed32: ::std::vec::Vec<u32>,
    unpacked_fixed64: ::std::vec::Vec<u64>,
    unpacked_sfixed32: ::std::vec::Vec<i32>,
    unpacked_sfixed64: ::std::vec::Vec<i64>,
    unpacked_float: ::std::vec::Vec<f32>,
    unpacked_double: ::std::vec::Vec<f64>,
    unpacked_bool: ::std::vec::Vec<bool>,
    unpacked_enum: ::std::vec::Vec<ForeignEnum>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestUnpackedTypes {
    pub fn new() -> TestUnpackedTypes {
        ::std::default::Default::default()
    }

    // repeated int32 unpacked_int32 = 90;

    pub fn clear_unpacked_int32(&mut self) {
        self.unpacked_int32.clear();
    }

    // Param is passed by value, moved
    pub fn set_unpacked_int32(&mut self, v: ::std::vec::Vec<i32>) {
        self.unpacked_int32 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unpacked_int32(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.unpacked_int32
    }

    // Take field
    pub fn take_unpacked_int32(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.unpacked_int32, ::std::vec::Vec::new())
    }

    pub fn get_unpacked_int32(&self) -> &[i32] {
        &self.unpacked_int32
    }

    // repeated int64 unpacked_int64 = 91;

    pub fn clear_unpacked_int64(&mut self) {
        self.unpacked_int64.clear();
    }

    // Param is passed by value, moved
    pub fn set_unpacked_int64(&mut self, v: ::std::vec::Vec<i64>) {
        self.unpacked_int64 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unpacked_int64(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.unpacked_int64
    }

    // Take field
    pub fn take_unpacked_int64(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.unpacked_int64, ::std::vec::Vec::new())
    }

    pub fn get_unpacked_int64(&self) -> &[i64] {
        &self.unpacked_int64
    }

    // repeated uint32 unpacked_uint32 = 92;

    pub fn clear_unpacked_uint32(&mut self) {
        self.unpacked_uint32.clear();
    }

    // Param is passed by value, moved
    pub fn set_unpacked_uint32(&mut self, v: ::std::vec::Vec<u32>) {
        self.unpacked_uint32 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unpacked_uint32(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.unpacked_uint32
    }

    // Take field
    pub fn take_unpacked_uint32(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.unpacked_uint32, ::std::vec::Vec::new())
    }

    pub fn get_unpacked_uint32(&self) -> &[u32] {
        &self.unpacked_uint32
    }

    // repeated uint64 unpacked_uint64 = 93;

    pub fn clear_unpacked_uint64(&mut self) {
        self.unpacked_uint64.clear();
    }

    // Param is passed by value, moved
    pub fn set_unpacked_uint64(&mut self, v: ::std::vec::Vec<u64>) {
        self.unpacked_uint64 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unpacked_uint64(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.unpacked_uint64
    }

    // Take field
    pub fn take_unpacked_uint64(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.unpacked_uint64, ::std::vec::Vec::new())
    }

    pub fn get_unpacked_uint64(&self) -> &[u64] {
        &self.unpacked_uint64
    }

    // repeated sint32 unpacked_sint32 = 94;

    pub fn clear_unpacked_sint32(&mut self) {
        self.unpacked_sint32.clear();
    }

    // Param is passed by value, moved
    pub fn set_unpacked_sint32(&mut self, v: ::std::vec::Vec<i32>) {
        self.unpacked_sint32 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unpacked_sint32(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.unpacked_sint32
    }

    // Take field
    pub fn take_unpacked_sint32(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.unpacked_sint32, ::std::vec::Vec::new())
    }

    pub fn get_unpacked_sint32(&self) -> &[i32] {
        &self.unpacked_sint32
    }

    // repeated sint64 unpacked_sint64 = 95;

    pub fn clear_unpacked_sint64(&mut self) {
        self.unpacked_sint64.clear();
    }

    // Param is passed by value, moved
    pub fn set_unpacked_sint64(&mut self, v: ::std::vec::Vec<i64>) {
        self.unpacked_sint64 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unpacked_sint64(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.unpacked_sint64
    }

    // Take field
    pub fn take_unpacked_sint64(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.unpacked_sint64, ::std::vec::Vec::new())
    }

    pub fn get_unpacked_sint64(&self) -> &[i64] {
        &self.unpacked_sint64
    }

    // repeated fixed32 unpacked_fixed32 = 96;

    pub fn clear_unpacked_fixed32(&mut self) {
        self.unpacked_fixed32.clear();
    }

    // Param is passed by value, moved
    pub fn set_unpacked_fixed32(&mut self, v: ::std::vec::Vec<u32>) {
        self.unpacked_fixed32 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unpacked_fixed32(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.unpacked_fixed32
    }

    // Take field
    pub fn take_unpacked_fixed32(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.unpacked_fixed32, ::std::vec::Vec::new())
    }

    pub fn get_unpacked_fixed32(&self) -> &[u32] {
        &self.unpacked_fixed32
    }

    // repeated fixed64 unpacked_fixed64 = 97;

    pub fn clear_unpacked_fixed64(&mut self) {
        self.unpacked_fixed64.clear();
    }

    // Param is passed by value, moved
    pub fn set_unpacked_fixed64(&mut self, v: ::std::vec::Vec<u64>) {
        self.unpacked_fixed64 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unpacked_fixed64(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.unpacked_fixed64
    }

    // Take field
    pub fn take_unpacked_fixed64(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.unpacked_fixed64, ::std::vec::Vec::new())
    }

    pub fn get_unpacked_fixed64(&self) -> &[u64] {
        &self.unpacked_fixed64
    }

    // repeated sfixed32 unpacked_sfixed32 = 98;

    pub fn clear_unpacked_sfixed32(&mut self) {
        self.unpacked_sfixed32.clear();
    }

    // Param is passed by value, moved
    pub fn set_unpacked_sfixed32(&mut self, v: ::std::vec::Vec<i32>) {
        self.unpacked_sfixed32 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unpacked_sfixed32(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.unpacked_sfixed32
    }

    // Take field
    pub fn take_unpacked_sfixed32(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.unpacked_sfixed32, ::std::vec::Vec::new())
    }

    pub fn get_unpacked_sfixed32(&self) -> &[i32] {
        &self.unpacked_sfixed32
    }

    // repeated sfixed64 unpacked_sfixed64 = 99;

    pub fn clear_unpacked_sfixed64(&mut self) {
        self.unpacked_sfixed64.clear();
    }

    // Param is passed by value, moved
    pub fn set_unpacked_sfixed64(&mut self, v: ::std::vec::Vec<i64>) {
        self.unpacked_sfixed64 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unpacked_sfixed64(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.unpacked_sfixed64
    }

    // Take field
    pub fn take_unpacked_sfixed64(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.unpacked_sfixed64, ::std::vec::Vec::new())
    }

    pub fn get_unpacked_sfixed64(&self) -> &[i64] {
        &self.unpacked_sfixed64
    }

    // repeated float unpacked_float = 100;

    pub fn clear_unpacked_float(&mut self) {
        self.unpacked_float.clear();
    }

    // Param is passed by value, moved
    pub fn set_unpacked_float(&mut self, v: ::std::vec::Vec<f32>) {
        self.unpacked_float = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unpacked_float(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.unpacked_float
    }

    // Take field
    pub fn take_unpacked_float(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.unpacked_float, ::std::vec::Vec::new())
    }

    pub fn get_unpacked_float(&self) -> &[f32] {
        &self.unpacked_float
    }

    // repeated double unpacked_double = 101;

    pub fn clear_unpacked_double(&mut self) {
        self.unpacked_double.clear();
    }

    // Param is passed by value, moved
    pub fn set_unpacked_double(&mut self, v: ::std::vec::Vec<f64>) {
        self.unpacked_double = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unpacked_double(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.unpacked_double
    }

    // Take field
    pub fn take_unpacked_double(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.unpacked_double, ::std::vec::Vec::new())
    }

    pub fn get_unpacked_double(&self) -> &[f64] {
        &self.unpacked_double
    }

    // repeated bool unpacked_bool = 102;

    pub fn clear_unpacked_bool(&mut self) {
        self.unpacked_bool.clear();
    }

    // Param is passed by value, moved
    pub fn set_unpacked_bool(&mut self, v: ::std::vec::Vec<bool>) {
        self.unpacked_bool = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unpacked_bool(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.unpacked_bool
    }

    // Take field
    pub fn take_unpacked_bool(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.unpacked_bool, ::std::vec::Vec::new())
    }

    pub fn get_unpacked_bool(&self) -> &[bool] {
        &self.unpacked_bool
    }

    // repeated .protobuf_unittest.ForeignEnum unpacked_enum = 103;

    pub fn clear_unpacked_enum(&mut self) {
        self.unpacked_enum.clear();
    }

    // Param is passed by value, moved
    pub fn set_unpacked_enum(&mut self, v: ::std::vec::Vec<ForeignEnum>) {
        self.unpacked_enum = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unpacked_enum(&mut self) -> &mut ::std::vec::Vec<ForeignEnum> {
        &mut self.unpacked_enum
    }

    // Take field
    pub fn take_unpacked_enum(&mut self) -> ::std::vec::Vec<ForeignEnum> {
        ::std::mem::replace(&mut self.unpacked_enum, ::std::vec::Vec::new())
    }

    pub fn get_unpacked_enum(&self) -> &[ForeignEnum] {
        &self.unpacked_enum
    }
}

impl ::protobuf::Message for TestUnpackedTypes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                90 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.unpacked_int32)?;
                },
                91 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.unpacked_int64)?;
                },
                92 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.unpacked_uint32)?;
                },
                93 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.unpacked_uint64)?;
                },
                94 => {
                    ::protobuf::rt::read_repeated_sint32_into(wire_type, is, &mut self.unpacked_sint32)?;
                },
                95 => {
                    ::protobuf::rt::read_repeated_sint64_into(wire_type, is, &mut self.unpacked_sint64)?;
                },
                96 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.unpacked_fixed32)?;
                },
                97 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.unpacked_fixed64)?;
                },
                98 => {
                    ::protobuf::rt::read_repeated_sfixed32_into(wire_type, is, &mut self.unpacked_sfixed32)?;
                },
                99 => {
                    ::protobuf::rt::read_repeated_sfixed64_into(wire_type, is, &mut self.unpacked_sfixed64)?;
                },
                100 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.unpacked_float)?;
                },
                101 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.unpacked_double)?;
                },
                102 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.unpacked_bool)?;
                },
                103 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.unpacked_enum, 103, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.unpacked_int32 {
            my_size += ::protobuf::rt::value_size(90, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.unpacked_int64 {
            my_size += ::protobuf::rt::value_size(91, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.unpacked_uint32 {
            my_size += ::protobuf::rt::value_size(92, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.unpacked_uint64 {
            my_size += ::protobuf::rt::value_size(93, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.unpacked_sint32 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(94, *value);
        };
        for value in &self.unpacked_sint64 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(95, *value);
        };
        my_size += 6 * self.unpacked_fixed32.len() as u32;
        my_size += 10 * self.unpacked_fixed64.len() as u32;
        my_size += 6 * self.unpacked_sfixed32.len() as u32;
        my_size += 10 * self.unpacked_sfixed64.len() as u32;
        my_size += 6 * self.unpacked_float.len() as u32;
        my_size += 10 * self.unpacked_double.len() as u32;
        my_size += 3 * self.unpacked_bool.len() as u32;
        for value in &self.unpacked_enum {
            my_size += ::protobuf::rt::enum_size(103, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.unpacked_int32 {
            os.write_int32(90, *v)?;
        };
        for v in &self.unpacked_int64 {
            os.write_int64(91, *v)?;
        };
        for v in &self.unpacked_uint32 {
            os.write_uint32(92, *v)?;
        };
        for v in &self.unpacked_uint64 {
            os.write_uint64(93, *v)?;
        };
        for v in &self.unpacked_sint32 {
            os.write_sint32(94, *v)?;
        };
        for v in &self.unpacked_sint64 {
            os.write_sint64(95, *v)?;
        };
        for v in &self.unpacked_fixed32 {
            os.write_fixed32(96, *v)?;
        };
        for v in &self.unpacked_fixed64 {
            os.write_fixed64(97, *v)?;
        };
        for v in &self.unpacked_sfixed32 {
            os.write_sfixed32(98, *v)?;
        };
        for v in &self.unpacked_sfixed64 {
            os.write_sfixed64(99, *v)?;
        };
        for v in &self.unpacked_float {
            os.write_float(100, *v)?;
        };
        for v in &self.unpacked_double {
            os.write_double(101, *v)?;
        };
        for v in &self.unpacked_bool {
            os.write_bool(102, *v)?;
        };
        for v in &self.unpacked_enum {
            os.write_enum(103, v.value())?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestUnpackedTypes {
        TestUnpackedTypes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "unpacked_int32",
                    |m: &TestUnpackedTypes| { &m.unpacked_int32 },
                    |m: &mut TestUnpackedTypes| { &mut m.unpacked_int32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "unpacked_int64",
                    |m: &TestUnpackedTypes| { &m.unpacked_int64 },
                    |m: &mut TestUnpackedTypes| { &mut m.unpacked_int64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "unpacked_uint32",
                    |m: &TestUnpackedTypes| { &m.unpacked_uint32 },
                    |m: &mut TestUnpackedTypes| { &mut m.unpacked_uint32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "unpacked_uint64",
                    |m: &TestUnpackedTypes| { &m.unpacked_uint64 },
                    |m: &mut TestUnpackedTypes| { &mut m.unpacked_uint64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "unpacked_sint32",
                    |m: &TestUnpackedTypes| { &m.unpacked_sint32 },
                    |m: &mut TestUnpackedTypes| { &mut m.unpacked_sint32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                    "unpacked_sint64",
                    |m: &TestUnpackedTypes| { &m.unpacked_sint64 },
                    |m: &mut TestUnpackedTypes| { &mut m.unpacked_sint64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "unpacked_fixed32",
                    |m: &TestUnpackedTypes| { &m.unpacked_fixed32 },
                    |m: &mut TestUnpackedTypes| { &mut m.unpacked_fixed32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "unpacked_fixed64",
                    |m: &TestUnpackedTypes| { &m.unpacked_fixed64 },
                    |m: &mut TestUnpackedTypes| { &mut m.unpacked_fixed64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSfixed32>(
                    "unpacked_sfixed32",
                    |m: &TestUnpackedTypes| { &m.unpacked_sfixed32 },
                    |m: &mut TestUnpackedTypes| { &mut m.unpacked_sfixed32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSfixed64>(
                    "unpacked_sfixed64",
                    |m: &TestUnpackedTypes| { &m.unpacked_sfixed64 },
                    |m: &mut TestUnpackedTypes| { &mut m.unpacked_sfixed64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "unpacked_float",
                    |m: &TestUnpackedTypes| { &m.unpacked_float },
                    |m: &mut TestUnpackedTypes| { &mut m.unpacked_float },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "unpacked_double",
                    |m: &TestUnpackedTypes| { &m.unpacked_double },
                    |m: &mut TestUnpackedTypes| { &mut m.unpacked_double },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "unpacked_bool",
                    |m: &TestUnpackedTypes| { &m.unpacked_bool },
                    |m: &mut TestUnpackedTypes| { &mut m.unpacked_bool },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ForeignEnum>>(
                    "unpacked_enum",
                    |m: &TestUnpackedTypes| { &m.unpacked_enum },
                    |m: &mut TestUnpackedTypes| { &mut m.unpacked_enum },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestUnpackedTypes>(
                    "TestUnpackedTypes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestUnpackedTypes {
        static mut instance: ::protobuf::lazy::Lazy<TestUnpackedTypes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestUnpackedTypes,
        };
        unsafe {
            instance.get(TestUnpackedTypes::new)
        }
    }
}

impl ::protobuf::Clear for TestUnpackedTypes {
    fn clear(&mut self) {
        self.clear_unpacked_int32();
        self.clear_unpacked_int64();
        self.clear_unpacked_uint32();
        self.clear_unpacked_uint64();
        self.clear_unpacked_sint32();
        self.clear_unpacked_sint64();
        self.clear_unpacked_fixed32();
        self.clear_unpacked_fixed64();
        self.clear_unpacked_sfixed32();
        self.clear_unpacked_sfixed64();
        self.clear_unpacked_float();
        self.clear_unpacked_double();
        self.clear_unpacked_bool();
        self.clear_unpacked_enum();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestUnpackedTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestUnpackedTypes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestPackedExtensions {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestPackedExtensions {
    pub fn new() -> TestPackedExtensions {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TestPackedExtensions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestPackedExtensions {
        TestPackedExtensions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<TestPackedExtensions>(
                    "TestPackedExtensions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestPackedExtensions {
        static mut instance: ::protobuf::lazy::Lazy<TestPackedExtensions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestPackedExtensions,
        };
        unsafe {
            instance.get(TestPackedExtensions::new)
        }
    }
}

impl ::protobuf::Clear for TestPackedExtensions {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestPackedExtensions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestPackedExtensions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestUnpackedExtensions {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestUnpackedExtensions {
    pub fn new() -> TestUnpackedExtensions {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TestUnpackedExtensions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestUnpackedExtensions {
        TestUnpackedExtensions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<TestUnpackedExtensions>(
                    "TestUnpackedExtensions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestUnpackedExtensions {
        static mut instance: ::protobuf::lazy::Lazy<TestUnpackedExtensions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestUnpackedExtensions,
        };
        unsafe {
            instance.get(TestUnpackedExtensions::new)
        }
    }
}

impl ::protobuf::Clear for TestUnpackedExtensions {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestUnpackedExtensions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestUnpackedExtensions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestDynamicExtensions {
    // message fields
    scalar_extension: ::std::option::Option<u32>,
    enum_extension: ::std::option::Option<ForeignEnum>,
    dynamic_enum_extension: ::std::option::Option<TestDynamicExtensions_DynamicEnumType>,
    message_extension: ::protobuf::SingularPtrField<ForeignMessage>,
    dynamic_message_extension: ::protobuf::SingularPtrField<TestDynamicExtensions_DynamicMessageType>,
    repeated_extension: ::protobuf::RepeatedField<::std::string::String>,
    packed_extension: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestDynamicExtensions {
    pub fn new() -> TestDynamicExtensions {
        ::std::default::Default::default()
    }

    // optional fixed32 scalar_extension = 2000;

    pub fn clear_scalar_extension(&mut self) {
        self.scalar_extension = ::std::option::Option::None;
    }

    pub fn has_scalar_extension(&self) -> bool {
        self.scalar_extension.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scalar_extension(&mut self, v: u32) {
        self.scalar_extension = ::std::option::Option::Some(v);
    }

    pub fn get_scalar_extension(&self) -> u32 {
        self.scalar_extension.unwrap_or(0)
    }

    // optional .protobuf_unittest.ForeignEnum enum_extension = 2001;

    pub fn clear_enum_extension(&mut self) {
        self.enum_extension = ::std::option::Option::None;
    }

    pub fn has_enum_extension(&self) -> bool {
        self.enum_extension.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enum_extension(&mut self, v: ForeignEnum) {
        self.enum_extension = ::std::option::Option::Some(v);
    }

    pub fn get_enum_extension(&self) -> ForeignEnum {
        self.enum_extension.unwrap_or(ForeignEnum::FOREIGN_FOO)
    }

    // optional .protobuf_unittest.TestDynamicExtensions.DynamicEnumType dynamic_enum_extension = 2002;

    pub fn clear_dynamic_enum_extension(&mut self) {
        self.dynamic_enum_extension = ::std::option::Option::None;
    }

    pub fn has_dynamic_enum_extension(&self) -> bool {
        self.dynamic_enum_extension.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dynamic_enum_extension(&mut self, v: TestDynamicExtensions_DynamicEnumType) {
        self.dynamic_enum_extension = ::std::option::Option::Some(v);
    }

    pub fn get_dynamic_enum_extension(&self) -> TestDynamicExtensions_DynamicEnumType {
        self.dynamic_enum_extension.unwrap_or(TestDynamicExtensions_DynamicEnumType::DYNAMIC_FOO)
    }

    // optional .protobuf_unittest.ForeignMessage message_extension = 2003;

    pub fn clear_message_extension(&mut self) {
        self.message_extension.clear();
    }

    pub fn has_message_extension(&self) -> bool {
        self.message_extension.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_extension(&mut self, v: ForeignMessage) {
        self.message_extension = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_extension(&mut self) -> &mut ForeignMessage {
        if self.message_extension.is_none() {
            self.message_extension.set_default();
        }
        self.message_extension.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_extension(&mut self) -> ForeignMessage {
        self.message_extension.take().unwrap_or_else(|| ForeignMessage::new())
    }

    pub fn get_message_extension(&self) -> &ForeignMessage {
        self.message_extension.as_ref().unwrap_or_else(|| ForeignMessage::default_instance())
    }

    // optional .protobuf_unittest.TestDynamicExtensions.DynamicMessageType dynamic_message_extension = 2004;

    pub fn clear_dynamic_message_extension(&mut self) {
        self.dynamic_message_extension.clear();
    }

    pub fn has_dynamic_message_extension(&self) -> bool {
        self.dynamic_message_extension.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dynamic_message_extension(&mut self, v: TestDynamicExtensions_DynamicMessageType) {
        self.dynamic_message_extension = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dynamic_message_extension(&mut self) -> &mut TestDynamicExtensions_DynamicMessageType {
        if self.dynamic_message_extension.is_none() {
            self.dynamic_message_extension.set_default();
        }
        self.dynamic_message_extension.as_mut().unwrap()
    }

    // Take field
    pub fn take_dynamic_message_extension(&mut self) -> TestDynamicExtensions_DynamicMessageType {
        self.dynamic_message_extension.take().unwrap_or_else(|| TestDynamicExtensions_DynamicMessageType::new())
    }

    pub fn get_dynamic_message_extension(&self) -> &TestDynamicExtensions_DynamicMessageType {
        self.dynamic_message_extension.as_ref().unwrap_or_else(|| TestDynamicExtensions_DynamicMessageType::default_instance())
    }

    // repeated string repeated_extension = 2005;

    pub fn clear_repeated_extension(&mut self) {
        self.repeated_extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_extension(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.repeated_extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_extension(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.repeated_extension
    }

    // Take field
    pub fn take_repeated_extension(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.repeated_extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_repeated_extension(&self) -> &[::std::string::String] {
        &self.repeated_extension
    }

    // repeated sint32 packed_extension = 2006;

    pub fn clear_packed_extension(&mut self) {
        self.packed_extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_packed_extension(&mut self, v: ::std::vec::Vec<i32>) {
        self.packed_extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packed_extension(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.packed_extension
    }

    // Take field
    pub fn take_packed_extension(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.packed_extension, ::std::vec::Vec::new())
    }

    pub fn get_packed_extension(&self) -> &[i32] {
        &self.packed_extension
    }
}

impl ::protobuf::Message for TestDynamicExtensions {
    fn is_initialized(&self) -> bool {
        for v in &self.message_extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dynamic_message_extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2000 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.scalar_extension = ::std::option::Option::Some(tmp);
                },
                2001 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.enum_extension, 2001, &mut self.unknown_fields)?
                },
                2002 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.dynamic_enum_extension, 2002, &mut self.unknown_fields)?
                },
                2003 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message_extension)?;
                },
                2004 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dynamic_message_extension)?;
                },
                2005 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.repeated_extension)?;
                },
                2006 => {
                    ::protobuf::rt::read_repeated_sint32_into(wire_type, is, &mut self.packed_extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.scalar_extension {
            my_size += 6;
        }
        if let Some(v) = self.enum_extension {
            my_size += ::protobuf::rt::enum_size(2001, v);
        }
        if let Some(v) = self.dynamic_enum_extension {
            my_size += ::protobuf::rt::enum_size(2002, v);
        }
        if let Some(ref v) = self.message_extension.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dynamic_message_extension.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.repeated_extension {
            my_size += ::protobuf::rt::string_size(2005, &value);
        };
        if !self.packed_extension.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(2006, &self.packed_extension);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.scalar_extension {
            os.write_fixed32(2000, v)?;
        }
        if let Some(v) = self.enum_extension {
            os.write_enum(2001, v.value())?;
        }
        if let Some(v) = self.dynamic_enum_extension {
            os.write_enum(2002, v.value())?;
        }
        if let Some(ref v) = self.message_extension.as_ref() {
            os.write_tag(2003, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dynamic_message_extension.as_ref() {
            os.write_tag(2004, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.repeated_extension {
            os.write_string(2005, &v)?;
        };
        if !self.packed_extension.is_empty() {
            os.write_tag(2006, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(&self.packed_extension))?;
            for v in &self.packed_extension {
                os.write_sint32_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestDynamicExtensions {
        TestDynamicExtensions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "scalar_extension",
                    |m: &TestDynamicExtensions| { &m.scalar_extension },
                    |m: &mut TestDynamicExtensions| { &mut m.scalar_extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ForeignEnum>>(
                    "enum_extension",
                    |m: &TestDynamicExtensions| { &m.enum_extension },
                    |m: &mut TestDynamicExtensions| { &mut m.enum_extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TestDynamicExtensions_DynamicEnumType>>(
                    "dynamic_enum_extension",
                    |m: &TestDynamicExtensions| { &m.dynamic_enum_extension },
                    |m: &mut TestDynamicExtensions| { &mut m.dynamic_enum_extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ForeignMessage>>(
                    "message_extension",
                    |m: &TestDynamicExtensions| { &m.message_extension },
                    |m: &mut TestDynamicExtensions| { &mut m.message_extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestDynamicExtensions_DynamicMessageType>>(
                    "dynamic_message_extension",
                    |m: &TestDynamicExtensions| { &m.dynamic_message_extension },
                    |m: &mut TestDynamicExtensions| { &mut m.dynamic_message_extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "repeated_extension",
                    |m: &TestDynamicExtensions| { &m.repeated_extension },
                    |m: &mut TestDynamicExtensions| { &mut m.repeated_extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "packed_extension",
                    |m: &TestDynamicExtensions| { &m.packed_extension },
                    |m: &mut TestDynamicExtensions| { &mut m.packed_extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestDynamicExtensions>(
                    "TestDynamicExtensions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestDynamicExtensions {
        static mut instance: ::protobuf::lazy::Lazy<TestDynamicExtensions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestDynamicExtensions,
        };
        unsafe {
            instance.get(TestDynamicExtensions::new)
        }
    }
}

impl ::protobuf::Clear for TestDynamicExtensions {
    fn clear(&mut self) {
        self.clear_scalar_extension();
        self.clear_enum_extension();
        self.clear_dynamic_enum_extension();
        self.clear_message_extension();
        self.clear_dynamic_message_extension();
        self.clear_repeated_extension();
        self.clear_packed_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestDynamicExtensions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestDynamicExtensions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestDynamicExtensions_DynamicMessageType {
    // message fields
    dynamic_field: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestDynamicExtensions_DynamicMessageType {
    pub fn new() -> TestDynamicExtensions_DynamicMessageType {
        ::std::default::Default::default()
    }

    // optional int32 dynamic_field = 2100;

    pub fn clear_dynamic_field(&mut self) {
        self.dynamic_field = ::std::option::Option::None;
    }

    pub fn has_dynamic_field(&self) -> bool {
        self.dynamic_field.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dynamic_field(&mut self, v: i32) {
        self.dynamic_field = ::std::option::Option::Some(v);
    }

    pub fn get_dynamic_field(&self) -> i32 {
        self.dynamic_field.unwrap_or(0)
    }
}

impl ::protobuf::Message for TestDynamicExtensions_DynamicMessageType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2100 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dynamic_field = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dynamic_field {
            my_size += ::protobuf::rt::value_size(2100, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dynamic_field {
            os.write_int32(2100, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestDynamicExtensions_DynamicMessageType {
        TestDynamicExtensions_DynamicMessageType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dynamic_field",
                    |m: &TestDynamicExtensions_DynamicMessageType| { &m.dynamic_field },
                    |m: &mut TestDynamicExtensions_DynamicMessageType| { &mut m.dynamic_field },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestDynamicExtensions_DynamicMessageType>(
                    "TestDynamicExtensions_DynamicMessageType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestDynamicExtensions_DynamicMessageType {
        static mut instance: ::protobuf::lazy::Lazy<TestDynamicExtensions_DynamicMessageType> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestDynamicExtensions_DynamicMessageType,
        };
        unsafe {
            instance.get(TestDynamicExtensions_DynamicMessageType::new)
        }
    }
}

impl ::protobuf::Clear for TestDynamicExtensions_DynamicMessageType {
    fn clear(&mut self) {
        self.clear_dynamic_field();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestDynamicExtensions_DynamicMessageType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestDynamicExtensions_DynamicMessageType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TestDynamicExtensions_DynamicEnumType {
    DYNAMIC_FOO = 2200,
    DYNAMIC_BAR = 2201,
    DYNAMIC_BAZ = 2202,
}

impl ::protobuf::ProtobufEnum for TestDynamicExtensions_DynamicEnumType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TestDynamicExtensions_DynamicEnumType> {
        match value {
            2200 => ::std::option::Option::Some(TestDynamicExtensions_DynamicEnumType::DYNAMIC_FOO),
            2201 => ::std::option::Option::Some(TestDynamicExtensions_DynamicEnumType::DYNAMIC_BAR),
            2202 => ::std::option::Option::Some(TestDynamicExtensions_DynamicEnumType::DYNAMIC_BAZ),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TestDynamicExtensions_DynamicEnumType] = &[
            TestDynamicExtensions_DynamicEnumType::DYNAMIC_FOO,
            TestDynamicExtensions_DynamicEnumType::DYNAMIC_BAR,
            TestDynamicExtensions_DynamicEnumType::DYNAMIC_BAZ,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TestDynamicExtensions_DynamicEnumType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TestDynamicExtensions_DynamicEnumType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TestDynamicExtensions_DynamicEnumType {
    fn default() -> Self {
        TestDynamicExtensions_DynamicEnumType::DYNAMIC_FOO
    }
}

impl ::protobuf::reflect::ProtobufValue for TestDynamicExtensions_DynamicEnumType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestRepeatedScalarDifferentTagSizes {
    // message fields
    repeated_fixed32: ::std::vec::Vec<u32>,
    repeated_int32: ::std::vec::Vec<i32>,
    repeated_fixed64: ::std::vec::Vec<u64>,
    repeated_int64: ::std::vec::Vec<i64>,
    repeated_float: ::std::vec::Vec<f32>,
    repeated_uint64: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestRepeatedScalarDifferentTagSizes {
    pub fn new() -> TestRepeatedScalarDifferentTagSizes {
        ::std::default::Default::default()
    }

    // repeated fixed32 repeated_fixed32 = 12;

    pub fn clear_repeated_fixed32(&mut self) {
        self.repeated_fixed32.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_fixed32(&mut self, v: ::std::vec::Vec<u32>) {
        self.repeated_fixed32 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_fixed32(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.repeated_fixed32
    }

    // Take field
    pub fn take_repeated_fixed32(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.repeated_fixed32, ::std::vec::Vec::new())
    }

    pub fn get_repeated_fixed32(&self) -> &[u32] {
        &self.repeated_fixed32
    }

    // repeated int32 repeated_int32 = 13;

    pub fn clear_repeated_int32(&mut self) {
        self.repeated_int32.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_int32(&mut self, v: ::std::vec::Vec<i32>) {
        self.repeated_int32 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_int32(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.repeated_int32
    }

    // Take field
    pub fn take_repeated_int32(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.repeated_int32, ::std::vec::Vec::new())
    }

    pub fn get_repeated_int32(&self) -> &[i32] {
        &self.repeated_int32
    }

    // repeated fixed64 repeated_fixed64 = 2046;

    pub fn clear_repeated_fixed64(&mut self) {
        self.repeated_fixed64.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_fixed64(&mut self, v: ::std::vec::Vec<u64>) {
        self.repeated_fixed64 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_fixed64(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.repeated_fixed64
    }

    // Take field
    pub fn take_repeated_fixed64(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.repeated_fixed64, ::std::vec::Vec::new())
    }

    pub fn get_repeated_fixed64(&self) -> &[u64] {
        &self.repeated_fixed64
    }

    // repeated int64 repeated_int64 = 2047;

    pub fn clear_repeated_int64(&mut self) {
        self.repeated_int64.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_int64(&mut self, v: ::std::vec::Vec<i64>) {
        self.repeated_int64 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_int64(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.repeated_int64
    }

    // Take field
    pub fn take_repeated_int64(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.repeated_int64, ::std::vec::Vec::new())
    }

    pub fn get_repeated_int64(&self) -> &[i64] {
        &self.repeated_int64
    }

    // repeated float repeated_float = 262142;

    pub fn clear_repeated_float(&mut self) {
        self.repeated_float.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_float(&mut self, v: ::std::vec::Vec<f32>) {
        self.repeated_float = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_float(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.repeated_float
    }

    // Take field
    pub fn take_repeated_float(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.repeated_float, ::std::vec::Vec::new())
    }

    pub fn get_repeated_float(&self) -> &[f32] {
        &self.repeated_float
    }

    // repeated uint64 repeated_uint64 = 262143;

    pub fn clear_repeated_uint64(&mut self) {
        self.repeated_uint64.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_uint64(&mut self, v: ::std::vec::Vec<u64>) {
        self.repeated_uint64 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_uint64(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.repeated_uint64
    }

    // Take field
    pub fn take_repeated_uint64(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.repeated_uint64, ::std::vec::Vec::new())
    }

    pub fn get_repeated_uint64(&self) -> &[u64] {
        &self.repeated_uint64
    }
}

impl ::protobuf::Message for TestRepeatedScalarDifferentTagSizes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                12 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.repeated_fixed32)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.repeated_int32)?;
                },
                2046 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.repeated_fixed64)?;
                },
                2047 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.repeated_int64)?;
                },
                262142 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.repeated_float)?;
                },
                262143 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.repeated_uint64)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 5 * self.repeated_fixed32.len() as u32;
        for value in &self.repeated_int32 {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += 10 * self.repeated_fixed64.len() as u32;
        for value in &self.repeated_int64 {
            my_size += ::protobuf::rt::value_size(2047, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += 7 * self.repeated_float.len() as u32;
        for value in &self.repeated_uint64 {
            my_size += ::protobuf::rt::value_size(262143, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.repeated_fixed32 {
            os.write_fixed32(12, *v)?;
        };
        for v in &self.repeated_int32 {
            os.write_int32(13, *v)?;
        };
        for v in &self.repeated_fixed64 {
            os.write_fixed64(2046, *v)?;
        };
        for v in &self.repeated_int64 {
            os.write_int64(2047, *v)?;
        };
        for v in &self.repeated_float {
            os.write_float(262142, *v)?;
        };
        for v in &self.repeated_uint64 {
            os.write_uint64(262143, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestRepeatedScalarDifferentTagSizes {
        TestRepeatedScalarDifferentTagSizes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "repeated_fixed32",
                    |m: &TestRepeatedScalarDifferentTagSizes| { &m.repeated_fixed32 },
                    |m: &mut TestRepeatedScalarDifferentTagSizes| { &mut m.repeated_fixed32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "repeated_int32",
                    |m: &TestRepeatedScalarDifferentTagSizes| { &m.repeated_int32 },
                    |m: &mut TestRepeatedScalarDifferentTagSizes| { &mut m.repeated_int32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "repeated_fixed64",
                    |m: &TestRepeatedScalarDifferentTagSizes| { &m.repeated_fixed64 },
                    |m: &mut TestRepeatedScalarDifferentTagSizes| { &mut m.repeated_fixed64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "repeated_int64",
                    |m: &TestRepeatedScalarDifferentTagSizes| { &m.repeated_int64 },
                    |m: &mut TestRepeatedScalarDifferentTagSizes| { &mut m.repeated_int64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "repeated_float",
                    |m: &TestRepeatedScalarDifferentTagSizes| { &m.repeated_float },
                    |m: &mut TestRepeatedScalarDifferentTagSizes| { &mut m.repeated_float },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "repeated_uint64",
                    |m: &TestRepeatedScalarDifferentTagSizes| { &m.repeated_uint64 },
                    |m: &mut TestRepeatedScalarDifferentTagSizes| { &mut m.repeated_uint64 },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestRepeatedScalarDifferentTagSizes>(
                    "TestRepeatedScalarDifferentTagSizes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestRepeatedScalarDifferentTagSizes {
        static mut instance: ::protobuf::lazy::Lazy<TestRepeatedScalarDifferentTagSizes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestRepeatedScalarDifferentTagSizes,
        };
        unsafe {
            instance.get(TestRepeatedScalarDifferentTagSizes::new)
        }
    }
}

impl ::protobuf::Clear for TestRepeatedScalarDifferentTagSizes {
    fn clear(&mut self) {
        self.clear_repeated_fixed32();
        self.clear_repeated_int32();
        self.clear_repeated_fixed64();
        self.clear_repeated_int64();
        self.clear_repeated_float();
        self.clear_repeated_uint64();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestRepeatedScalarDifferentTagSizes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestRepeatedScalarDifferentTagSizes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestParsingMerge {
    // message fields
    required_all_types: ::protobuf::SingularPtrField<TestAllTypes>,
    optional_all_types: ::protobuf::SingularPtrField<TestAllTypes>,
    repeated_all_types: ::protobuf::RepeatedField<TestAllTypes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestParsingMerge {
    pub fn new() -> TestParsingMerge {
        ::std::default::Default::default()
    }

    // required .protobuf_unittest.TestAllTypes required_all_types = 1;

    pub fn clear_required_all_types(&mut self) {
        self.required_all_types.clear();
    }

    pub fn has_required_all_types(&self) -> bool {
        self.required_all_types.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_all_types(&mut self, v: TestAllTypes) {
        self.required_all_types = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_required_all_types(&mut self) -> &mut TestAllTypes {
        if self.required_all_types.is_none() {
            self.required_all_types.set_default();
        }
        self.required_all_types.as_mut().unwrap()
    }

    // Take field
    pub fn take_required_all_types(&mut self) -> TestAllTypes {
        self.required_all_types.take().unwrap_or_else(|| TestAllTypes::new())
    }

    pub fn get_required_all_types(&self) -> &TestAllTypes {
        self.required_all_types.as_ref().unwrap_or_else(|| TestAllTypes::default_instance())
    }

    // optional .protobuf_unittest.TestAllTypes optional_all_types = 2;

    pub fn clear_optional_all_types(&mut self) {
        self.optional_all_types.clear();
    }

    pub fn has_optional_all_types(&self) -> bool {
        self.optional_all_types.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional_all_types(&mut self, v: TestAllTypes) {
        self.optional_all_types = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_optional_all_types(&mut self) -> &mut TestAllTypes {
        if self.optional_all_types.is_none() {
            self.optional_all_types.set_default();
        }
        self.optional_all_types.as_mut().unwrap()
    }

    // Take field
    pub fn take_optional_all_types(&mut self) -> TestAllTypes {
        self.optional_all_types.take().unwrap_or_else(|| TestAllTypes::new())
    }

    pub fn get_optional_all_types(&self) -> &TestAllTypes {
        self.optional_all_types.as_ref().unwrap_or_else(|| TestAllTypes::default_instance())
    }

    // repeated .protobuf_unittest.TestAllTypes repeated_all_types = 3;

    pub fn clear_repeated_all_types(&mut self) {
        self.repeated_all_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_repeated_all_types(&mut self, v: ::protobuf::RepeatedField<TestAllTypes>) {
        self.repeated_all_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repeated_all_types(&mut self) -> &mut ::protobuf::RepeatedField<TestAllTypes> {
        &mut self.repeated_all_types
    }

    // Take field
    pub fn take_repeated_all_types(&mut self) -> ::protobuf::RepeatedField<TestAllTypes> {
        ::std::mem::replace(&mut self.repeated_all_types, ::protobuf::RepeatedField::new())
    }

    pub fn get_repeated_all_types(&self) -> &[TestAllTypes] {
        &self.repeated_all_types
    }
}

impl ::protobuf::Message for TestParsingMerge {
    fn is_initialized(&self) -> bool {
        if self.required_all_types.is_none() {
            return false;
        }
        for v in &self.required_all_types {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.optional_all_types {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.repeated_all_types {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.required_all_types)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.optional_all_types)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.repeated_all_types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.required_all_types.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.optional_all_types.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.repeated_all_types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.required_all_types.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.optional_all_types.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.repeated_all_types {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestParsingMerge {
        TestParsingMerge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestAllTypes>>(
                    "required_all_types",
                    |m: &TestParsingMerge| { &m.required_all_types },
                    |m: &mut TestParsingMerge| { &mut m.required_all_types },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestAllTypes>>(
                    "optional_all_types",
                    |m: &TestParsingMerge| { &m.optional_all_types },
                    |m: &mut TestParsingMerge| { &mut m.optional_all_types },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestAllTypes>>(
                    "repeated_all_types",
                    |m: &TestParsingMerge| { &m.repeated_all_types },
                    |m: &mut TestParsingMerge| { &mut m.repeated_all_types },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestParsingMerge>(
                    "TestParsingMerge",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestParsingMerge {
        static mut instance: ::protobuf::lazy::Lazy<TestParsingMerge> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestParsingMerge,
        };
        unsafe {
            instance.get(TestParsingMerge::new)
        }
    }
}

impl ::protobuf::Clear for TestParsingMerge {
    fn clear(&mut self) {
        self.clear_required_all_types();
        self.clear_optional_all_types();
        self.clear_repeated_all_types();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestParsingMerge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestParsingMerge {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestParsingMerge_RepeatedFieldsGenerator {
    // message fields
    field1: ::protobuf::RepeatedField<TestAllTypes>,
    field2: ::protobuf::RepeatedField<TestAllTypes>,
    field3: ::protobuf::RepeatedField<TestAllTypes>,
    ext1: ::protobuf::RepeatedField<TestAllTypes>,
    ext2: ::protobuf::RepeatedField<TestAllTypes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestParsingMerge_RepeatedFieldsGenerator {
    pub fn new() -> TestParsingMerge_RepeatedFieldsGenerator {
        ::std::default::Default::default()
    }

    // repeated .protobuf_unittest.TestAllTypes field1 = 1;

    pub fn clear_field1(&mut self) {
        self.field1.clear();
    }

    // Param is passed by value, moved
    pub fn set_field1(&mut self, v: ::protobuf::RepeatedField<TestAllTypes>) {
        self.field1 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_field1(&mut self) -> &mut ::protobuf::RepeatedField<TestAllTypes> {
        &mut self.field1
    }

    // Take field
    pub fn take_field1(&mut self) -> ::protobuf::RepeatedField<TestAllTypes> {
        ::std::mem::replace(&mut self.field1, ::protobuf::RepeatedField::new())
    }

    pub fn get_field1(&self) -> &[TestAllTypes] {
        &self.field1
    }

    // repeated .protobuf_unittest.TestAllTypes field2 = 2;

    pub fn clear_field2(&mut self) {
        self.field2.clear();
    }

    // Param is passed by value, moved
    pub fn set_field2(&mut self, v: ::protobuf::RepeatedField<TestAllTypes>) {
        self.field2 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_field2(&mut self) -> &mut ::protobuf::RepeatedField<TestAllTypes> {
        &mut self.field2
    }

    // Take field
    pub fn take_field2(&mut self) -> ::protobuf::RepeatedField<TestAllTypes> {
        ::std::mem::replace(&mut self.field2, ::protobuf::RepeatedField::new())
    }

    pub fn get_field2(&self) -> &[TestAllTypes] {
        &self.field2
    }

    // repeated .protobuf_unittest.TestAllTypes field3 = 3;

    pub fn clear_field3(&mut self) {
        self.field3.clear();
    }

    // Param is passed by value, moved
    pub fn set_field3(&mut self, v: ::protobuf::RepeatedField<TestAllTypes>) {
        self.field3 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_field3(&mut self) -> &mut ::protobuf::RepeatedField<TestAllTypes> {
        &mut self.field3
    }

    // Take field
    pub fn take_field3(&mut self) -> ::protobuf::RepeatedField<TestAllTypes> {
        ::std::mem::replace(&mut self.field3, ::protobuf::RepeatedField::new())
    }

    pub fn get_field3(&self) -> &[TestAllTypes] {
        &self.field3
    }

    // repeated .protobuf_unittest.TestAllTypes ext1 = 1000;

    pub fn clear_ext1(&mut self) {
        self.ext1.clear();
    }

    // Param is passed by value, moved
    pub fn set_ext1(&mut self, v: ::protobuf::RepeatedField<TestAllTypes>) {
        self.ext1 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ext1(&mut self) -> &mut ::protobuf::RepeatedField<TestAllTypes> {
        &mut self.ext1
    }

    // Take field
    pub fn take_ext1(&mut self) -> ::protobuf::RepeatedField<TestAllTypes> {
        ::std::mem::replace(&mut self.ext1, ::protobuf::RepeatedField::new())
    }

    pub fn get_ext1(&self) -> &[TestAllTypes] {
        &self.ext1
    }

    // repeated .protobuf_unittest.TestAllTypes ext2 = 1001;

    pub fn clear_ext2(&mut self) {
        self.ext2.clear();
    }

    // Param is passed by value, moved
    pub fn set_ext2(&mut self, v: ::protobuf::RepeatedField<TestAllTypes>) {
        self.ext2 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ext2(&mut self) -> &mut ::protobuf::RepeatedField<TestAllTypes> {
        &mut self.ext2
    }

    // Take field
    pub fn take_ext2(&mut self) -> ::protobuf::RepeatedField<TestAllTypes> {
        ::std::mem::replace(&mut self.ext2, ::protobuf::RepeatedField::new())
    }

    pub fn get_ext2(&self) -> &[TestAllTypes] {
        &self.ext2
    }
}

impl ::protobuf::Message for TestParsingMerge_RepeatedFieldsGenerator {
    fn is_initialized(&self) -> bool {
        for v in &self.field1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field3 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ext1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ext2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.field1)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.field2)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.field3)?;
                },
                1000 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ext1)?;
                },
                1001 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ext2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.field1 {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.field2 {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.field3 {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ext1 {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ext2 {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.field1 {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.field2 {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.field3 {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ext1 {
            os.write_tag(1000, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ext2 {
            os.write_tag(1001, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestParsingMerge_RepeatedFieldsGenerator {
        TestParsingMerge_RepeatedFieldsGenerator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestAllTypes>>(
                    "field1",
                    |m: &TestParsingMerge_RepeatedFieldsGenerator| { &m.field1 },
                    |m: &mut TestParsingMerge_RepeatedFieldsGenerator| { &mut m.field1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestAllTypes>>(
                    "field2",
                    |m: &TestParsingMerge_RepeatedFieldsGenerator| { &m.field2 },
                    |m: &mut TestParsingMerge_RepeatedFieldsGenerator| { &mut m.field2 },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestAllTypes>>(
                    "field3",
                    |m: &TestParsingMerge_RepeatedFieldsGenerator| { &m.field3 },
                    |m: &mut TestParsingMerge_RepeatedFieldsGenerator| { &mut m.field3 },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestAllTypes>>(
                    "ext1",
                    |m: &TestParsingMerge_RepeatedFieldsGenerator| { &m.ext1 },
                    |m: &mut TestParsingMerge_RepeatedFieldsGenerator| { &mut m.ext1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestAllTypes>>(
                    "ext2",
                    |m: &TestParsingMerge_RepeatedFieldsGenerator| { &m.ext2 },
                    |m: &mut TestParsingMerge_RepeatedFieldsGenerator| { &mut m.ext2 },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestParsingMerge_RepeatedFieldsGenerator>(
                    "TestParsingMerge_RepeatedFieldsGenerator",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestParsingMerge_RepeatedFieldsGenerator {
        static mut instance: ::protobuf::lazy::Lazy<TestParsingMerge_RepeatedFieldsGenerator> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestParsingMerge_RepeatedFieldsGenerator,
        };
        unsafe {
            instance.get(TestParsingMerge_RepeatedFieldsGenerator::new)
        }
    }
}

impl ::protobuf::Clear for TestParsingMerge_RepeatedFieldsGenerator {
    fn clear(&mut self) {
        self.clear_field1();
        self.clear_field2();
        self.clear_field3();
        self.clear_ext1();
        self.clear_ext2();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestParsingMerge_RepeatedFieldsGenerator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestParsingMerge_RepeatedFieldsGenerator {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestCommentInjectionMessage {
    // message fields
    a: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestCommentInjectionMessage {
    pub fn new() -> TestCommentInjectionMessage {
        ::std::default::Default::default()
    }

    // optional string a = 1;

    pub fn clear_a(&mut self) {
        self.a.clear();
    }

    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_a(&mut self, v: ::std::string::String) {
        self.a = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_a(&mut self) -> &mut ::std::string::String {
        if self.a.is_none() {
            self.a.set_default();
        }
        self.a.as_mut().unwrap()
    }

    // Take field
    pub fn take_a(&mut self) -> ::std::string::String {
        self.a.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_a(&self) -> &str {
        match self.a.as_ref() {
            Some(v) => &v,
            None => "*/ <- Neither should this.",
        }
    }
}

impl ::protobuf::Message for TestCommentInjectionMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.a)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.a.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.a.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestCommentInjectionMessage {
        TestCommentInjectionMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "a",
                    |m: &TestCommentInjectionMessage| { &m.a },
                    |m: &mut TestCommentInjectionMessage| { &mut m.a },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestCommentInjectionMessage>(
                    "TestCommentInjectionMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestCommentInjectionMessage {
        static mut instance: ::protobuf::lazy::Lazy<TestCommentInjectionMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestCommentInjectionMessage,
        };
        unsafe {
            instance.get(TestCommentInjectionMessage::new)
        }
    }
}

impl ::protobuf::Clear for TestCommentInjectionMessage {
    fn clear(&mut self) {
        self.clear_a();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestCommentInjectionMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestCommentInjectionMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FooRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FooRequest {
    pub fn new() -> FooRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FooRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FooRequest {
        FooRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<FooRequest>(
                    "FooRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FooRequest {
        static mut instance: ::protobuf::lazy::Lazy<FooRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FooRequest,
        };
        unsafe {
            instance.get(FooRequest::new)
        }
    }
}

impl ::protobuf::Clear for FooRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FooRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FooRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FooResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FooResponse {
    pub fn new() -> FooResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FooResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FooResponse {
        FooResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<FooResponse>(
                    "FooResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FooResponse {
        static mut instance: ::protobuf::lazy::Lazy<FooResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FooResponse,
        };
        unsafe {
            instance.get(FooResponse::new)
        }
    }
}

impl ::protobuf::Clear for FooResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FooResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FooResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FooClientMessage {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FooClientMessage {
    pub fn new() -> FooClientMessage {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FooClientMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FooClientMessage {
        FooClientMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<FooClientMessage>(
                    "FooClientMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FooClientMessage {
        static mut instance: ::protobuf::lazy::Lazy<FooClientMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FooClientMessage,
        };
        unsafe {
            instance.get(FooClientMessage::new)
        }
    }
}

impl ::protobuf::Clear for FooClientMessage {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FooClientMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FooClientMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FooServerMessage {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FooServerMessage {
    pub fn new() -> FooServerMessage {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FooServerMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FooServerMessage {
        FooServerMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<FooServerMessage>(
                    "FooServerMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FooServerMessage {
        static mut instance: ::protobuf::lazy::Lazy<FooServerMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FooServerMessage,
        };
        unsafe {
            instance.get(FooServerMessage::new)
        }
    }
}

impl ::protobuf::Clear for FooServerMessage {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FooServerMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FooServerMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BarRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl BarRequest {
    pub fn new() -> BarRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for BarRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BarRequest {
        BarRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<BarRequest>(
                    "BarRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BarRequest {
        static mut instance: ::protobuf::lazy::Lazy<BarRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BarRequest,
        };
        unsafe {
            instance.get(BarRequest::new)
        }
    }
}

impl ::protobuf::Clear for BarRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BarRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BarRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BarResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl BarResponse {
    pub fn new() -> BarResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for BarResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> & dyn ::std::any::Any {
        self as & dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BarResponse {
        BarResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<BarResponse>(
                    "BarResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BarResponse {
        static mut instance: ::protobuf::lazy::Lazy<BarResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BarResponse,
        };
        unsafe {
            instance.get(BarResponse::new)
        }
    }
}

impl ::protobuf::Clear for BarResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BarResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BarResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ForeignEnum {
    FOREIGN_FOO = 4,
    FOREIGN_BAR = 5,
    FOREIGN_BAZ = 6,
}

impl ::protobuf::ProtobufEnum for ForeignEnum {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ForeignEnum> {
        match value {
            4 => ::std::option::Option::Some(ForeignEnum::FOREIGN_FOO),
            5 => ::std::option::Option::Some(ForeignEnum::FOREIGN_BAR),
            6 => ::std::option::Option::Some(ForeignEnum::FOREIGN_BAZ),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ForeignEnum] = &[
            ForeignEnum::FOREIGN_FOO,
            ForeignEnum::FOREIGN_BAR,
            ForeignEnum::FOREIGN_BAZ,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ForeignEnum", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ForeignEnum {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ForeignEnum {
    fn default() -> Self {
        ForeignEnum::FOREIGN_FOO
    }
}

impl ::protobuf::reflect::ProtobufValue for ForeignEnum {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

// Note: you cannot use pattern matching for enums with allow_alias option
#[derive(Clone,Eq,Debug)]
pub enum TestEnumWithDupValue {
    FOO1, // 1
    BAR1, // 2
    BAZ, // 3
    FOO2, // 1
    BAR2, // 2
}

impl ::std::cmp::PartialEq for TestEnumWithDupValue {
    fn eq(&self, other: &Self) -> bool {
        self.value() == other.value()
    }
}

impl ::std::hash::Hash for TestEnumWithDupValue {
    fn hash<H : ::std::hash::Hasher>(&self, state: &mut H) {
        state.write_i32(self.value())
    }
}

impl ::protobuf::ProtobufEnum for TestEnumWithDupValue {
    fn value(&self) -> i32 {
        match *self {
            TestEnumWithDupValue::FOO1 => 1,
            TestEnumWithDupValue::BAR1 => 2,
            TestEnumWithDupValue::BAZ => 3,
            TestEnumWithDupValue::FOO2 => 1,
            TestEnumWithDupValue::BAR2 => 2,
        }
    }

    fn from_i32(value: i32) -> ::std::option::Option<TestEnumWithDupValue> {
        match value {
            1 => ::std::option::Option::Some(TestEnumWithDupValue::FOO1),
            2 => ::std::option::Option::Some(TestEnumWithDupValue::BAR1),
            3 => ::std::option::Option::Some(TestEnumWithDupValue::BAZ),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TestEnumWithDupValue] = &[
            TestEnumWithDupValue::FOO1,
            TestEnumWithDupValue::BAR1,
            TestEnumWithDupValue::BAZ,
            TestEnumWithDupValue::FOO2,
            TestEnumWithDupValue::BAR2,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TestEnumWithDupValue", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TestEnumWithDupValue {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TestEnumWithDupValue {
    fn default() -> Self {
        TestEnumWithDupValue::FOO1
    }
}

impl ::protobuf::reflect::ProtobufValue for TestEnumWithDupValue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TestSparseEnum {
    SPARSE_A = 123,
    SPARSE_B = 62374,
    SPARSE_C = 12589234,
    SPARSE_D = -15,
    SPARSE_E = -53452,
    SPARSE_F = 0,
    SPARSE_G = 2,
}

impl ::protobuf::ProtobufEnum for TestSparseEnum {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TestSparseEnum> {
        match value {
            123 => ::std::option::Option::Some(TestSparseEnum::SPARSE_A),
            62374 => ::std::option::Option::Some(TestSparseEnum::SPARSE_B),
            12589234 => ::std::option::Option::Some(TestSparseEnum::SPARSE_C),
            -15 => ::std::option::Option::Some(TestSparseEnum::SPARSE_D),
            -53452 => ::std::option::Option::Some(TestSparseEnum::SPARSE_E),
            0 => ::std::option::Option::Some(TestSparseEnum::SPARSE_F),
            2 => ::std::option::Option::Some(TestSparseEnum::SPARSE_G),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TestSparseEnum] = &[
            TestSparseEnum::SPARSE_A,
            TestSparseEnum::SPARSE_B,
            TestSparseEnum::SPARSE_C,
            TestSparseEnum::SPARSE_D,
            TestSparseEnum::SPARSE_E,
            TestSparseEnum::SPARSE_F,
            TestSparseEnum::SPARSE_G,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TestSparseEnum", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TestSparseEnum {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TestSparseEnum {
    fn default() -> Self {
        TestSparseEnum::SPARSE_A
    }
}

impl ::protobuf::reflect::ProtobufValue for TestSparseEnum {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

pub mod exts {
    use protobuf::Message as Message_imported_for_functions;

    pub const optional_int32_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeInt32> = ::protobuf::ext::ExtFieldOptional { field_number: 1, phantom: ::std::marker::PhantomData };

    pub const optional_int64_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeInt64> = ::protobuf::ext::ExtFieldOptional { field_number: 2, phantom: ::std::marker::PhantomData };

    pub const optional_uint32_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeUint32> = ::protobuf::ext::ExtFieldOptional { field_number: 3, phantom: ::std::marker::PhantomData };

    pub const optional_uint64_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeUint64> = ::protobuf::ext::ExtFieldOptional { field_number: 4, phantom: ::std::marker::PhantomData };

    pub const optional_sint32_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeSint32> = ::protobuf::ext::ExtFieldOptional { field_number: 5, phantom: ::std::marker::PhantomData };

    pub const optional_sint64_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeSint64> = ::protobuf::ext::ExtFieldOptional { field_number: 6, phantom: ::std::marker::PhantomData };

    pub const optional_fixed32_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeFixed32> = ::protobuf::ext::ExtFieldOptional { field_number: 7, phantom: ::std::marker::PhantomData };

    pub const optional_fixed64_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeFixed64> = ::protobuf::ext::ExtFieldOptional { field_number: 8, phantom: ::std::marker::PhantomData };

    pub const optional_sfixed32_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeSfixed32> = ::protobuf::ext::ExtFieldOptional { field_number: 9, phantom: ::std::marker::PhantomData };

    pub const optional_sfixed64_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeSfixed64> = ::protobuf::ext::ExtFieldOptional { field_number: 10, phantom: ::std::marker::PhantomData };

    pub const optional_float_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeFloat> = ::protobuf::ext::ExtFieldOptional { field_number: 11, phantom: ::std::marker::PhantomData };

    pub const optional_double_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeDouble> = ::protobuf::ext::ExtFieldOptional { field_number: 12, phantom: ::std::marker::PhantomData };

    pub const optional_bool_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeBool> = ::protobuf::ext::ExtFieldOptional { field_number: 13, phantom: ::std::marker::PhantomData };

    pub const optional_string_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeString> = ::protobuf::ext::ExtFieldOptional { field_number: 14, phantom: ::std::marker::PhantomData };

    pub const optional_bytes_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeBytes> = ::protobuf::ext::ExtFieldOptional { field_number: 15, phantom: ::std::marker::PhantomData };

    pub const optional_nested_message_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeMessage<super::TestAllTypes_NestedMessage>> = ::protobuf::ext::ExtFieldOptional { field_number: 18, phantom: ::std::marker::PhantomData };

    pub const optional_foreign_message_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeMessage<super::ForeignMessage>> = ::protobuf::ext::ExtFieldOptional { field_number: 19, phantom: ::std::marker::PhantomData };

    pub const optional_import_message_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeMessage<super::super::unittest_import::ImportMessage>> = ::protobuf::ext::ExtFieldOptional { field_number: 20, phantom: ::std::marker::PhantomData };

    pub const optional_nested_enum_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeEnum<super::TestAllTypes_NestedEnum>> = ::protobuf::ext::ExtFieldOptional { field_number: 21, phantom: ::std::marker::PhantomData };

    pub const optional_foreign_enum_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeEnum<super::ForeignEnum>> = ::protobuf::ext::ExtFieldOptional { field_number: 22, phantom: ::std::marker::PhantomData };

    pub const optional_import_enum_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeEnum<super::super::unittest_import::ImportEnum>> = ::protobuf::ext::ExtFieldOptional { field_number: 23, phantom: ::std::marker::PhantomData };

    pub const optional_string_piece_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeString> = ::protobuf::ext::ExtFieldOptional { field_number: 24, phantom: ::std::marker::PhantomData };

    pub const optional_cord_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeString> = ::protobuf::ext::ExtFieldOptional { field_number: 25, phantom: ::std::marker::PhantomData };

    pub const optional_public_import_message_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeMessage<super::super::unittest_import_public::PublicImportMessage>> = ::protobuf::ext::ExtFieldOptional { field_number: 26, phantom: ::std::marker::PhantomData };

    pub const optional_lazy_message_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeMessage<super::TestAllTypes_NestedMessage>> = ::protobuf::ext::ExtFieldOptional { field_number: 27, phantom: ::std::marker::PhantomData };

    pub const repeated_int32_extension: ::protobuf::ext::ExtFieldRepeated<super::TestAllExtensions, ::protobuf::types::ProtobufTypeInt32> = ::protobuf::ext::ExtFieldRepeated { field_number: 31, phantom: ::std::marker::PhantomData };

    pub const repeated_int64_extension: ::protobuf::ext::ExtFieldRepeated<super::TestAllExtensions, ::protobuf::types::ProtobufTypeInt64> = ::protobuf::ext::ExtFieldRepeated { field_number: 32, phantom: ::std::marker::PhantomData };

    pub const repeated_uint32_extension: ::protobuf::ext::ExtFieldRepeated<super::TestAllExtensions, ::protobuf::types::ProtobufTypeUint32> = ::protobuf::ext::ExtFieldRepeated { field_number: 33, phantom: ::std::marker::PhantomData };

    pub const repeated_uint64_extension: ::protobuf::ext::ExtFieldRepeated<super::TestAllExtensions, ::protobuf::types::ProtobufTypeUint64> = ::protobuf::ext::ExtFieldRepeated { field_number: 34, phantom: ::std::marker::PhantomData };

    pub const repeated_sint32_extension: ::protobuf::ext::ExtFieldRepeated<super::TestAllExtensions, ::protobuf::types::ProtobufTypeSint32> = ::protobuf::ext::ExtFieldRepeated { field_number: 35, phantom: ::std::marker::PhantomData };

    pub const repeated_sint64_extension: ::protobuf::ext::ExtFieldRepeated<super::TestAllExtensions, ::protobuf::types::ProtobufTypeSint64> = ::protobuf::ext::ExtFieldRepeated { field_number: 36, phantom: ::std::marker::PhantomData };

    pub const repeated_fixed32_extension: ::protobuf::ext::ExtFieldRepeated<super::TestAllExtensions, ::protobuf::types::ProtobufTypeFixed32> = ::protobuf::ext::ExtFieldRepeated { field_number: 37, phantom: ::std::marker::PhantomData };

    pub const repeated_fixed64_extension: ::protobuf::ext::ExtFieldRepeated<super::TestAllExtensions, ::protobuf::types::ProtobufTypeFixed64> = ::protobuf::ext::ExtFieldRepeated { field_number: 38, phantom: ::std::marker::PhantomData };

    pub const repeated_sfixed32_extension: ::protobuf::ext::ExtFieldRepeated<super::TestAllExtensions, ::protobuf::types::ProtobufTypeSfixed32> = ::protobuf::ext::ExtFieldRepeated { field_number: 39, phantom: ::std::marker::PhantomData };

    pub const repeated_sfixed64_extension: ::protobuf::ext::ExtFieldRepeated<super::TestAllExtensions, ::protobuf::types::ProtobufTypeSfixed64> = ::protobuf::ext::ExtFieldRepeated { field_number: 40, phantom: ::std::marker::PhantomData };

    pub const repeated_float_extension: ::protobuf::ext::ExtFieldRepeated<super::TestAllExtensions, ::protobuf::types::ProtobufTypeFloat> = ::protobuf::ext::ExtFieldRepeated { field_number: 41, phantom: ::std::marker::PhantomData };

    pub const repeated_double_extension: ::protobuf::ext::ExtFieldRepeated<super::TestAllExtensions, ::protobuf::types::ProtobufTypeDouble> = ::protobuf::ext::ExtFieldRepeated { field_number: 42, phantom: ::std::marker::PhantomData };

    pub const repeated_bool_extension: ::protobuf::ext::ExtFieldRepeated<super::TestAllExtensions, ::protobuf::types::ProtobufTypeBool> = ::protobuf::ext::ExtFieldRepeated { field_number: 43, phantom: ::std::marker::PhantomData };

    pub const repeated_string_extension: ::protobuf::ext::ExtFieldRepeated<super::TestAllExtensions, ::protobuf::types::ProtobufTypeString> = ::protobuf::ext::ExtFieldRepeated { field_number: 44, phantom: ::std::marker::PhantomData };

    pub const repeated_bytes_extension: ::protobuf::ext::ExtFieldRepeated<super::TestAllExtensions, ::protobuf::types::ProtobufTypeBytes> = ::protobuf::ext::ExtFieldRepeated { field_number: 45, phantom: ::std::marker::PhantomData };

    pub const repeated_nested_message_extension: ::protobuf::ext::ExtFieldRepeated<super::TestAllExtensions, ::protobuf::types::ProtobufTypeMessage<super::TestAllTypes_NestedMessage>> = ::protobuf::ext::ExtFieldRepeated { field_number: 48, phantom: ::std::marker::PhantomData };

    pub const repeated_foreign_message_extension: ::protobuf::ext::ExtFieldRepeated<super::TestAllExtensions, ::protobuf::types::ProtobufTypeMessage<super::ForeignMessage>> = ::protobuf::ext::ExtFieldRepeated { field_number: 49, phantom: ::std::marker::PhantomData };

    pub const repeated_import_message_extension: ::protobuf::ext::ExtFieldRepeated<super::TestAllExtensions, ::protobuf::types::ProtobufTypeMessage<super::super::unittest_import::ImportMessage>> = ::protobuf::ext::ExtFieldRepeated { field_number: 50, phantom: ::std::marker::PhantomData };

    pub const repeated_nested_enum_extension: ::protobuf::ext::ExtFieldRepeated<super::TestAllExtensions, ::protobuf::types::ProtobufTypeEnum<super::TestAllTypes_NestedEnum>> = ::protobuf::ext::ExtFieldRepeated { field_number: 51, phantom: ::std::marker::PhantomData };

    pub const repeated_foreign_enum_extension: ::protobuf::ext::ExtFieldRepeated<super::TestAllExtensions, ::protobuf::types::ProtobufTypeEnum<super::ForeignEnum>> = ::protobuf::ext::ExtFieldRepeated { field_number: 52, phantom: ::std::marker::PhantomData };

    pub const repeated_import_enum_extension: ::protobuf::ext::ExtFieldRepeated<super::TestAllExtensions, ::protobuf::types::ProtobufTypeEnum<super::super::unittest_import::ImportEnum>> = ::protobuf::ext::ExtFieldRepeated { field_number: 53, phantom: ::std::marker::PhantomData };

    pub const repeated_string_piece_extension: ::protobuf::ext::ExtFieldRepeated<super::TestAllExtensions, ::protobuf::types::ProtobufTypeString> = ::protobuf::ext::ExtFieldRepeated { field_number: 54, phantom: ::std::marker::PhantomData };

    pub const repeated_cord_extension: ::protobuf::ext::ExtFieldRepeated<super::TestAllExtensions, ::protobuf::types::ProtobufTypeString> = ::protobuf::ext::ExtFieldRepeated { field_number: 55, phantom: ::std::marker::PhantomData };

    pub const repeated_lazy_message_extension: ::protobuf::ext::ExtFieldRepeated<super::TestAllExtensions, ::protobuf::types::ProtobufTypeMessage<super::TestAllTypes_NestedMessage>> = ::protobuf::ext::ExtFieldRepeated { field_number: 57, phantom: ::std::marker::PhantomData };

    pub const default_int32_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeInt32> = ::protobuf::ext::ExtFieldOptional { field_number: 61, phantom: ::std::marker::PhantomData };

    pub const default_int64_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeInt64> = ::protobuf::ext::ExtFieldOptional { field_number: 62, phantom: ::std::marker::PhantomData };

    pub const default_uint32_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeUint32> = ::protobuf::ext::ExtFieldOptional { field_number: 63, phantom: ::std::marker::PhantomData };

    pub const default_uint64_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeUint64> = ::protobuf::ext::ExtFieldOptional { field_number: 64, phantom: ::std::marker::PhantomData };

    pub const default_sint32_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeSint32> = ::protobuf::ext::ExtFieldOptional { field_number: 65, phantom: ::std::marker::PhantomData };

    pub const default_sint64_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeSint64> = ::protobuf::ext::ExtFieldOptional { field_number: 66, phantom: ::std::marker::PhantomData };

    pub const default_fixed32_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeFixed32> = ::protobuf::ext::ExtFieldOptional { field_number: 67, phantom: ::std::marker::PhantomData };

    pub const default_fixed64_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeFixed64> = ::protobuf::ext::ExtFieldOptional { field_number: 68, phantom: ::std::marker::PhantomData };

    pub const default_sfixed32_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeSfixed32> = ::protobuf::ext::ExtFieldOptional { field_number: 69, phantom: ::std::marker::PhantomData };

    pub const default_sfixed64_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeSfixed64> = ::protobuf::ext::ExtFieldOptional { field_number: 70, phantom: ::std::marker::PhantomData };

    pub const default_float_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeFloat> = ::protobuf::ext::ExtFieldOptional { field_number: 71, phantom: ::std::marker::PhantomData };

    pub const default_double_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeDouble> = ::protobuf::ext::ExtFieldOptional { field_number: 72, phantom: ::std::marker::PhantomData };

    pub const default_bool_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeBool> = ::protobuf::ext::ExtFieldOptional { field_number: 73, phantom: ::std::marker::PhantomData };

    pub const default_string_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeString> = ::protobuf::ext::ExtFieldOptional { field_number: 74, phantom: ::std::marker::PhantomData };

    pub const default_bytes_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeBytes> = ::protobuf::ext::ExtFieldOptional { field_number: 75, phantom: ::std::marker::PhantomData };

    pub const default_nested_enum_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeEnum<super::TestAllTypes_NestedEnum>> = ::protobuf::ext::ExtFieldOptional { field_number: 81, phantom: ::std::marker::PhantomData };

    pub const default_foreign_enum_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeEnum<super::ForeignEnum>> = ::protobuf::ext::ExtFieldOptional { field_number: 82, phantom: ::std::marker::PhantomData };

    pub const default_import_enum_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeEnum<super::super::unittest_import::ImportEnum>> = ::protobuf::ext::ExtFieldOptional { field_number: 83, phantom: ::std::marker::PhantomData };

    pub const default_string_piece_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeString> = ::protobuf::ext::ExtFieldOptional { field_number: 84, phantom: ::std::marker::PhantomData };

    pub const default_cord_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeString> = ::protobuf::ext::ExtFieldOptional { field_number: 85, phantom: ::std::marker::PhantomData };

    pub const oneof_uint32_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeUint32> = ::protobuf::ext::ExtFieldOptional { field_number: 111, phantom: ::std::marker::PhantomData };

    pub const oneof_nested_message_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeMessage<super::TestAllTypes_NestedMessage>> = ::protobuf::ext::ExtFieldOptional { field_number: 112, phantom: ::std::marker::PhantomData };

    pub const oneof_string_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeString> = ::protobuf::ext::ExtFieldOptional { field_number: 113, phantom: ::std::marker::PhantomData };

    pub const oneof_bytes_extension: ::protobuf::ext::ExtFieldOptional<super::TestAllExtensions, ::protobuf::types::ProtobufTypeBytes> = ::protobuf::ext::ExtFieldOptional { field_number: 114, phantom: ::std::marker::PhantomData };

    pub const my_extension_string: ::protobuf::ext::ExtFieldOptional<super::TestFieldOrderings, ::protobuf::types::ProtobufTypeString> = ::protobuf::ext::ExtFieldOptional { field_number: 50, phantom: ::std::marker::PhantomData };

    pub const my_extension_int: ::protobuf::ext::ExtFieldOptional<super::TestFieldOrderings, ::protobuf::types::ProtobufTypeInt32> = ::protobuf::ext::ExtFieldOptional { field_number: 5, phantom: ::std::marker::PhantomData };

    pub const packed_int32_extension: ::protobuf::ext::ExtFieldRepeated<super::TestPackedExtensions, ::protobuf::types::ProtobufTypeInt32> = ::protobuf::ext::ExtFieldRepeated { field_number: 90, phantom: ::std::marker::PhantomData };

    pub const packed_int64_extension: ::protobuf::ext::ExtFieldRepeated<super::TestPackedExtensions, ::protobuf::types::ProtobufTypeInt64> = ::protobuf::ext::ExtFieldRepeated { field_number: 91, phantom: ::std::marker::PhantomData };

    pub const packed_uint32_extension: ::protobuf::ext::ExtFieldRepeated<super::TestPackedExtensions, ::protobuf::types::ProtobufTypeUint32> = ::protobuf::ext::ExtFieldRepeated { field_number: 92, phantom: ::std::marker::PhantomData };

    pub const packed_uint64_extension: ::protobuf::ext::ExtFieldRepeated<super::TestPackedExtensions, ::protobuf::types::ProtobufTypeUint64> = ::protobuf::ext::ExtFieldRepeated { field_number: 93, phantom: ::std::marker::PhantomData };

    pub const packed_sint32_extension: ::protobuf::ext::ExtFieldRepeated<super::TestPackedExtensions, ::protobuf::types::ProtobufTypeSint32> = ::protobuf::ext::ExtFieldRepeated { field_number: 94, phantom: ::std::marker::PhantomData };

    pub const packed_sint64_extension: ::protobuf::ext::ExtFieldRepeated<super::TestPackedExtensions, ::protobuf::types::ProtobufTypeSint64> = ::protobuf::ext::ExtFieldRepeated { field_number: 95, phantom: ::std::marker::PhantomData };

    pub const packed_fixed32_extension: ::protobuf::ext::ExtFieldRepeated<super::TestPackedExtensions, ::protobuf::types::ProtobufTypeFixed32> = ::protobuf::ext::ExtFieldRepeated { field_number: 96, phantom: ::std::marker::PhantomData };

    pub const packed_fixed64_extension: ::protobuf::ext::ExtFieldRepeated<super::TestPackedExtensions, ::protobuf::types::ProtobufTypeFixed64> = ::protobuf::ext::ExtFieldRepeated { field_number: 97, phantom: ::std::marker::PhantomData };

    pub const packed_sfixed32_extension: ::protobuf::ext::ExtFieldRepeated<super::TestPackedExtensions, ::protobuf::types::ProtobufTypeSfixed32> = ::protobuf::ext::ExtFieldRepeated { field_number: 98, phantom: ::std::marker::PhantomData };

    pub const packed_sfixed64_extension: ::protobuf::ext::ExtFieldRepeated<super::TestPackedExtensions, ::protobuf::types::ProtobufTypeSfixed64> = ::protobuf::ext::ExtFieldRepeated { field_number: 99, phantom: ::std::marker::PhantomData };

    pub const packed_float_extension: ::protobuf::ext::ExtFieldRepeated<super::TestPackedExtensions, ::protobuf::types::ProtobufTypeFloat> = ::protobuf::ext::ExtFieldRepeated { field_number: 100, phantom: ::std::marker::PhantomData };

    pub const packed_double_extension: ::protobuf::ext::ExtFieldRepeated<super::TestPackedExtensions, ::protobuf::types::ProtobufTypeDouble> = ::protobuf::ext::ExtFieldRepeated { field_number: 101, phantom: ::std::marker::PhantomData };

    pub const packed_bool_extension: ::protobuf::ext::ExtFieldRepeated<super::TestPackedExtensions, ::protobuf::types::ProtobufTypeBool> = ::protobuf::ext::ExtFieldRepeated { field_number: 102, phantom: ::std::marker::PhantomData };

    pub const packed_enum_extension: ::protobuf::ext::ExtFieldRepeated<super::TestPackedExtensions, ::protobuf::types::ProtobufTypeEnum<super::ForeignEnum>> = ::protobuf::ext::ExtFieldRepeated { field_number: 103, phantom: ::std::marker::PhantomData };

    pub const unpacked_int32_extension: ::protobuf::ext::ExtFieldRepeated<super::TestUnpackedExtensions, ::protobuf::types::ProtobufTypeInt32> = ::protobuf::ext::ExtFieldRepeated { field_number: 90, phantom: ::std::marker::PhantomData };

    pub const unpacked_int64_extension: ::protobuf::ext::ExtFieldRepeated<super::TestUnpackedExtensions, ::protobuf::types::ProtobufTypeInt64> = ::protobuf::ext::ExtFieldRepeated { field_number: 91, phantom: ::std::marker::PhantomData };

    pub const unpacked_uint32_extension: ::protobuf::ext::ExtFieldRepeated<super::TestUnpackedExtensions, ::protobuf::types::ProtobufTypeUint32> = ::protobuf::ext::ExtFieldRepeated { field_number: 92, phantom: ::std::marker::PhantomData };

    pub const unpacked_uint64_extension: ::protobuf::ext::ExtFieldRepeated<super::TestUnpackedExtensions, ::protobuf::types::ProtobufTypeUint64> = ::protobuf::ext::ExtFieldRepeated { field_number: 93, phantom: ::std::marker::PhantomData };

    pub const unpacked_sint32_extension: ::protobuf::ext::ExtFieldRepeated<super::TestUnpackedExtensions, ::protobuf::types::ProtobufTypeSint32> = ::protobuf::ext::ExtFieldRepeated { field_number: 94, phantom: ::std::marker::PhantomData };

    pub const unpacked_sint64_extension: ::protobuf::ext::ExtFieldRepeated<super::TestUnpackedExtensions, ::protobuf::types::ProtobufTypeSint64> = ::protobuf::ext::ExtFieldRepeated { field_number: 95, phantom: ::std::marker::PhantomData };

    pub const unpacked_fixed32_extension: ::protobuf::ext::ExtFieldRepeated<super::TestUnpackedExtensions, ::protobuf::types::ProtobufTypeFixed32> = ::protobuf::ext::ExtFieldRepeated { field_number: 96, phantom: ::std::marker::PhantomData };

    pub const unpacked_fixed64_extension: ::protobuf::ext::ExtFieldRepeated<super::TestUnpackedExtensions, ::protobuf::types::ProtobufTypeFixed64> = ::protobuf::ext::ExtFieldRepeated { field_number: 97, phantom: ::std::marker::PhantomData };

    pub const unpacked_sfixed32_extension: ::protobuf::ext::ExtFieldRepeated<super::TestUnpackedExtensions, ::protobuf::types::ProtobufTypeSfixed32> = ::protobuf::ext::ExtFieldRepeated { field_number: 98, phantom: ::std::marker::PhantomData };

    pub const unpacked_sfixed64_extension: ::protobuf::ext::ExtFieldRepeated<super::TestUnpackedExtensions, ::protobuf::types::ProtobufTypeSfixed64> = ::protobuf::ext::ExtFieldRepeated { field_number: 99, phantom: ::std::marker::PhantomData };

    pub const unpacked_float_extension: ::protobuf::ext::ExtFieldRepeated<super::TestUnpackedExtensions, ::protobuf::types::ProtobufTypeFloat> = ::protobuf::ext::ExtFieldRepeated { field_number: 100, phantom: ::std::marker::PhantomData };

    pub const unpacked_double_extension: ::protobuf::ext::ExtFieldRepeated<super::TestUnpackedExtensions, ::protobuf::types::ProtobufTypeDouble> = ::protobuf::ext::ExtFieldRepeated { field_number: 101, phantom: ::std::marker::PhantomData };

    pub const unpacked_bool_extension: ::protobuf::ext::ExtFieldRepeated<super::TestUnpackedExtensions, ::protobuf::types::ProtobufTypeBool> = ::protobuf::ext::ExtFieldRepeated { field_number: 102, phantom: ::std::marker::PhantomData };

    pub const unpacked_enum_extension: ::protobuf::ext::ExtFieldRepeated<super::TestUnpackedExtensions, ::protobuf::types::ProtobufTypeEnum<super::ForeignEnum>> = ::protobuf::ext::ExtFieldRepeated { field_number: 103, phantom: ::std::marker::PhantomData };
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1egoogle/protobuf/unittest.proto\x12\x11protobuf_unittest\x1a%google\
    /protobuf/unittest_import.proto\"\x96!\n\x0cTestAllTypes\x12%\n\x0eoptio\
    nal_int32\x18\x01\x20\x01(\x05R\roptionalInt32\x12%\n\x0eoptional_int64\
    \x18\x02\x20\x01(\x03R\roptionalInt64\x12'\n\x0foptional_uint32\x18\x03\
    \x20\x01(\rR\x0eoptionalUint32\x12'\n\x0foptional_uint64\x18\x04\x20\x01\
    (\x04R\x0eoptionalUint64\x12'\n\x0foptional_sint32\x18\x05\x20\x01(\x11R\
    \x0eoptionalSint32\x12'\n\x0foptional_sint64\x18\x06\x20\x01(\x12R\x0eop\
    tionalSint64\x12)\n\x10optional_fixed32\x18\x07\x20\x01(\x07R\x0foptiona\
    lFixed32\x12)\n\x10optional_fixed64\x18\x08\x20\x01(\x06R\x0foptionalFix\
    ed64\x12+\n\x11optional_sfixed32\x18\t\x20\x01(\x0fR\x10optionalSfixed32\
    \x12+\n\x11optional_sfixed64\x18\n\x20\x01(\x10R\x10optionalSfixed64\x12\
    %\n\x0eoptional_float\x18\x0b\x20\x01(\x02R\roptionalFloat\x12'\n\x0fopt\
    ional_double\x18\x0c\x20\x01(\x01R\x0eoptionalDouble\x12#\n\roptional_bo\
    ol\x18\r\x20\x01(\x08R\x0coptionalBool\x12'\n\x0foptional_string\x18\x0e\
    \x20\x01(\tR\x0eoptionalString\x12%\n\x0eoptional_bytes\x18\x0f\x20\x01(\
    \x0cR\roptionalBytes\x12e\n\x17optional_nested_message\x18\x12\x20\x01(\
    \x0b2-.protobuf_unittest.TestAllTypes.NestedMessageR\x15optionalNestedMe\
    ssage\x12[\n\x18optional_foreign_message\x18\x13\x20\x01(\x0b2!.protobuf\
    _unittest.ForeignMessageR\x16optionalForeignMessage\x12_\n\x17optional_i\
    mport_message\x18\x14\x20\x01(\x0b2'.protobuf_unittest_import.ImportMess\
    ageR\x15optionalImportMessage\x12\\\n\x14optional_nested_enum\x18\x15\
    \x20\x01(\x0e2*.protobuf_unittest.TestAllTypes.NestedEnumR\x12optionalNe\
    stedEnum\x12R\n\x15optional_foreign_enum\x18\x16\x20\x01(\x0e2\x1e.proto\
    buf_unittest.ForeignEnumR\x13optionalForeignEnum\x12V\n\x14optional_impo\
    rt_enum\x18\x17\x20\x01(\x0e2$.protobuf_unittest_import.ImportEnumR\x12o\
    ptionalImportEnum\x126\n\x15optional_string_piece\x18\x18\x20\x01(\tR\
    \x13optionalStringPieceB\x02\x08\x02\x12'\n\roptional_cord\x18\x19\x20\
    \x01(\tR\x0coptionalCordB\x02\x08\x01\x12r\n\x1eoptional_public_import_m\
    essage\x18\x1a\x20\x01(\x0b2-.protobuf_unittest_import.PublicImportMessa\
    geR\x1boptionalPublicImportMessage\x12e\n\x15optional_lazy_message\x18\
    \x1b\x20\x01(\x0b2-.protobuf_unittest.TestAllTypes.NestedMessageR\x13opt\
    ionalLazyMessageB\x02(\x01\x12%\n\x0erepeated_int32\x18\x1f\x20\x03(\x05\
    R\rrepeatedInt32\x12%\n\x0erepeated_int64\x18\x20\x20\x03(\x03R\rrepeate\
    dInt64\x12'\n\x0frepeated_uint32\x18!\x20\x03(\rR\x0erepeatedUint32\x12'\
    \n\x0frepeated_uint64\x18\"\x20\x03(\x04R\x0erepeatedUint64\x12'\n\x0fre\
    peated_sint32\x18#\x20\x03(\x11R\x0erepeatedSint32\x12'\n\x0frepeated_si\
    nt64\x18$\x20\x03(\x12R\x0erepeatedSint64\x12)\n\x10repeated_fixed32\x18\
    %\x20\x03(\x07R\x0frepeatedFixed32\x12)\n\x10repeated_fixed64\x18&\x20\
    \x03(\x06R\x0frepeatedFixed64\x12+\n\x11repeated_sfixed32\x18'\x20\x03(\
    \x0fR\x10repeatedSfixed32\x12+\n\x11repeated_sfixed64\x18(\x20\x03(\x10R\
    \x10repeatedSfixed64\x12%\n\x0erepeated_float\x18)\x20\x03(\x02R\rrepeat\
    edFloat\x12'\n\x0frepeated_double\x18*\x20\x03(\x01R\x0erepeatedDouble\
    \x12#\n\rrepeated_bool\x18+\x20\x03(\x08R\x0crepeatedBool\x12'\n\x0frepe\
    ated_string\x18,\x20\x03(\tR\x0erepeatedString\x12%\n\x0erepeated_bytes\
    \x18-\x20\x03(\x0cR\rrepeatedBytes\x12e\n\x17repeated_nested_message\x18\
    0\x20\x03(\x0b2-.protobuf_unittest.TestAllTypes.NestedMessageR\x15repeat\
    edNestedMessage\x12[\n\x18repeated_foreign_message\x181\x20\x03(\x0b2!.p\
    rotobuf_unittest.ForeignMessageR\x16repeatedForeignMessage\x12_\n\x17rep\
    eated_import_message\x182\x20\x03(\x0b2'.protobuf_unittest_import.Import\
    MessageR\x15repeatedImportMessage\x12\\\n\x14repeated_nested_enum\x183\
    \x20\x03(\x0e2*.protobuf_unittest.TestAllTypes.NestedEnumR\x12repeatedNe\
    stedEnum\x12R\n\x15repeated_foreign_enum\x184\x20\x03(\x0e2\x1e.protobuf\
    _unittest.ForeignEnumR\x13repeatedForeignEnum\x12V\n\x14repeated_import_\
    enum\x185\x20\x03(\x0e2$.protobuf_unittest_import.ImportEnumR\x12repeate\
    dImportEnum\x126\n\x15repeated_string_piece\x186\x20\x03(\tR\x13repeated\
    StringPieceB\x02\x08\x02\x12'\n\rrepeated_cord\x187\x20\x03(\tR\x0crepea\
    tedCordB\x02\x08\x01\x12e\n\x15repeated_lazy_message\x189\x20\x03(\x0b2-\
    .protobuf_unittest.TestAllTypes.NestedMessageR\x13repeatedLazyMessageB\
    \x02(\x01\x12'\n\rdefault_int32\x18=\x20\x01(\x05:\x0241R\x0cdefaultInt3\
    2\x12'\n\rdefault_int64\x18>\x20\x01(\x03:\x0242R\x0cdefaultInt64\x12)\n\
    \x0edefault_uint32\x18?\x20\x01(\r:\x0243R\rdefaultUint32\x12)\n\x0edefa\
    ult_uint64\x18@\x20\x01(\x04:\x0244R\rdefaultUint64\x12*\n\x0edefault_si\
    nt32\x18A\x20\x01(\x11:\x03-45R\rdefaultSint32\x12)\n\x0edefault_sint64\
    \x18B\x20\x01(\x12:\x0246R\rdefaultSint64\x12+\n\x0fdefault_fixed32\x18C\
    \x20\x01(\x07:\x0247R\x0edefaultFixed32\x12+\n\x0fdefault_fixed64\x18D\
    \x20\x01(\x06:\x0248R\x0edefaultFixed64\x12-\n\x10default_sfixed32\x18E\
    \x20\x01(\x0f:\x0249R\x0fdefaultSfixed32\x12.\n\x10default_sfixed64\x18F\
    \x20\x01(\x10:\x03-50R\x0fdefaultSfixed64\x12)\n\rdefault_float\x18G\x20\
    \x01(\x02:\x0451.5R\x0cdefaultFloat\x12,\n\x0edefault_double\x18H\x20\
    \x01(\x01:\x0552000R\rdefaultDouble\x12'\n\x0cdefault_bool\x18I\x20\x01(\
    \x08:\x04trueR\x0bdefaultBool\x12,\n\x0edefault_string\x18J\x20\x01(\t:\
    \x05helloR\rdefaultString\x12*\n\rdefault_bytes\x18K\x20\x01(\x0c:\x05wo\
    rldR\x0cdefaultBytes\x12_\n\x13default_nested_enum\x18Q\x20\x01(\x0e2*.p\
    rotobuf_unittest.TestAllTypes.NestedEnum:\x03BARR\x11defaultNestedEnum\
    \x12]\n\x14default_foreign_enum\x18R\x20\x01(\x0e2\x1e.protobuf_unittest\
    .ForeignEnum:\x0bFOREIGN_BARR\x12defaultForeignEnum\x12`\n\x13default_im\
    port_enum\x18S\x20\x01(\x0e2$.protobuf_unittest_import.ImportEnum:\nIMPO\
    RT_BARR\x11defaultImportEnum\x129\n\x14default_string_piece\x18T\x20\x01\
    (\t:\x03abcR\x12defaultStringPieceB\x02\x08\x02\x12*\n\x0cdefault_cord\
    \x18U\x20\x01(\t:\x03123R\x0bdefaultCordB\x02\x08\x01\x12#\n\x0coneof_ui\
    nt32\x18o\x20\x01(\rH\0R\x0boneofUint32\x12a\n\x14oneof_nested_message\
    \x18p\x20\x01(\x0b2-.protobuf_unittest.TestAllTypes.NestedMessageH\0R\
    \x12oneofNestedMessage\x12#\n\x0coneof_string\x18q\x20\x01(\tH\0R\x0bone\
    ofString\x12!\n\x0boneof_bytes\x18r\x20\x01(\x0cH\0R\noneofBytes\x1a\x1f\
    \n\rNestedMessage\x12\x0e\n\x02bb\x18\x01\x20\x01(\x05R\x02bb\"9\n\nNest\
    edEnum\x12\x07\n\x03FOO\x10\x01\x12\x07\n\x03BAR\x10\x02\x12\x07\n\x03BA\
    Z\x10\x03\x12\x10\n\x03NEG\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01B\
    \r\n\x0boneof_field\"\xda\x01\n\x12NestedTestAllTypes\x12;\n\x05child\
    \x18\x01\x20\x01(\x0b2%.protobuf_unittest.NestedTestAllTypesR\x05child\
    \x129\n\x07payload\x18\x02\x20\x01(\x0b2\x1f.protobuf_unittest.TestAllTy\
    pesR\x07payload\x12L\n\x0erepeated_child\x18\x03\x20\x03(\x0b2%.protobuf\
    _unittest.NestedTestAllTypesR\rrepeatedChild\"E\n\x14TestDeprecatedField\
    s\x12-\n\x10deprecated_int32\x18\x01\x20\x01(\x05R\x0fdeprecatedInt32B\
    \x02\x18\x01\"\x1e\n\x0eForeignMessage\x12\x0c\n\x01c\x18\x01\x20\x01(\
    \x05R\x01c\"0\n\x12TestReservedFieldsJ\x04\x08\x02\x10\x03J\x04\x08\x0f\
    \x10\x10J\x04\x08\t\x10\x0cR\x03barR\x03baz\"\x1d\n\x11TestAllExtensions\
    *\x08\x08\x01\x10\x80\x80\x80\x80\x02\"\xb5\x01\n\x13TestNestedExtension\
    2?\n\x04test\x18\xea\x07\x20\x01(\t\x12$.protobuf_unittest.TestAllExtens\
    ions:\x04testR\x04test2]\n\x17nested_string_extension\x18\xeb\x07\x20\
    \x01(\t\x12$.protobuf_unittest.TestAllExtensionsR\x15nestedStringExtensi\
    on\"\xf4\x07\n\x0cTestRequired\x12\x0c\n\x01a\x18\x01\x20\x02(\x05R\x01a\
    \x12\x16\n\x06dummy2\x18\x02\x20\x01(\x05R\x06dummy2\x12\x0c\n\x01b\x18\
    \x03\x20\x02(\x05R\x01b\x12\x16\n\x06dummy4\x18\x04\x20\x01(\x05R\x06dum\
    my4\x12\x16\n\x06dummy5\x18\x05\x20\x01(\x05R\x06dummy5\x12\x16\n\x06dum\
    my6\x18\x06\x20\x01(\x05R\x06dummy6\x12\x16\n\x06dummy7\x18\x07\x20\x01(\
    \x05R\x06dummy7\x12\x16\n\x06dummy8\x18\x08\x20\x01(\x05R\x06dummy8\x12\
    \x16\n\x06dummy9\x18\t\x20\x01(\x05R\x06dummy9\x12\x18\n\x07dummy10\x18\
    \n\x20\x01(\x05R\x07dummy10\x12\x18\n\x07dummy11\x18\x0b\x20\x01(\x05R\
    \x07dummy11\x12\x18\n\x07dummy12\x18\x0c\x20\x01(\x05R\x07dummy12\x12\
    \x18\n\x07dummy13\x18\r\x20\x01(\x05R\x07dummy13\x12\x18\n\x07dummy14\
    \x18\x0e\x20\x01(\x05R\x07dummy14\x12\x18\n\x07dummy15\x18\x0f\x20\x01(\
    \x05R\x07dummy15\x12\x18\n\x07dummy16\x18\x10\x20\x01(\x05R\x07dummy16\
    \x12\x18\n\x07dummy17\x18\x11\x20\x01(\x05R\x07dummy17\x12\x18\n\x07dumm\
    y18\x18\x12\x20\x01(\x05R\x07dummy18\x12\x18\n\x07dummy19\x18\x13\x20\
    \x01(\x05R\x07dummy19\x12\x18\n\x07dummy20\x18\x14\x20\x01(\x05R\x07dumm\
    y20\x12\x18\n\x07dummy21\x18\x15\x20\x01(\x05R\x07dummy21\x12\x18\n\x07d\
    ummy22\x18\x16\x20\x01(\x05R\x07dummy22\x12\x18\n\x07dummy23\x18\x17\x20\
    \x01(\x05R\x07dummy23\x12\x18\n\x07dummy24\x18\x18\x20\x01(\x05R\x07dumm\
    y24\x12\x18\n\x07dummy25\x18\x19\x20\x01(\x05R\x07dummy25\x12\x18\n\x07d\
    ummy26\x18\x1a\x20\x01(\x05R\x07dummy26\x12\x18\n\x07dummy27\x18\x1b\x20\
    \x01(\x05R\x07dummy27\x12\x18\n\x07dummy28\x18\x1c\x20\x01(\x05R\x07dumm\
    y28\x12\x18\n\x07dummy29\x18\x1d\x20\x01(\x05R\x07dummy29\x12\x18\n\x07d\
    ummy30\x18\x1e\x20\x01(\x05R\x07dummy30\x12\x18\n\x07dummy31\x18\x1f\x20\
    \x01(\x05R\x07dummy31\x12\x18\n\x07dummy32\x18\x20\x20\x01(\x05R\x07dumm\
    y32\x12\x0c\n\x01c\x18!\x20\x02(\x05R\x01c2^\n\x06single\x18\xe8\x07\x20\
    \x01(\x0b2\x1f.protobuf_unittest.TestRequired\x12$.protobuf_unittest.Tes\
    tAllExtensionsR\x06single2\\\n\x05multi\x18\xe9\x07\x20\x03(\x0b2\x1f.pr\
    otobuf_unittest.TestRequired\x12$.protobuf_unittest.TestAllExtensionsR\
    \x05multi\"\xc3\x01\n\x13TestRequiredForeign\x12J\n\x10optional_message\
    \x18\x01\x20\x01(\x0b2\x1f.protobuf_unittest.TestRequiredR\x0foptionalMe\
    ssage\x12J\n\x10repeated_message\x18\x02\x20\x03(\x0b2\x1f.protobuf_unit\
    test.TestRequiredR\x0frepeatedMessage\x12\x14\n\x05dummy\x18\x03\x20\x01\
    (\x05R\x05dummy\"i\n\x11TestForeignNested\x12T\n\x0eforeign_nested\x18\
    \x01\x20\x01(\x0b2-.protobuf_unittest.TestAllTypes.NestedMessageR\rforei\
    gnNested\"\x12\n\x10TestEmptyMessage\"*\n\x1eTestEmptyMessageWithExtensi\
    ons*\x08\x08\x01\x10\x80\x80\x80\x80\x02\"7\n\x1bTestMultipleExtensionRa\
    nges*\x04\x08*\x10+*\x06\x08\xaf\x20\x10\x94!*\n\x08\x80\x80\x04\x10\x80\
    \x80\x80\x80\x02\";\n\x18TestReallyLargeTagNumber\x12\x0c\n\x01a\x18\x01\
    \x20\x01(\x05R\x01a\x12\x11\n\x02bb\x18\xff\xff\xff\x7f\x20\x01(\x05R\
    \x02bb\"[\n\x14TestRecursiveMessage\x125\n\x01a\x18\x01\x20\x01(\x0b2'.p\
    rotobuf_unittest.TestRecursiveMessageR\x01a\x12\x0c\n\x01i\x18\x02\x20\
    \x01(\x05R\x01i\"O\n\x14TestMutualRecursionA\x127\n\x02bb\x18\x01\x20\
    \x01(\x0b2'.protobuf_unittest.TestMutualRecursionBR\x02bb\"t\n\x14TestMu\
    tualRecursionB\x125\n\x01a\x18\x01\x20\x01(\x0b2'.protobuf_unittest.Test\
    MutualRecursionAR\x01a\x12%\n\x0eoptional_int32\x18\x02\x20\x01(\x05R\ro\
    ptionalInt32\"\"\n\x12TestDupFieldNumber\x12\x0c\n\x01a\x18\x01\x20\x01(\
    \x05R\x01a\"X\n\x10TestEagerMessage\x12D\n\x0bsub_message\x18\x01\x20\
    \x01(\x0b2\x1f.protobuf_unittest.TestAllTypesR\nsubMessageB\x02(\0\"W\n\
    \x0fTestLazyMessage\x12D\n\x0bsub_message\x18\x01\x20\x01(\x0b2\x1f.prot\
    obuf_unittest.TestAllTypesR\nsubMessageB\x02(\x01\"\xd8\x02\n\x18TestNes\
    tedMessageHasBits\x12q\n\x17optional_nested_message\x18\x01\x20\x01(\x0b\
    29.protobuf_unittest.TestNestedMessageHasBits.NestedMessageR\x15optional\
    NestedMessage\x1a\xc8\x01\n\rNestedMessage\x12@\n\x1cnestedmessage_repea\
    ted_int32\x18\x01\x20\x03(\x05R\x1anestedmessageRepeatedInt32\x12u\n%nes\
    tedmessage_repeated_foreignmessage\x18\x02\x20\x03(\x0b2!.protobuf_unitt\
    est.ForeignMessageR#nestedmessageRepeatedForeignmessage\"\xbb\x05\n\x17T\
    estCamelCaseFieldNames\x12&\n\x0ePrimitiveField\x18\x01\x20\x01(\x05R\
    \x0ePrimitiveField\x12\x20\n\x0bStringField\x18\x02\x20\x01(\tR\x0bStrin\
    gField\x12<\n\tEnumField\x18\x03\x20\x01(\x0e2\x1e.protobuf_unittest.For\
    eignEnumR\tEnumField\x12E\n\x0cMessageField\x18\x04\x20\x01(\x0b2!.proto\
    buf_unittest.ForeignMessageR\x0cMessageField\x12.\n\x10StringPieceField\
    \x18\x05\x20\x01(\tR\x10StringPieceFieldB\x02\x08\x02\x12\x20\n\tCordFie\
    ld\x18\x06\x20\x01(\tR\tCordFieldB\x02\x08\x01\x126\n\x16RepeatedPrimiti\
    veField\x18\x07\x20\x03(\x05R\x16RepeatedPrimitiveField\x120\n\x13Repeat\
    edStringField\x18\x08\x20\x03(\tR\x13RepeatedStringField\x12L\n\x11Repea\
    tedEnumField\x18\t\x20\x03(\x0e2\x1e.protobuf_unittest.ForeignEnumR\x11R\
    epeatedEnumField\x12U\n\x14RepeatedMessageField\x18\n\x20\x03(\x0b2!.pro\
    tobuf_unittest.ForeignMessageR\x14RepeatedMessageField\x12>\n\x18Repeate\
    dStringPieceField\x18\x0b\x20\x03(\tR\x18RepeatedStringPieceFieldB\x02\
    \x08\x02\x120\n\x11RepeatedCordField\x18\x0c\x20\x03(\tR\x11RepeatedCord\
    FieldB\x02\x08\x01\"\x8e\x02\n\x12TestFieldOrderings\x12\x1b\n\tmy_strin\
    g\x18\x0b\x20\x01(\tR\x08myString\x12\x15\n\x06my_int\x18\x01\x20\x01(\
    \x03R\x05myInt\x12\x19\n\x08my_float\x18e\x20\x01(\x02R\x07myFloat\x12l\
    \n\x17optional_nested_message\x18\xc8\x01\x20\x01(\x0b23.protobuf_unitte\
    st.TestFieldOrderings.NestedMessageR\x15optionalNestedMessage\x1a/\n\rNe\
    stedMessage\x12\x0e\n\x02oo\x18\x02\x20\x01(\x03R\x02oo\x12\x0e\n\x02bb\
    \x18\x01\x20\x01(\x05R\x02bb*\x04\x08\x02\x10\x0b*\x04\x08\x0c\x10e\"\
    \xfe\x07\n\x18TestExtremeDefaultValues\x12-\n\x0clarge_uint32\x18\x02\
    \x20\x01(\r:\n4294967295R\x0blargeUint32\x127\n\x0clarge_uint64\x18\x03\
    \x20\x01(\x04:\x1418446744073709551615R\x0blargeUint64\x12,\n\x0bsmall_i\
    nt32\x18\x04\x20\x01(\x05:\x0b-2147483647R\nsmallInt32\x125\n\x0bsmall_i\
    nt64\x18\x05\x20\x01(\x03:\x14-9223372036854775807R\nsmallInt64\x129\n\
    \x12really_small_int32\x18\x15\x20\x01(\x05:\x0b-2147483648R\x10reallySm\
    allInt32\x12B\n\x12really_small_int64\x18\x16\x20\x01(\x03:\x14-92233720\
    36854775808R\x10reallySmallInt64\x12$\n\x0butf8_string\x18\x06\x20\x01(\
    \t:\x03\xe1\x88\xb4R\nutf8String\x12\x20\n\nzero_float\x18\x07\x20\x01(\
    \x02:\x010R\tzeroFloat\x12\x1e\n\tone_float\x18\x08\x20\x01(\x02:\x011R\
    \x08oneFloat\x12$\n\x0bsmall_float\x18\t\x20\x01(\x02:\x031.5R\nsmallFlo\
    at\x120\n\x12negative_one_float\x18\n\x20\x01(\x02:\x02-1R\x10negativeOn\
    eFloat\x12+\n\x0enegative_float\x18\x0b\x20\x01(\x02:\x04-1.5R\rnegative\
    Float\x12&\n\x0blarge_float\x18\x0c\x20\x01(\x02:\x052e+08R\nlargeFloat\
    \x128\n\x14small_negative_float\x18\r\x20\x01(\x02:\x06-8e-28R\x12smallN\
    egativeFloat\x128\n\x0ccpp_trigraph\x18\x14\x20\x01(\t:\x15?\x20?\x20??\
    \x20??\x20???\x20??/\x20??-R\x0bcppTrigraph\x120\n\x10string_with_zero\
    \x18\x17\x20\x01(\t:\x06hel\0loR\x0estringWithZero\x121\n\x0fbytes_with_\
    zero\x18\x18\x20\x01(\x0c:\twor\\000ldR\rbytesWithZero\x12=\n\x16string_\
    piece_with_zero\x18\x19\x20\x01(\t:\x04ab\0cR\x13stringPieceWithZeroB\
    \x02\x08\x02\x12.\n\x0ecord_with_zero\x18\x1a\x20\x01(\t:\x0412\03R\x0cc\
    ordWithZeroB\x02\x08\x01\x129\n\x12replacement_string\x18\x1b\x20\x01(\t\
    :\n${unknown}R\x11replacementString\"W\n\x11SparseEnumMessage\x12B\n\x0b\
    sparse_enum\x18\x01\x20\x01(\x0e2!.protobuf_unittest.TestSparseEnumR\nsp\
    arseEnum\"\x1f\n\tOneString\x12\x12\n\x04data\x18\x01\x20\x01(\tR\x04dat\
    a\"\x20\n\nMoreString\x12\x12\n\x04data\x18\x01\x20\x03(\tR\x04data\"\
    \x1e\n\x08OneBytes\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\"\x1f\
    \n\tMoreBytes\x12\x12\n\x04data\x18\x01\x20\x03(\x0cR\x04data\"\"\n\x0cI\
    nt32Message\x12\x12\n\x04data\x18\x01\x20\x01(\x05R\x04data\"#\n\rUint32\
    Message\x12\x12\n\x04data\x18\x01\x20\x01(\rR\x04data\"\"\n\x0cInt64Mess\
    age\x12\x12\n\x04data\x18\x01\x20\x01(\x03R\x04data\"#\n\rUint64Message\
    \x12\x12\n\x04data\x18\x01\x20\x01(\x04R\x04data\"!\n\x0bBoolMessage\x12\
    \x12\n\x04data\x18\x01\x20\x01(\x08R\x04data\"\x92\x01\n\tTestOneof\x12\
    \x19\n\x07foo_int\x18\x01\x20\x01(\x05H\0R\x06fooInt\x12\x1f\n\nfoo_stri\
    ng\x18\x02\x20\x01(\tH\0R\tfooString\x12B\n\x0bfoo_message\x18\x03\x20\
    \x01(\x0b2\x1f.protobuf_unittest.TestAllTypesH\0R\nfooMessageB\x05\n\x03\
    foo\"\x98\x01\n\x1cTestOneofBackwardsCompatible\x12\x17\n\x07foo_int\x18\
    \x01\x20\x01(\x05R\x06fooInt\x12\x1d\n\nfoo_string\x18\x02\x20\x01(\tR\t\
    fooString\x12@\n\x0bfoo_message\x18\x03\x20\x01(\x0b2\x1f.protobuf_unitt\
    est.TestAllTypesR\nfooMessage\"\xd1\x05\n\nTestOneof2\x12\x19\n\x07foo_i\
    nt\x18\x01\x20\x01(\x05H\0R\x06fooInt\x12\x1f\n\nfoo_string\x18\x02\x20\
    \x01(\tH\0R\tfooString\x12\x1f\n\x08foo_cord\x18\x03\x20\x01(\tH\0R\x07f\
    ooCordB\x02\x08\x01\x12.\n\x10foo_string_piece\x18\x04\x20\x01(\tH\0R\
    \x0efooStringPieceB\x02\x08\x02\x12\x1d\n\tfoo_bytes\x18\x05\x20\x01(\
    \x0cH\0R\x08fooBytes\x12E\n\x08foo_enum\x18\x06\x20\x01(\x0e2(.protobuf_\
    unittest.TestOneof2.NestedEnumH\0R\x07fooEnum\x12N\n\x0bfoo_message\x18\
    \x07\x20\x01(\x0b2+.protobuf_unittest.TestOneof2.NestedMessageH\0R\nfooM\
    essage\x12[\n\x10foo_lazy_message\x18\x0b\x20\x01(\x0b2+.protobuf_unitte\
    st.TestOneof2.NestedMessageH\0R\x0efooLazyMessageB\x02(\x01\x12\x1c\n\
    \x07bar_int\x18\x0c\x20\x01(\x05:\x015H\x01R\x06barInt\x12J\n\x08bar_enu\
    m\x18\x11\x20\x01(\x0e2(.protobuf_unittest.TestOneof2.NestedEnum:\x03BAR\
    H\x01R\x07barEnum\x12\x17\n\x07baz_int\x18\x12\x20\x01(\x05R\x06bazInt\
    \x12\"\n\nbaz_string\x18\x13\x20\x01(\t:\x03BAZR\tbazString\x1aE\n\rNest\
    edMessage\x12\x17\n\x07qux_int\x18\x01\x20\x01(\x03R\x06quxInt\x12\x1b\n\
    \tcorge_int\x18\x02\x20\x03(\x05R\x08corgeInt\"'\n\nNestedEnum\x12\x07\n\
    \x03FOO\x10\x01\x12\x07\n\x03BAR\x10\x02\x12\x07\n\x03BAZ\x10\x03B\x05\n\
    \x03fooB\x05\n\x03bar\"\xe7\x01\n\x11TestRequiredOneof\x12\x19\n\x07foo_\
    int\x18\x01\x20\x01(\x05H\0R\x06fooInt\x12\x1f\n\nfoo_string\x18\x02\x20\
    \x01(\tH\0R\tfooString\x12U\n\x0bfoo_message\x18\x03\x20\x01(\x0b22.prot\
    obuf_unittest.TestRequiredOneof.NestedMessageH\0R\nfooMessage\x1a8\n\rNe\
    stedMessage\x12'\n\x0frequired_double\x18\x01\x20\x02(\x01R\x0erequiredD\
    oubleB\x05\n\x03foo\"\xed\x04\n\x0fTestPackedTypes\x12%\n\x0cpacked_int3\
    2\x18Z\x20\x03(\x05R\x0bpackedInt32B\x02\x10\x01\x12%\n\x0cpacked_int64\
    \x18[\x20\x03(\x03R\x0bpackedInt64B\x02\x10\x01\x12'\n\rpacked_uint32\
    \x18\\\x20\x03(\rR\x0cpackedUint32B\x02\x10\x01\x12'\n\rpacked_uint64\
    \x18]\x20\x03(\x04R\x0cpackedUint64B\x02\x10\x01\x12'\n\rpacked_sint32\
    \x18^\x20\x03(\x11R\x0cpackedSint32B\x02\x10\x01\x12'\n\rpacked_sint64\
    \x18_\x20\x03(\x12R\x0cpackedSint64B\x02\x10\x01\x12)\n\x0epacked_fixed3\
    2\x18`\x20\x03(\x07R\rpackedFixed32B\x02\x10\x01\x12)\n\x0epacked_fixed6\
    4\x18a\x20\x03(\x06R\rpackedFixed64B\x02\x10\x01\x12+\n\x0fpacked_sfixed\
    32\x18b\x20\x03(\x0fR\x0epackedSfixed32B\x02\x10\x01\x12+\n\x0fpacked_sf\
    ixed64\x18c\x20\x03(\x10R\x0epackedSfixed64B\x02\x10\x01\x12%\n\x0cpacke\
    d_float\x18d\x20\x03(\x02R\x0bpackedFloatB\x02\x10\x01\x12'\n\rpacked_do\
    uble\x18e\x20\x03(\x01R\x0cpackedDoubleB\x02\x10\x01\x12#\n\x0bpacked_bo\
    ol\x18f\x20\x03(\x08R\npackedBoolB\x02\x10\x01\x12C\n\x0bpacked_enum\x18\
    g\x20\x03(\x0e2\x1e.protobuf_unittest.ForeignEnumR\npackedEnumB\x02\x10\
    \x01\"\xa7\x05\n\x11TestUnpackedTypes\x12)\n\x0eunpacked_int32\x18Z\x20\
    \x03(\x05R\runpackedInt32B\x02\x10\0\x12)\n\x0eunpacked_int64\x18[\x20\
    \x03(\x03R\runpackedInt64B\x02\x10\0\x12+\n\x0funpacked_uint32\x18\\\x20\
    \x03(\rR\x0eunpackedUint32B\x02\x10\0\x12+\n\x0funpacked_uint64\x18]\x20\
    \x03(\x04R\x0eunpackedUint64B\x02\x10\0\x12+\n\x0funpacked_sint32\x18^\
    \x20\x03(\x11R\x0eunpackedSint32B\x02\x10\0\x12+\n\x0funpacked_sint64\
    \x18_\x20\x03(\x12R\x0eunpackedSint64B\x02\x10\0\x12-\n\x10unpacked_fixe\
    d32\x18`\x20\x03(\x07R\x0funpackedFixed32B\x02\x10\0\x12-\n\x10unpacked_\
    fixed64\x18a\x20\x03(\x06R\x0funpackedFixed64B\x02\x10\0\x12/\n\x11unpac\
    ked_sfixed32\x18b\x20\x03(\x0fR\x10unpackedSfixed32B\x02\x10\0\x12/\n\
    \x11unpacked_sfixed64\x18c\x20\x03(\x10R\x10unpackedSfixed64B\x02\x10\0\
    \x12)\n\x0eunpacked_float\x18d\x20\x03(\x02R\runpackedFloatB\x02\x10\0\
    \x12+\n\x0funpacked_double\x18e\x20\x03(\x01R\x0eunpackedDoubleB\x02\x10\
    \0\x12'\n\runpacked_bool\x18f\x20\x03(\x08R\x0cunpackedBoolB\x02\x10\0\
    \x12G\n\runpacked_enum\x18g\x20\x03(\x0e2\x1e.protobuf_unittest.ForeignE\
    numR\x0cunpackedEnumB\x02\x10\0\"\x20\n\x14TestPackedExtensions*\x08\x08\
    \x01\x10\x80\x80\x80\x80\x02\"\"\n\x16TestUnpackedExtensions*\x08\x08\
    \x01\x10\x80\x80\x80\x80\x02\"\xac\x05\n\x15TestDynamicExtensions\x12*\n\
    \x10scalar_extension\x18\xd0\x0f\x20\x01(\x07R\x0fscalarExtension\x12F\n\
    \x0eenum_extension\x18\xd1\x0f\x20\x01(\x0e2\x1e.protobuf_unittest.Forei\
    gnEnumR\renumExtension\x12o\n\x16dynamic_enum_extension\x18\xd2\x0f\x20\
    \x01(\x0e28.protobuf_unittest.TestDynamicExtensions.DynamicEnumTypeR\x14\
    dynamicEnumExtension\x12O\n\x11message_extension\x18\xd3\x0f\x20\x01(\
    \x0b2!.protobuf_unittest.ForeignMessageR\x10messageExtension\x12x\n\x19d\
    ynamic_message_extension\x18\xd4\x0f\x20\x01(\x0b2;.protobuf_unittest.Te\
    stDynamicExtensions.DynamicMessageTypeR\x17dynamicMessageExtension\x12.\
    \n\x12repeated_extension\x18\xd5\x0f\x20\x03(\tR\x11repeatedExtension\
    \x12.\n\x10packed_extension\x18\xd6\x0f\x20\x03(\x11R\x0fpackedExtension\
    B\x02\x10\x01\x1a:\n\x12DynamicMessageType\x12$\n\rdynamic_field\x18\xb4\
    \x10\x20\x01(\x05R\x0cdynamicField\"G\n\x0fDynamicEnumType\x12\x10\n\x0b\
    DYNAMIC_FOO\x10\x98\x11\x12\x10\n\x0bDYNAMIC_BAR\x10\x99\x11\x12\x10\n\
    \x0bDYNAMIC_BAZ\x10\x9a\x11\"\x9f\x02\n#TestRepeatedScalarDifferentTagSi\
    zes\x12)\n\x10repeated_fixed32\x18\x0c\x20\x03(\x07R\x0frepeatedFixed32\
    \x12%\n\x0erepeated_int32\x18\r\x20\x03(\x05R\rrepeatedInt32\x12*\n\x10r\
    epeated_fixed64\x18\xfe\x0f\x20\x03(\x06R\x0frepeatedFixed64\x12&\n\x0er\
    epeated_int64\x18\xff\x0f\x20\x03(\x03R\rrepeatedInt64\x12'\n\x0erepeate\
    d_float\x18\xfe\xff\x0f\x20\x03(\x02R\rrepeatedFloat\x12)\n\x0frepeated_\
    uint64\x18\xff\xff\x0f\x20\x03(\x04R\x0erepeatedUint64\"\x91\x06\n\x10Te\
    stParsingMerge\x12M\n\x12required_all_types\x18\x01\x20\x02(\x0b2\x1f.pr\
    otobuf_unittest.TestAllTypesR\x10requiredAllTypes\x12M\n\x12optional_all\
    _types\x18\x02\x20\x01(\x0b2\x1f.protobuf_unittest.TestAllTypesR\x10opti\
    onalAllTypes\x12M\n\x12repeated_all_types\x18\x03\x20\x03(\x0b2\x1f.prot\
    obuf_unittest.TestAllTypesR\x10repeatedAllTypes2h\n\x0coptional_ext\x18\
    \xe8\x07\x20\x01(\x0b2\x1f.protobuf_unittest.TestAllTypes\x12#.protobuf_\
    unittest.TestParsingMergeR\x0boptionalExt2h\n\x0crepeated_ext\x18\xe9\
    \x07\x20\x03(\x0b2\x1f.protobuf_unittest.TestAllTypes\x12#.protobuf_unit\
    test.TestParsingMergeR\x0brepeatedExt\x1a\xb0\x02\n\x17RepeatedFieldsGen\
    erator\x127\n\x06field1\x18\x01\x20\x03(\x0b2\x1f.protobuf_unittest.Test\
    AllTypesR\x06field1\x127\n\x06field2\x18\x02\x20\x03(\x0b2\x1f.protobuf_\
    unittest.TestAllTypesR\x06field2\x127\n\x06field3\x18\x03\x20\x03(\x0b2\
    \x1f.protobuf_unittest.TestAllTypesR\x06field3\x124\n\x04ext1\x18\xe8\
    \x07\x20\x03(\x0b2\x1f.protobuf_unittest.TestAllTypesR\x04ext1\x124\n\
    \x04ext2\x18\xe9\x07\x20\x03(\x0b2\x1f.protobuf_unittest.TestAllTypesR\
    \x04ext2*\t\x08\xe8\x07\x10\x80\x80\x80\x80\x02\"G\n\x1bTestCommentInjec\
    tionMessage\x12(\n\x01a\x18\x01\x20\x01(\t:\x1a*/\x20<-\x20Neither\x20sh\
    ould\x20this.R\x01a\"\x0c\n\nFooRequest\"\r\n\x0bFooResponse\"\x12\n\x10\
    FooClientMessage\"\x12\n\x10FooServerMessage\"\x0c\n\nBarRequest\"\r\n\
    \x0bBarResponse*@\n\x0bForeignEnum\x12\x0f\n\x0bFOREIGN_FOO\x10\x04\x12\
    \x0f\n\x0bFOREIGN_BAR\x10\x05\x12\x0f\n\x0bFOREIGN_BAZ\x10\x06*K\n\x14Te\
    stEnumWithDupValue\x12\x08\n\x04FOO1\x10\x01\x12\x08\n\x04BAR1\x10\x02\
    \x12\x07\n\x03BAZ\x10\x03\x12\x08\n\x04FOO2\x10\x01\x12\x08\n\x04BAR2\
    \x10\x02\x1a\x02\x10\x01*\x89\x01\n\x0eTestSparseEnum\x12\x0c\n\x08SPARS\
    E_A\x10{\x12\x0e\n\x08SPARSE_B\x10\xa6\xe7\x03\x12\x0f\n\x08SPARSE_C\x10\
    \xb2\xb1\x80\x06\x12\x15\n\x08SPARSE_D\x10\xf1\xff\xff\xff\xff\xff\xff\
    \xff\xff\x01\x12\x15\n\x08SPARSE_E\x10\xb4\xde\xfc\xff\xff\xff\xff\xff\
    \xff\x01\x12\x0c\n\x08SPARSE_F\x10\0\x12\x0c\n\x08SPARSE_G\x10\x022\x99\
    \x01\n\x0bTestService\x12D\n\x03Foo\x12\x1d.protobuf_unittest.FooRequest\
    \x1a\x1e.protobuf_unittest.FooResponse\x12D\n\x03Bar\x12\x1d.protobuf_un\
    ittest.BarRequest\x1a\x1e.protobuf_unittest.BarResponse:^\n\x18optional_\
    int32_extension\x18\x01\x20\x01(\x05\x12$.protobuf_unittest.TestAllExten\
    sionsR\x16optionalInt32Extension:^\n\x18optional_int64_extension\x18\x02\
    \x20\x01(\x03\x12$.protobuf_unittest.TestAllExtensionsR\x16optionalInt64\
    Extension:`\n\x19optional_uint32_extension\x18\x03\x20\x01(\r\x12$.proto\
    buf_unittest.TestAllExtensionsR\x17optionalUint32Extension:`\n\x19option\
    al_uint64_extension\x18\x04\x20\x01(\x04\x12$.protobuf_unittest.TestAllE\
    xtensionsR\x17optionalUint64Extension:`\n\x19optional_sint32_extension\
    \x18\x05\x20\x01(\x11\x12$.protobuf_unittest.TestAllExtensionsR\x17optio\
    nalSint32Extension:`\n\x19optional_sint64_extension\x18\x06\x20\x01(\x12\
    \x12$.protobuf_unittest.TestAllExtensionsR\x17optionalSint64Extension:b\
    \n\x1aoptional_fixed32_extension\x18\x07\x20\x01(\x07\x12$.protobuf_unit\
    test.TestAllExtensionsR\x18optionalFixed32Extension:b\n\x1aoptional_fixe\
    d64_extension\x18\x08\x20\x01(\x06\x12$.protobuf_unittest.TestAllExtensi\
    onsR\x18optionalFixed64Extension:d\n\x1boptional_sfixed32_extension\x18\
    \t\x20\x01(\x0f\x12$.protobuf_unittest.TestAllExtensionsR\x19optionalSfi\
    xed32Extension:d\n\x1boptional_sfixed64_extension\x18\n\x20\x01(\x10\x12\
    $.protobuf_unittest.TestAllExtensionsR\x19optionalSfixed64Extension:^\n\
    \x18optional_float_extension\x18\x0b\x20\x01(\x02\x12$.protobuf_unittest\
    .TestAllExtensionsR\x16optionalFloatExtension:`\n\x19optional_double_ext\
    ension\x18\x0c\x20\x01(\x01\x12$.protobuf_unittest.TestAllExtensionsR\
    \x17optionalDoubleExtension:\\\n\x17optional_bool_extension\x18\r\x20\
    \x01(\x08\x12$.protobuf_unittest.TestAllExtensionsR\x15optionalBoolExten\
    sion:`\n\x19optional_string_extension\x18\x0e\x20\x01(\t\x12$.protobuf_u\
    nittest.TestAllExtensionsR\x17optionalStringExtension:^\n\x18optional_by\
    tes_extension\x18\x0f\x20\x01(\x0c\x12$.protobuf_unittest.TestAllExtensi\
    onsR\x16optionalBytesExtension:\x9e\x01\n!optional_nested_message_extens\
    ion\x18\x12\x20\x01(\x0b2-.protobuf_unittest.TestAllTypes.NestedMessage\
    \x12$.protobuf_unittest.TestAllExtensionsR\x1eoptionalNestedMessageExten\
    sion:\x94\x01\n\"optional_foreign_message_extension\x18\x13\x20\x01(\x0b\
    2!.protobuf_unittest.ForeignMessage\x12$.protobuf_unittest.TestAllExtens\
    ionsR\x1foptionalForeignMessageExtension:\x98\x01\n!optional_import_mess\
    age_extension\x18\x14\x20\x01(\x0b2'.protobuf_unittest_import.ImportMess\
    age\x12$.protobuf_unittest.TestAllExtensionsR\x1eoptionalImportMessageEx\
    tension:\x95\x01\n\x1eoptional_nested_enum_extension\x18\x15\x20\x01(\
    \x0e2*.protobuf_unittest.TestAllTypes.NestedEnum\x12$.protobuf_unittest.\
    TestAllExtensionsR\x1boptionalNestedEnumExtension:\x8b\x01\n\x1foptional\
    _foreign_enum_extension\x18\x16\x20\x01(\x0e2\x1e.protobuf_unittest.Fore\
    ignEnum\x12$.protobuf_unittest.TestAllExtensionsR\x1coptionalForeignEnum\
    Extension:\x8f\x01\n\x1eoptional_import_enum_extension\x18\x17\x20\x01(\
    \x0e2$.protobuf_unittest_import.ImportEnum\x12$.protobuf_unittest.TestAl\
    lExtensionsR\x1boptionalImportEnumExtension:o\n\x1foptional_string_piece\
    _extension\x18\x18\x20\x01(\t\x12$.protobuf_unittest.TestAllExtensionsR\
    \x1coptionalStringPieceExtensionB\x02\x08\x02:`\n\x17optional_cord_exten\
    sion\x18\x19\x20\x01(\t\x12$.protobuf_unittest.TestAllExtensionsR\x15opt\
    ionalCordExtensionB\x02\x08\x01:\xab\x01\n(optional_public_import_messag\
    e_extension\x18\x1a\x20\x01(\x0b2-.protobuf_unittest_import.PublicImport\
    Message\x12$.protobuf_unittest.TestAllExtensionsR$optionalPublicImportMe\
    ssageExtension:\x9e\x01\n\x1foptional_lazy_message_extension\x18\x1b\x20\
    \x01(\x0b2-.protobuf_unittest.TestAllTypes.NestedMessage\x12$.protobuf_u\
    nittest.TestAllExtensionsR\x1coptionalLazyMessageExtensionB\x02(\x01:^\n\
    \x18repeated_int32_extension\x18\x1f\x20\x03(\x05\x12$.protobuf_unittest\
    .TestAllExtensionsR\x16repeatedInt32Extension:^\n\x18repeated_int64_exte\
    nsion\x18\x20\x20\x03(\x03\x12$.protobuf_unittest.TestAllExtensionsR\x16\
    repeatedInt64Extension:`\n\x19repeated_uint32_extension\x18!\x20\x03(\r\
    \x12$.protobuf_unittest.TestAllExtensionsR\x17repeatedUint32Extension:`\
    \n\x19repeated_uint64_extension\x18\"\x20\x03(\x04\x12$.protobuf_unittes\
    t.TestAllExtensionsR\x17repeatedUint64Extension:`\n\x19repeated_sint32_e\
    xtension\x18#\x20\x03(\x11\x12$.protobuf_unittest.TestAllExtensionsR\x17\
    repeatedSint32Extension:`\n\x19repeated_sint64_extension\x18$\x20\x03(\
    \x12\x12$.protobuf_unittest.TestAllExtensionsR\x17repeatedSint64Extensio\
    n:b\n\x1arepeated_fixed32_extension\x18%\x20\x03(\x07\x12$.protobuf_unit\
    test.TestAllExtensionsR\x18repeatedFixed32Extension:b\n\x1arepeated_fixe\
    d64_extension\x18&\x20\x03(\x06\x12$.protobuf_unittest.TestAllExtensions\
    R\x18repeatedFixed64Extension:d\n\x1brepeated_sfixed32_extension\x18'\
    \x20\x03(\x0f\x12$.protobuf_unittest.TestAllExtensionsR\x19repeatedSfixe\
    d32Extension:d\n\x1brepeated_sfixed64_extension\x18(\x20\x03(\x10\x12$.p\
    rotobuf_unittest.TestAllExtensionsR\x19repeatedSfixed64Extension:^\n\x18\
    repeated_float_extension\x18)\x20\x03(\x02\x12$.protobuf_unittest.TestAl\
    lExtensionsR\x16repeatedFloatExtension:`\n\x19repeated_double_extension\
    \x18*\x20\x03(\x01\x12$.protobuf_unittest.TestAllExtensionsR\x17repeated\
    DoubleExtension:\\\n\x17repeated_bool_extension\x18+\x20\x03(\x08\x12$.p\
    rotobuf_unittest.TestAllExtensionsR\x15repeatedBoolExtension:`\n\x19repe\
    ated_string_extension\x18,\x20\x03(\t\x12$.protobuf_unittest.TestAllExte\
    nsionsR\x17repeatedStringExtension:^\n\x18repeated_bytes_extension\x18-\
    \x20\x03(\x0c\x12$.protobuf_unittest.TestAllExtensionsR\x16repeatedBytes\
    Extension:\x9e\x01\n!repeated_nested_message_extension\x180\x20\x03(\x0b\
    2-.protobuf_unittest.TestAllTypes.NestedMessage\x12$.protobuf_unittest.T\
    estAllExtensionsR\x1erepeatedNestedMessageExtension:\x94\x01\n\"repeated\
    _foreign_message_extension\x181\x20\x03(\x0b2!.protobuf_unittest.Foreign\
    Message\x12$.protobuf_unittest.TestAllExtensionsR\x1frepeatedForeignMess\
    ageExtension:\x98\x01\n!repeated_import_message_extension\x182\x20\x03(\
    \x0b2'.protobuf_unittest_import.ImportMessage\x12$.protobuf_unittest.Tes\
    tAllExtensionsR\x1erepeatedImportMessageExtension:\x95\x01\n\x1erepeated\
    _nested_enum_extension\x183\x20\x03(\x0e2*.protobuf_unittest.TestAllType\
    s.NestedEnum\x12$.protobuf_unittest.TestAllExtensionsR\x1brepeatedNested\
    EnumExtension:\x8b\x01\n\x1frepeated_foreign_enum_extension\x184\x20\x03\
    (\x0e2\x1e.protobuf_unittest.ForeignEnum\x12$.protobuf_unittest.TestAllE\
    xtensionsR\x1crepeatedForeignEnumExtension:\x8f\x01\n\x1erepeated_import\
    _enum_extension\x185\x20\x03(\x0e2$.protobuf_unittest_import.ImportEnum\
    \x12$.protobuf_unittest.TestAllExtensionsR\x1brepeatedImportEnumExtensio\
    n:o\n\x1frepeated_string_piece_extension\x186\x20\x03(\t\x12$.protobuf_u\
    nittest.TestAllExtensionsR\x1crepeatedStringPieceExtensionB\x02\x08\x02:\
    `\n\x17repeated_cord_extension\x187\x20\x03(\t\x12$.protobuf_unittest.Te\
    stAllExtensionsR\x15repeatedCordExtensionB\x02\x08\x01:\x9e\x01\n\x1frep\
    eated_lazy_message_extension\x189\x20\x03(\x0b2-.protobuf_unittest.TestA\
    llTypes.NestedMessage\x12$.protobuf_unittest.TestAllExtensionsR\x1crepea\
    tedLazyMessageExtensionB\x02(\x01:`\n\x17default_int32_extension\x18=\
    \x20\x01(\x05\x12$.protobuf_unittest.TestAllExtensions:\x0241R\x15defaul\
    tInt32Extension:`\n\x17default_int64_extension\x18>\x20\x01(\x03\x12$.pr\
    otobuf_unittest.TestAllExtensions:\x0242R\x15defaultInt64Extension:b\n\
    \x18default_uint32_extension\x18?\x20\x01(\r\x12$.protobuf_unittest.Test\
    AllExtensions:\x0243R\x16defaultUint32Extension:b\n\x18default_uint64_ex\
    tension\x18@\x20\x01(\x04\x12$.protobuf_unittest.TestAllExtensions:\x024\
    4R\x16defaultUint64Extension:c\n\x18default_sint32_extension\x18A\x20\
    \x01(\x11\x12$.protobuf_unittest.TestAllExtensions:\x03-45R\x16defaultSi\
    nt32Extension:b\n\x18default_sint64_extension\x18B\x20\x01(\x12\x12$.pro\
    tobuf_unittest.TestAllExtensions:\x0246R\x16defaultSint64Extension:d\n\
    \x19default_fixed32_extension\x18C\x20\x01(\x07\x12$.protobuf_unittest.T\
    estAllExtensions:\x0247R\x17defaultFixed32Extension:d\n\x19default_fixed\
    64_extension\x18D\x20\x01(\x06\x12$.protobuf_unittest.TestAllExtensions:\
    \x0248R\x17defaultFixed64Extension:f\n\x1adefault_sfixed32_extension\x18\
    E\x20\x01(\x0f\x12$.protobuf_unittest.TestAllExtensions:\x0249R\x18defau\
    ltSfixed32Extension:g\n\x1adefault_sfixed64_extension\x18F\x20\x01(\x10\
    \x12$.protobuf_unittest.TestAllExtensions:\x03-50R\x18defaultSfixed64Ext\
    ension:b\n\x17default_float_extension\x18G\x20\x01(\x02\x12$.protobuf_un\
    ittest.TestAllExtensions:\x0451.5R\x15defaultFloatExtension:e\n\x18defau\
    lt_double_extension\x18H\x20\x01(\x01\x12$.protobuf_unittest.TestAllExte\
    nsions:\x0552000R\x16defaultDoubleExtension:`\n\x16default_bool_extensio\
    n\x18I\x20\x01(\x08\x12$.protobuf_unittest.TestAllExtensions:\x04trueR\
    \x14defaultBoolExtension:e\n\x18default_string_extension\x18J\x20\x01(\t\
    \x12$.protobuf_unittest.TestAllExtensions:\x05helloR\x16defaultStringExt\
    ension:c\n\x17default_bytes_extension\x18K\x20\x01(\x0c\x12$.protobuf_un\
    ittest.TestAllExtensions:\x05worldR\x15defaultBytesExtension:\x98\x01\n\
    \x1ddefault_nested_enum_extension\x18Q\x20\x01(\x0e2*.protobuf_unittest.\
    TestAllTypes.NestedEnum\x12$.protobuf_unittest.TestAllExtensions:\x03BAR\
    R\x1adefaultNestedEnumExtension:\x96\x01\n\x1edefault_foreign_enum_exten\
    sion\x18R\x20\x01(\x0e2\x1e.protobuf_unittest.ForeignEnum\x12$.protobuf_\
    unittest.TestAllExtensions:\x0bFOREIGN_BARR\x1bdefaultForeignEnumExtensi\
    on:\x99\x01\n\x1ddefault_import_enum_extension\x18S\x20\x01(\x0e2$.proto\
    buf_unittest_import.ImportEnum\x12$.protobuf_unittest.TestAllExtensions:\
    \nIMPORT_BARR\x1adefaultImportEnumExtension:r\n\x1edefault_string_piece_\
    extension\x18T\x20\x01(\t\x12$.protobuf_unittest.TestAllExtensions:\x03a\
    bcR\x1bdefaultStringPieceExtensionB\x02\x08\x02:c\n\x16default_cord_exte\
    nsion\x18U\x20\x01(\t\x12$.protobuf_unittest.TestAllExtensions:\x03123R\
    \x14defaultCordExtensionB\x02\x08\x01:Z\n\x16oneof_uint32_extension\x18o\
    \x20\x01(\r\x12$.protobuf_unittest.TestAllExtensionsR\x14oneofUint32Exte\
    nsion:\x98\x01\n\x1eoneof_nested_message_extension\x18p\x20\x01(\x0b2-.p\
    rotobuf_unittest.TestAllTypes.NestedMessage\x12$.protobuf_unittest.TestA\
    llExtensionsR\x1boneofNestedMessageExtension:Z\n\x16oneof_string_extensi\
    on\x18q\x20\x01(\t\x12$.protobuf_unittest.TestAllExtensionsR\x14oneofStr\
    ingExtension:X\n\x15oneof_bytes_extension\x18r\x20\x01(\x0c\x12$.protobu\
    f_unittest.TestAllExtensionsR\x13oneofBytesExtension:U\n\x13my_extension\
    _string\x182\x20\x01(\t\x12%.protobuf_unittest.TestFieldOrderingsR\x11my\
    ExtensionString:O\n\x10my_extension_int\x18\x05\x20\x01(\x05\x12%.protob\
    uf_unittest.TestFieldOrderingsR\x0emyExtensionInt:a\n\x16packed_int32_ex\
    tension\x18Z\x20\x03(\x05\x12'.protobuf_unittest.TestPackedExtensionsR\
    \x14packedInt32ExtensionB\x02\x10\x01:a\n\x16packed_int64_extension\x18[\
    \x20\x03(\x03\x12'.protobuf_unittest.TestPackedExtensionsR\x14packedInt6\
    4ExtensionB\x02\x10\x01:c\n\x17packed_uint32_extension\x18\\\x20\x03(\r\
    \x12'.protobuf_unittest.TestPackedExtensionsR\x15packedUint32ExtensionB\
    \x02\x10\x01:c\n\x17packed_uint64_extension\x18]\x20\x03(\x04\x12'.proto\
    buf_unittest.TestPackedExtensionsR\x15packedUint64ExtensionB\x02\x10\x01\
    :c\n\x17packed_sint32_extension\x18^\x20\x03(\x11\x12'.protobuf_unittest\
    .TestPackedExtensionsR\x15packedSint32ExtensionB\x02\x10\x01:c\n\x17pack\
    ed_sint64_extension\x18_\x20\x03(\x12\x12'.protobuf_unittest.TestPackedE\
    xtensionsR\x15packedSint64ExtensionB\x02\x10\x01:e\n\x18packed_fixed32_e\
    xtension\x18`\x20\x03(\x07\x12'.protobuf_unittest.TestPackedExtensionsR\
    \x16packedFixed32ExtensionB\x02\x10\x01:e\n\x18packed_fixed64_extension\
    \x18a\x20\x03(\x06\x12'.protobuf_unittest.TestPackedExtensionsR\x16packe\
    dFixed64ExtensionB\x02\x10\x01:g\n\x19packed_sfixed32_extension\x18b\x20\
    \x03(\x0f\x12'.protobuf_unittest.TestPackedExtensionsR\x17packedSfixed32\
    ExtensionB\x02\x10\x01:g\n\x19packed_sfixed64_extension\x18c\x20\x03(\
    \x10\x12'.protobuf_unittest.TestPackedExtensionsR\x17packedSfixed64Exten\
    sionB\x02\x10\x01:a\n\x16packed_float_extension\x18d\x20\x03(\x02\x12'.p\
    rotobuf_unittest.TestPackedExtensionsR\x14packedFloatExtensionB\x02\x10\
    \x01:c\n\x17packed_double_extension\x18e\x20\x03(\x01\x12'.protobuf_unit\
    test.TestPackedExtensionsR\x15packedDoubleExtensionB\x02\x10\x01:_\n\x15\
    packed_bool_extension\x18f\x20\x03(\x08\x12'.protobuf_unittest.TestPacke\
    dExtensionsR\x13packedBoolExtensionB\x02\x10\x01:\x7f\n\x15packed_enum_e\
    xtension\x18g\x20\x03(\x0e2\x1e.protobuf_unittest.ForeignEnum\x12'.proto\
    buf_unittest.TestPackedExtensionsR\x13packedEnumExtensionB\x02\x10\x01:g\
    \n\x18unpacked_int32_extension\x18Z\x20\x03(\x05\x12).protobuf_unittest.\
    TestUnpackedExtensionsR\x16unpackedInt32ExtensionB\x02\x10\0:g\n\x18unpa\
    cked_int64_extension\x18[\x20\x03(\x03\x12).protobuf_unittest.TestUnpack\
    edExtensionsR\x16unpackedInt64ExtensionB\x02\x10\0:i\n\x19unpacked_uint3\
    2_extension\x18\\\x20\x03(\r\x12).protobuf_unittest.TestUnpackedExtensio\
    nsR\x17unpackedUint32ExtensionB\x02\x10\0:i\n\x19unpacked_uint64_extensi\
    on\x18]\x20\x03(\x04\x12).protobuf_unittest.TestUnpackedExtensionsR\x17u\
    npackedUint64ExtensionB\x02\x10\0:i\n\x19unpacked_sint32_extension\x18^\
    \x20\x03(\x11\x12).protobuf_unittest.TestUnpackedExtensionsR\x17unpacked\
    Sint32ExtensionB\x02\x10\0:i\n\x19unpacked_sint64_extension\x18_\x20\x03\
    (\x12\x12).protobuf_unittest.TestUnpackedExtensionsR\x17unpackedSint64Ex\
    tensionB\x02\x10\0:k\n\x1aunpacked_fixed32_extension\x18`\x20\x03(\x07\
    \x12).protobuf_unittest.TestUnpackedExtensionsR\x18unpackedFixed32Extens\
    ionB\x02\x10\0:k\n\x1aunpacked_fixed64_extension\x18a\x20\x03(\x06\x12).\
    protobuf_unittest.TestUnpackedExtensionsR\x18unpackedFixed64ExtensionB\
    \x02\x10\0:m\n\x1bunpacked_sfixed32_extension\x18b\x20\x03(\x0f\x12).pro\
    tobuf_unittest.TestUnpackedExtensionsR\x19unpackedSfixed32ExtensionB\x02\
    \x10\0:m\n\x1bunpacked_sfixed64_extension\x18c\x20\x03(\x10\x12).protobu\
    f_unittest.TestUnpackedExtensionsR\x19unpackedSfixed64ExtensionB\x02\x10\
    \0:g\n\x18unpacked_float_extension\x18d\x20\x03(\x02\x12).protobuf_unitt\
    est.TestUnpackedExtensionsR\x16unpackedFloatExtensionB\x02\x10\0:i\n\x19\
    unpacked_double_extension\x18e\x20\x03(\x01\x12).protobuf_unittest.TestU\
    npackedExtensionsR\x17unpackedDoubleExtensionB\x02\x10\0:e\n\x17unpacked\
    _bool_extension\x18f\x20\x03(\x08\x12).protobuf_unittest.TestUnpackedExt\
    ensionsR\x15unpackedBoolExtensionB\x02\x10\0:\x85\x01\n\x17unpacked_enum\
    _extension\x18g\x20\x03(\x0e2\x1e.protobuf_unittest.ForeignEnum\x12).pro\
    tobuf_unittest.TestUnpackedExtensionsR\x15unpackedEnumExtensionB\x02\x10\
    \0B\x1dB\rUnittestProtoH\x01\x80\x01\x01\x88\x01\x01\x90\x01\x01\xf8\x01\
    \x01J\xa9\xd5\x02\n\x07\x12\x05$\0\x87\x07\x16\n\xff\r\n\x01\x0c\x12\x03\
    $\0\x122\xc1\x0c\x20Protocol\x20Buffers\x20-\x20Google's\x20data\x20inte\
    rchange\x20format\n\x20Copyright\x202008\x20Google\x20Inc.\x20\x20All\
    \x20rights\x20reserved.\n\x20https://developers.google.com/protocol-buff\
    ers/\n\n\x20Redistribution\x20and\x20use\x20in\x20source\x20and\x20binar\
    y\x20forms,\x20with\x20or\x20without\n\x20modification,\x20are\x20permit\
    ted\x20provided\x20that\x20the\x20following\x20conditions\x20are\n\x20me\
    t:\n\n\x20\x20\x20\x20\x20*\x20Redistributions\x20of\x20source\x20code\
    \x20must\x20retain\x20the\x20above\x20copyright\n\x20notice,\x20this\x20\
    list\x20of\x20conditions\x20and\x20the\x20following\x20disclaimer.\n\x20\
    \x20\x20\x20\x20*\x20Redistributions\x20in\x20binary\x20form\x20must\x20\
    reproduce\x20the\x20above\n\x20copyright\x20notice,\x20this\x20list\x20o\
    f\x20conditions\x20and\x20the\x20following\x20disclaimer\n\x20in\x20the\
    \x20documentation\x20and/or\x20other\x20materials\x20provided\x20with\
    \x20the\n\x20distribution.\n\x20\x20\x20\x20\x20*\x20Neither\x20the\x20n\
    ame\x20of\x20Google\x20Inc.\x20nor\x20the\x20names\x20of\x20its\n\x20con\
    tributors\x20may\x20be\x20used\x20to\x20endorse\x20or\x20promote\x20prod\
    ucts\x20derived\x20from\n\x20this\x20software\x20without\x20specific\x20\
    prior\x20written\x20permission.\n\n\x20THIS\x20SOFTWARE\x20IS\x20PROVIDE\
    D\x20BY\x20THE\x20COPYRIGHT\x20HOLDERS\x20AND\x20CONTRIBUTORS\n\x20\"AS\
    \x20IS\"\x20AND\x20ANY\x20EXPRESS\x20OR\x20IMPLIED\x20WARRANTIES,\x20INC\
    LUDING,\x20BUT\x20NOT\n\x20LIMITED\x20TO,\x20THE\x20IMPLIED\x20WARRANTIE\
    S\x20OF\x20MERCHANTABILITY\x20AND\x20FITNESS\x20FOR\n\x20A\x20PARTICULAR\
    \x20PURPOSE\x20ARE\x20DISCLAIMED.\x20IN\x20NO\x20EVENT\x20SHALL\x20THE\
    \x20COPYRIGHT\n\x20OWNER\x20OR\x20CONTRIBUTORS\x20BE\x20LIABLE\x20FOR\
    \x20ANY\x20DIRECT,\x20INDIRECT,\x20INCIDENTAL,\n\x20SPECIAL,\x20EXEMPLAR\
    Y,\x20OR\x20CONSEQUENTIAL\x20DAMAGES\x20(INCLUDING,\x20BUT\x20NOT\n\x20L\
    IMITED\x20TO,\x20PROCUREMENT\x20OF\x20SUBSTITUTE\x20GOODS\x20OR\x20SERVI\
    CES;\x20LOSS\x20OF\x20USE,\n\x20DATA,\x20OR\x20PROFITS;\x20OR\x20BUSINES\
    S\x20INTERRUPTION)\x20HOWEVER\x20CAUSED\x20AND\x20ON\x20ANY\n\x20THEORY\
    \x20OF\x20LIABILITY,\x20WHETHER\x20IN\x20CONTRACT,\x20STRICT\x20LIABILIT\
    Y,\x20OR\x20TORT\n\x20(INCLUDING\x20NEGLIGENCE\x20OR\x20OTHERWISE)\x20AR\
    ISING\x20IN\x20ANY\x20WAY\x20OUT\x20OF\x20THE\x20USE\n\x20OF\x20THIS\x20\
    SOFTWARE,\x20EVEN\x20IF\x20ADVISED\x20OF\x20THE\x20POSSIBILITY\x20OF\x20\
    SUCH\x20DAMAGE.\n2\xb0\x01\x20Author:\x20kenton@google.com\x20(Kenton\
    \x20Varda)\n\x20\x20Based\x20on\x20original\x20Protocol\x20Buffers\x20de\
    sign\x20by\n\x20\x20Sanjay\x20Ghemawat,\x20Jeff\x20Dean,\x20and\x20other\
    s.\n\n\x20A\x20proto\x20file\x20we\x20will\x20use\x20for\x20unit\x20test\
    ing.\n\n\x08\n\x01\x08\x12\x03(\0\"\n\x80\x01\n\x02\x08\x10\x12\x03(\0\"\
    \x1ag\x20Some\x20generic_services\x20option(s)\x20added\x20automatically\
    .\n\x20See:\x20\x20http://go/proto2-generic-services-default\n\"\x0c\x20\
    auto-added\n\n\x08\n\x01\x08\x12\x03)\0$\n\x17\n\x02\x08\x11\x12\x03)\0$\
    \"\x0c\x20auto-added\n\n\x08\n\x01\x08\x12\x03*\0\"\n\x17\n\x02\x08\x12\
    \x12\x03*\0\"\"\x0c\x20auto-added\n\n\x08\n\x01\x08\x12\x03+\0\x1f\n\t\n\
    \x02\x08\x1f\x12\x03+\0\x1f\n\t\n\x02\x03\0\x12\x03-\x07.\n\xe6\x01\n\
    \x01\x02\x12\x032\x08\x19\x1a\xdb\x01\x20We\x20don't\x20put\x20this\x20i\
    n\x20a\x20package\x20within\x20proto2\x20because\x20we\x20need\x20to\x20\
    make\x20sure\n\x20that\x20the\x20generated\x20code\x20doesn't\x20depend\
    \x20on\x20being\x20in\x20the\x20proto2\x20namespace.\n\x20In\x20test_uti\
    l.h\x20we\x20do\x20\"using\x20namespace\x20unittest\x20=\x20protobuf_uni\
    ttest\".\n\n\x08\n\x01\x08\x12\x037\0\x1c\n\xe2\x01\n\x02\x08\t\x12\x037\
    \0\x1c\x1a\xd6\x01\x20Protos\x20optimized\x20for\x20SPEED\x20use\x20a\
    \x20strict\x20superset\x20of\x20the\x20generated\x20code\n\x20of\x20equi\
    valent\x20ones\x20optimized\x20for\x20CODE_SIZE,\x20so\x20we\x20should\
    \x20optimize\x20all\x20our\n\x20tests\x20for\x20speed\x20unless\x20expli\
    citly\x20testing\x20code\x20size\x20optimization.\n\n\x08\n\x01\x08\x12\
    \x039\0.\n\t\n\x02\x08\x08\x12\x039\0.\n\\\n\x02\x04\0\x12\x05=\0\xb8\
    \x01\x01\x1aO\x20This\x20proto\x20includes\x20every\x20type\x20of\x20fie\
    ld\x20in\x20both\x20singular\x20and\x20repeated\n\x20forms.\n\n\n\n\x03\
    \x04\0\x01\x12\x03=\x08\x14\n\x0c\n\x04\x04\0\x03\0\x12\x04>\x02C\x03\n\
    \x0c\n\x05\x04\0\x03\0\x01\x12\x03>\n\x17\n\xe3\x01\n\x06\x04\0\x03\0\
    \x02\0\x12\x03B\x04\x1a\x1a\xd3\x01\x20The\x20field\x20name\x20\"b\"\x20\
    fails\x20to\x20compile\x20in\x20proto1\x20because\x20it\x20conflicts\x20\
    with\n\x20a\x20local\x20variable\x20named\x20\"b\"\x20in\x20one\x20of\
    \x20the\x20generated\x20methods.\x20\x20Doh.\n\x20This\x20file\x20needs\
    \x20to\x20compile\x20in\x20proto1\x20to\x20test\x20backwards-compatibili\
    ty.\n\n\x0e\n\x07\x04\0\x03\0\x02\0\x04\x12\x03B\x04\x0c\n\x0e\n\x07\x04\
    \0\x03\0\x02\0\x05\x12\x03B\r\x12\n\x0e\n\x07\x04\0\x03\0\x02\0\x01\x12\
    \x03B\x13\x15\n\x0e\n\x07\x04\0\x03\0\x02\0\x03\x12\x03B\x18\x19\n\x0c\n\
    \x04\x04\0\x04\0\x12\x04E\x02J\x03\n\x0c\n\x05\x04\0\x04\0\x01\x12\x03E\
    \x07\x11\n\r\n\x06\x04\0\x04\0\x02\0\x12\x03F\x04\x0c\n\x0e\n\x07\x04\0\
    \x04\0\x02\0\x01\x12\x03F\x04\x07\n\x0e\n\x07\x04\0\x04\0\x02\0\x02\x12\
    \x03F\n\x0b\n\r\n\x06\x04\0\x04\0\x02\x01\x12\x03G\x04\x0c\n\x0e\n\x07\
    \x04\0\x04\0\x02\x01\x01\x12\x03G\x04\x07\n\x0e\n\x07\x04\0\x04\0\x02\
    \x01\x02\x12\x03G\n\x0b\n\r\n\x06\x04\0\x04\0\x02\x02\x12\x03H\x04\x0c\n\
    \x0e\n\x07\x04\0\x04\0\x02\x02\x01\x12\x03H\x04\x07\n\x0e\n\x07\x04\0\
    \x04\0\x02\x02\x02\x12\x03H\n\x0b\n(\n\x06\x04\0\x04\0\x02\x03\x12\x03I\
    \x04\r\"\x19\x20Intentionally\x20negative.\n\n\x0e\n\x07\x04\0\x04\0\x02\
    \x03\x01\x12\x03I\x04\x07\n\x0e\n\x07\x04\0\x04\0\x02\x03\x02\x12\x03I\n\
    \x0c\n\x17\n\x04\x04\0\x02\0\x12\x03M\x02+\x1a\n\x20Singular\n\n\x0c\n\
    \x05\x04\0\x02\0\x04\x12\x03M\x02\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03M\
    \x0e\x13\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03M\x14\"\n\x0c\n\x05\x04\0\
    \x02\0\x03\x12\x03M)*\n\x0b\n\x04\x04\0\x02\x01\x12\x03N\x02+\n\x0c\n\
    \x05\x04\0\x02\x01\x04\x12\x03N\x02\n\n\x0c\n\x05\x04\0\x02\x01\x05\x12\
    \x03N\x0e\x13\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03N\x14\"\n\x0c\n\x05\
    \x04\0\x02\x01\x03\x12\x03N)*\n\x0b\n\x04\x04\0\x02\x02\x12\x03O\x02+\n\
    \x0c\n\x05\x04\0\x02\x02\x04\x12\x03O\x02\n\n\x0c\n\x05\x04\0\x02\x02\
    \x05\x12\x03O\r\x13\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03O\x14#\n\x0c\n\
    \x05\x04\0\x02\x02\x03\x12\x03O)*\n\x0b\n\x04\x04\0\x02\x03\x12\x03P\x02\
    +\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03P\x02\n\n\x0c\n\x05\x04\0\x02\x03\
    \x05\x12\x03P\r\x13\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03P\x14#\n\x0c\n\
    \x05\x04\0\x02\x03\x03\x12\x03P)*\n\x0b\n\x04\x04\0\x02\x04\x12\x03Q\x02\
    +\n\x0c\n\x05\x04\0\x02\x04\x04\x12\x03Q\x02\n\n\x0c\n\x05\x04\0\x02\x04\
    \x05\x12\x03Q\r\x13\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03Q\x14#\n\x0c\n\
    \x05\x04\0\x02\x04\x03\x12\x03Q)*\n\x0b\n\x04\x04\0\x02\x05\x12\x03R\x02\
    +\n\x0c\n\x05\x04\0\x02\x05\x04\x12\x03R\x02\n\n\x0c\n\x05\x04\0\x02\x05\
    \x05\x12\x03R\r\x13\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03R\x14#\n\x0c\n\
    \x05\x04\0\x02\x05\x03\x12\x03R)*\n\x0b\n\x04\x04\0\x02\x06\x12\x03S\x02\
    +\n\x0c\n\x05\x04\0\x02\x06\x04\x12\x03S\x02\n\n\x0c\n\x05\x04\0\x02\x06\
    \x05\x12\x03S\x0c\x13\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03S\x14$\n\x0c\
    \n\x05\x04\0\x02\x06\x03\x12\x03S)*\n\x0b\n\x04\x04\0\x02\x07\x12\x03T\
    \x02+\n\x0c\n\x05\x04\0\x02\x07\x04\x12\x03T\x02\n\n\x0c\n\x05\x04\0\x02\
    \x07\x05\x12\x03T\x0c\x13\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03T\x14$\n\
    \x0c\n\x05\x04\0\x02\x07\x03\x12\x03T)*\n\x0b\n\x04\x04\0\x02\x08\x12\
    \x03U\x02+\n\x0c\n\x05\x04\0\x02\x08\x04\x12\x03U\x02\n\n\x0c\n\x05\x04\
    \0\x02\x08\x05\x12\x03U\x0b\x13\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03U\
    \x14%\n\x0c\n\x05\x04\0\x02\x08\x03\x12\x03U)*\n\x0b\n\x04\x04\0\x02\t\
    \x12\x03V\x02+\n\x0c\n\x05\x04\0\x02\t\x04\x12\x03V\x02\n\n\x0c\n\x05\
    \x04\0\x02\t\x05\x12\x03V\x0b\x13\n\x0c\n\x05\x04\0\x02\t\x01\x12\x03V\
    \x14%\n\x0c\n\x05\x04\0\x02\t\x03\x12\x03V(*\n\x0b\n\x04\x04\0\x02\n\x12\
    \x03W\x02+\n\x0c\n\x05\x04\0\x02\n\x04\x12\x03W\x02\n\n\x0c\n\x05\x04\0\
    \x02\n\x05\x12\x03W\x0e\x13\n\x0c\n\x05\x04\0\x02\n\x01\x12\x03W\x14\"\n\
    \x0c\n\x05\x04\0\x02\n\x03\x12\x03W(*\n\x0b\n\x04\x04\0\x02\x0b\x12\x03X\
    \x02+\n\x0c\n\x05\x04\0\x02\x0b\x04\x12\x03X\x02\n\n\x0c\n\x05\x04\0\x02\
    \x0b\x05\x12\x03X\r\x13\n\x0c\n\x05\x04\0\x02\x0b\x01\x12\x03X\x14#\n\
    \x0c\n\x05\x04\0\x02\x0b\x03\x12\x03X(*\n\x0b\n\x04\x04\0\x02\x0c\x12\
    \x03Y\x02+\n\x0c\n\x05\x04\0\x02\x0c\x04\x12\x03Y\x02\n\n\x0c\n\x05\x04\
    \0\x02\x0c\x05\x12\x03Y\x0f\x13\n\x0c\n\x05\x04\0\x02\x0c\x01\x12\x03Y\
    \x14!\n\x0c\n\x05\x04\0\x02\x0c\x03\x12\x03Y(*\n\x0b\n\x04\x04\0\x02\r\
    \x12\x03Z\x02+\n\x0c\n\x05\x04\0\x02\r\x04\x12\x03Z\x02\n\n\x0c\n\x05\
    \x04\0\x02\r\x05\x12\x03Z\r\x13\n\x0c\n\x05\x04\0\x02\r\x01\x12\x03Z\x14\
    #\n\x0c\n\x05\x04\0\x02\r\x03\x12\x03Z(*\n\x0b\n\x04\x04\0\x02\x0e\x12\
    \x03[\x02+\n\x0c\n\x05\x04\0\x02\x0e\x04\x12\x03[\x02\n\n\x0c\n\x05\x04\
    \0\x02\x0e\x05\x12\x03[\x0e\x13\n\x0c\n\x05\x04\0\x02\x0e\x01\x12\x03[\
    \x14\"\n\x0c\n\x05\x04\0\x02\x0e\x03\x12\x03[(*\nK\n\x04\x04\0\x02\x0f\
    \x12\x03c\x02N2>\noptional\x20group\x20OptionalGroup\x20=\x2016\x20{\nop\
    tional\x20int32\x20a\x20=\x2017;\n}\n\n\x0c\n\x05\x04\0\x02\x0f\x04\x12\
    \x03c\x02\n\n\x0c\n\x05\x04\0\x02\x0f\x06\x12\x03c\x0b\x18\n\x0c\n\x05\
    \x04\0\x02\x0f\x01\x12\x03c0G\n\x0c\n\x05\x04\0\x02\x0f\x03\x12\x03cKM\n\
    \x0b\n\x04\x04\0\x02\x10\x12\x03d\x02N\n\x0c\n\x05\x04\0\x02\x10\x04\x12\
    \x03d\x02\n\n\x0c\n\x05\x04\0\x02\x10\x06\x12\x03d\x0b\x19\n\x0c\n\x05\
    \x04\0\x02\x10\x01\x12\x03d0H\n\x0c\n\x05\x04\0\x02\x10\x03\x12\x03dKM\n\
    \x0b\n\x04\x04\0\x02\x11\x12\x03e\x02P\n\x0c\n\x05\x04\0\x02\x11\x04\x12\
    \x03e\x02\n\n\x0c\n\x05\x04\0\x02\x11\x06\x12\x03e\x0b1\n\x0c\n\x05\x04\
    \0\x02\x11\x01\x12\x03e2I\n\x0c\n\x05\x04\0\x02\x11\x03\x12\x03eMO\n\x0b\
    \n\x04\x04\0\x02\x12\x12\x03g\x02N\n\x0c\n\x05\x04\0\x02\x12\x04\x12\x03\
    g\x02\n\n\x0c\n\x05\x04\0\x02\x12\x06\x12\x03g\x0b\x15\n\x0c\n\x05\x04\0\
    \x02\x12\x01\x12\x03g0D\n\x0c\n\x05\x04\0\x02\x12\x03\x12\x03gKM\n\x0b\n\
    \x04\x04\0\x02\x13\x12\x03h\x02N\n\x0c\n\x05\x04\0\x02\x13\x04\x12\x03h\
    \x02\n\n\x0c\n\x05\x04\0\x02\x13\x06\x12\x03h\x0b\x16\n\x0c\n\x05\x04\0\
    \x02\x13\x01\x12\x03h0E\n\x0c\n\x05\x04\0\x02\x13\x03\x12\x03hKM\n\x0b\n\
    \x04\x04\0\x02\x14\x12\x03i\x02P\n\x0c\n\x05\x04\0\x02\x14\x04\x12\x03i\
    \x02\n\n\x0c\n\x05\x04\0\x02\x14\x06\x12\x03i\x0b.\n\x0c\n\x05\x04\0\x02\
    \x14\x01\x12\x03i2F\n\x0c\n\x05\x04\0\x02\x14\x03\x12\x03iMO\n\x0b\n\x04\
    \x04\0\x02\x15\x12\x03k\x02B\n\x0c\n\x05\x04\0\x02\x15\x04\x12\x03k\x02\
    \n\n\x0c\n\x05\x04\0\x02\x15\x05\x12\x03k\x0b\x11\n\x0c\n\x05\x04\0\x02\
    \x15\x01\x12\x03k\x12'\n\x0c\n\x05\x04\0\x02\x15\x03\x12\x03k*,\n\x0c\n\
    \x05\x04\0\x02\x15\x08\x12\x03k-A\n\r\n\x06\x04\0\x02\x15\x08\x01\x12\
    \x03k.@\n\x0b\n\x04\x04\0\x02\x16\x12\x03l\x022\n\x0c\n\x05\x04\0\x02\
    \x16\x04\x12\x03l\x02\n\n\x0c\n\x05\x04\0\x02\x16\x05\x12\x03l\x0b\x11\n\
    \x0c\n\x05\x04\0\x02\x16\x01\x12\x03l\x12\x1f\n\x0c\n\x05\x04\0\x02\x16\
    \x03\x12\x03l\"$\n\x0c\n\x05\x04\0\x02\x16\x08\x12\x03l%1\n\r\n\x06\x04\
    \0\x02\x16\x08\x01\x12\x03l&0\n7\n\x04\x04\0\x02\x17\x12\x04o\x02p*\x1a)\
    \x20Defined\x20in\x20unittest_import_public.proto\n\n\x0c\n\x05\x04\0\
    \x02\x17\x04\x12\x03o\x02\n\n\x0c\n\x05\x04\0\x02\x17\x06\x12\x03o\x0b7\
    \n\x0c\n\x05\x04\0\x02\x17\x01\x12\x03p\x06$\n\x0c\n\x05\x04\0\x02\x17\
    \x03\x12\x03p')\n\x0b\n\x04\x04\0\x02\x18\x12\x03r\x02@\n\x0c\n\x05\x04\
    \0\x02\x18\x04\x12\x03r\x02\n\n\x0c\n\x05\x04\0\x02\x18\x06\x12\x03r\x0b\
    \x18\n\x0c\n\x05\x04\0\x02\x18\x01\x12\x03r\x19.\n\x0c\n\x05\x04\0\x02\
    \x18\x03\x12\x03r13\n\x0c\n\x05\x04\0\x02\x18\x08\x12\x03r4?\n\r\n\x06\
    \x04\0\x02\x18\x08\x05\x12\x03r5>\n\x17\n\x04\x04\0\x02\x19\x12\x03u\x02\
    +\x1a\n\x20Repeated\n\n\x0c\n\x05\x04\0\x02\x19\x04\x12\x03u\x02\n\n\x0c\
    \n\x05\x04\0\x02\x19\x05\x12\x03u\x0e\x13\n\x0c\n\x05\x04\0\x02\x19\x01\
    \x12\x03u\x14\"\n\x0c\n\x05\x04\0\x02\x19\x03\x12\x03u(*\n\x0b\n\x04\x04\
    \0\x02\x1a\x12\x03v\x02+\n\x0c\n\x05\x04\0\x02\x1a\x04\x12\x03v\x02\n\n\
    \x0c\n\x05\x04\0\x02\x1a\x05\x12\x03v\x0e\x13\n\x0c\n\x05\x04\0\x02\x1a\
    \x01\x12\x03v\x14\"\n\x0c\n\x05\x04\0\x02\x1a\x03\x12\x03v(*\n\x0b\n\x04\
    \x04\0\x02\x1b\x12\x03w\x02+\n\x0c\n\x05\x04\0\x02\x1b\x04\x12\x03w\x02\
    \n\n\x0c\n\x05\x04\0\x02\x1b\x05\x12\x03w\r\x13\n\x0c\n\x05\x04\0\x02\
    \x1b\x01\x12\x03w\x14#\n\x0c\n\x05\x04\0\x02\x1b\x03\x12\x03w(*\n\x0b\n\
    \x04\x04\0\x02\x1c\x12\x03x\x02+\n\x0c\n\x05\x04\0\x02\x1c\x04\x12\x03x\
    \x02\n\n\x0c\n\x05\x04\0\x02\x1c\x05\x12\x03x\r\x13\n\x0c\n\x05\x04\0\
    \x02\x1c\x01\x12\x03x\x14#\n\x0c\n\x05\x04\0\x02\x1c\x03\x12\x03x(*\n\
    \x0b\n\x04\x04\0\x02\x1d\x12\x03y\x02+\n\x0c\n\x05\x04\0\x02\x1d\x04\x12\
    \x03y\x02\n\n\x0c\n\x05\x04\0\x02\x1d\x05\x12\x03y\r\x13\n\x0c\n\x05\x04\
    \0\x02\x1d\x01\x12\x03y\x14#\n\x0c\n\x05\x04\0\x02\x1d\x03\x12\x03y(*\n\
    \x0b\n\x04\x04\0\x02\x1e\x12\x03z\x02+\n\x0c\n\x05\x04\0\x02\x1e\x04\x12\
    \x03z\x02\n\n\x0c\n\x05\x04\0\x02\x1e\x05\x12\x03z\r\x13\n\x0c\n\x05\x04\
    \0\x02\x1e\x01\x12\x03z\x14#\n\x0c\n\x05\x04\0\x02\x1e\x03\x12\x03z(*\n\
    \x0b\n\x04\x04\0\x02\x1f\x12\x03{\x02+\n\x0c\n\x05\x04\0\x02\x1f\x04\x12\
    \x03{\x02\n\n\x0c\n\x05\x04\0\x02\x1f\x05\x12\x03{\x0c\x13\n\x0c\n\x05\
    \x04\0\x02\x1f\x01\x12\x03{\x14$\n\x0c\n\x05\x04\0\x02\x1f\x03\x12\x03{(\
    *\n\x0b\n\x04\x04\0\x02\x20\x12\x03|\x02+\n\x0c\n\x05\x04\0\x02\x20\x04\
    \x12\x03|\x02\n\n\x0c\n\x05\x04\0\x02\x20\x05\x12\x03|\x0c\x13\n\x0c\n\
    \x05\x04\0\x02\x20\x01\x12\x03|\x14$\n\x0c\n\x05\x04\0\x02\x20\x03\x12\
    \x03|(*\n\x0b\n\x04\x04\0\x02!\x12\x03}\x02+\n\x0c\n\x05\x04\0\x02!\x04\
    \x12\x03}\x02\n\n\x0c\n\x05\x04\0\x02!\x05\x12\x03}\x0b\x13\n\x0c\n\x05\
    \x04\0\x02!\x01\x12\x03}\x14%\n\x0c\n\x05\x04\0\x02!\x03\x12\x03}(*\n\
    \x0b\n\x04\x04\0\x02\"\x12\x03~\x02+\n\x0c\n\x05\x04\0\x02\"\x04\x12\x03\
    ~\x02\n\n\x0c\n\x05\x04\0\x02\"\x05\x12\x03~\x0b\x13\n\x0c\n\x05\x04\0\
    \x02\"\x01\x12\x03~\x14%\n\x0c\n\x05\x04\0\x02\"\x03\x12\x03~(*\n\x0b\n\
    \x04\x04\0\x02#\x12\x03\x7f\x02+\n\x0c\n\x05\x04\0\x02#\x04\x12\x03\x7f\
    \x02\n\n\x0c\n\x05\x04\0\x02#\x05\x12\x03\x7f\x0e\x13\n\x0c\n\x05\x04\0\
    \x02#\x01\x12\x03\x7f\x14\"\n\x0c\n\x05\x04\0\x02#\x03\x12\x03\x7f(*\n\
    \x0c\n\x04\x04\0\x02$\x12\x04\x80\x01\x02+\n\r\n\x05\x04\0\x02$\x04\x12\
    \x04\x80\x01\x02\n\n\r\n\x05\x04\0\x02$\x05\x12\x04\x80\x01\r\x13\n\r\n\
    \x05\x04\0\x02$\x01\x12\x04\x80\x01\x14#\n\r\n\x05\x04\0\x02$\x03\x12\
    \x04\x80\x01(*\n\x0c\n\x04\x04\0\x02%\x12\x04\x81\x01\x02+\n\r\n\x05\x04\
    \0\x02%\x04\x12\x04\x81\x01\x02\n\n\r\n\x05\x04\0\x02%\x05\x12\x04\x81\
    \x01\x0f\x13\n\r\n\x05\x04\0\x02%\x01\x12\x04\x81\x01\x14!\n\r\n\x05\x04\
    \0\x02%\x03\x12\x04\x81\x01(*\n\x0c\n\x04\x04\0\x02&\x12\x04\x82\x01\x02\
    +\n\r\n\x05\x04\0\x02&\x04\x12\x04\x82\x01\x02\n\n\r\n\x05\x04\0\x02&\
    \x05\x12\x04\x82\x01\r\x13\n\r\n\x05\x04\0\x02&\x01\x12\x04\x82\x01\x14#\
    \n\r\n\x05\x04\0\x02&\x03\x12\x04\x82\x01(*\n\x0c\n\x04\x04\0\x02'\x12\
    \x04\x83\x01\x02+\n\r\n\x05\x04\0\x02'\x04\x12\x04\x83\x01\x02\n\n\r\n\
    \x05\x04\0\x02'\x05\x12\x04\x83\x01\x0e\x13\n\r\n\x05\x04\0\x02'\x01\x12\
    \x04\x83\x01\x14\"\n\r\n\x05\x04\0\x02'\x03\x12\x04\x83\x01(*\nL\n\x04\
    \x04\0\x02(\x12\x04\x8b\x01\x02N2>\nrepeated\x20group\x20RepeatedGroup\
    \x20=\x2046\x20{\noptional\x20int32\x20a\x20=\x2047;\n}\n\n\r\n\x05\x04\
    \0\x02(\x04\x12\x04\x8b\x01\x02\n\n\r\n\x05\x04\0\x02(\x06\x12\x04\x8b\
    \x01\x0b\x18\n\r\n\x05\x04\0\x02(\x01\x12\x04\x8b\x010G\n\r\n\x05\x04\0\
    \x02(\x03\x12\x04\x8b\x01KM\n\x0c\n\x04\x04\0\x02)\x12\x04\x8c\x01\x02N\
    \n\r\n\x05\x04\0\x02)\x04\x12\x04\x8c\x01\x02\n\n\r\n\x05\x04\0\x02)\x06\
    \x12\x04\x8c\x01\x0b\x19\n\r\n\x05\x04\0\x02)\x01\x12\x04\x8c\x010H\n\r\
    \n\x05\x04\0\x02)\x03\x12\x04\x8c\x01KM\n\x0c\n\x04\x04\0\x02*\x12\x04\
    \x8d\x01\x02P\n\r\n\x05\x04\0\x02*\x04\x12\x04\x8d\x01\x02\n\n\r\n\x05\
    \x04\0\x02*\x06\x12\x04\x8d\x01\x0b1\n\r\n\x05\x04\0\x02*\x01\x12\x04\
    \x8d\x012I\n\r\n\x05\x04\0\x02*\x03\x12\x04\x8d\x01MO\n\x0c\n\x04\x04\0\
    \x02+\x12\x04\x8f\x01\x02N\n\r\n\x05\x04\0\x02+\x04\x12\x04\x8f\x01\x02\
    \n\n\r\n\x05\x04\0\x02+\x06\x12\x04\x8f\x01\x0b\x15\n\r\n\x05\x04\0\x02+\
    \x01\x12\x04\x8f\x010D\n\r\n\x05\x04\0\x02+\x03\x12\x04\x8f\x01KM\n\x0c\
    \n\x04\x04\0\x02,\x12\x04\x90\x01\x02N\n\r\n\x05\x04\0\x02,\x04\x12\x04\
    \x90\x01\x02\n\n\r\n\x05\x04\0\x02,\x06\x12\x04\x90\x01\x0b\x16\n\r\n\
    \x05\x04\0\x02,\x01\x12\x04\x90\x010E\n\r\n\x05\x04\0\x02,\x03\x12\x04\
    \x90\x01KM\n\x0c\n\x04\x04\0\x02-\x12\x04\x91\x01\x02P\n\r\n\x05\x04\0\
    \x02-\x04\x12\x04\x91\x01\x02\n\n\r\n\x05\x04\0\x02-\x06\x12\x04\x91\x01\
    \x0b.\n\r\n\x05\x04\0\x02-\x01\x12\x04\x91\x012F\n\r\n\x05\x04\0\x02-\
    \x03\x12\x04\x91\x01MO\n\x0c\n\x04\x04\0\x02.\x12\x04\x93\x01\x02B\n\r\n\
    \x05\x04\0\x02.\x04\x12\x04\x93\x01\x02\n\n\r\n\x05\x04\0\x02.\x05\x12\
    \x04\x93\x01\x0b\x11\n\r\n\x05\x04\0\x02.\x01\x12\x04\x93\x01\x12'\n\r\n\
    \x05\x04\0\x02.\x03\x12\x04\x93\x01*,\n\r\n\x05\x04\0\x02.\x08\x12\x04\
    \x93\x01-A\n\x0e\n\x06\x04\0\x02.\x08\x01\x12\x04\x93\x01.@\n\x0c\n\x04\
    \x04\0\x02/\x12\x04\x94\x01\x022\n\r\n\x05\x04\0\x02/\x04\x12\x04\x94\
    \x01\x02\n\n\r\n\x05\x04\0\x02/\x05\x12\x04\x94\x01\x0b\x11\n\r\n\x05\
    \x04\0\x02/\x01\x12\x04\x94\x01\x12\x1f\n\r\n\x05\x04\0\x02/\x03\x12\x04\
    \x94\x01\"$\n\r\n\x05\x04\0\x02/\x08\x12\x04\x94\x01%1\n\x0e\n\x06\x04\0\
    \x02/\x08\x01\x12\x04\x94\x01&0\n\x0c\n\x04\x04\0\x020\x12\x04\x96\x01\
    \x02@\n\r\n\x05\x04\0\x020\x04\x12\x04\x96\x01\x02\n\n\r\n\x05\x04\0\x02\
    0\x06\x12\x04\x96\x01\x0b\x18\n\r\n\x05\x04\0\x020\x01\x12\x04\x96\x01\
    \x19.\n\r\n\x05\x04\0\x020\x03\x12\x04\x96\x0113\n\r\n\x05\x04\0\x020\
    \x08\x12\x04\x96\x014?\n\x0e\n\x06\x04\0\x020\x08\x05\x12\x04\x96\x015>\
    \n&\n\x04\x04\0\x021\x12\x04\x99\x01\x02>\x1a\x18\x20Singular\x20with\
    \x20defaults\n\n\r\n\x05\x04\0\x021\x04\x12\x04\x99\x01\x02\n\n\r\n\x05\
    \x04\0\x021\x05\x12\x04\x99\x01\x0e\x13\n\r\n\x05\x04\0\x021\x01\x12\x04\
    \x99\x01\x14!\n\r\n\x05\x04\0\x021\x03\x12\x04\x99\x01')\n\r\n\x05\x04\0\
    \x021\x08\x12\x04\x99\x01*=\n\r\n\x05\x04\0\x021\x07\x12\x04\x99\x0168\n\
    \x0c\n\x04\x04\0\x022\x12\x04\x9a\x01\x02>\n\r\n\x05\x04\0\x022\x04\x12\
    \x04\x9a\x01\x02\n\n\r\n\x05\x04\0\x022\x05\x12\x04\x9a\x01\x0e\x13\n\r\
    \n\x05\x04\0\x022\x01\x12\x04\x9a\x01\x14!\n\r\n\x05\x04\0\x022\x03\x12\
    \x04\x9a\x01')\n\r\n\x05\x04\0\x022\x08\x12\x04\x9a\x01*=\n\r\n\x05\x04\
    \0\x022\x07\x12\x04\x9a\x0168\n\x0c\n\x04\x04\0\x023\x12\x04\x9b\x01\x02\
    >\n\r\n\x05\x04\0\x023\x04\x12\x04\x9b\x01\x02\n\n\r\n\x05\x04\0\x023\
    \x05\x12\x04\x9b\x01\r\x13\n\r\n\x05\x04\0\x023\x01\x12\x04\x9b\x01\x14\
    \"\n\r\n\x05\x04\0\x023\x03\x12\x04\x9b\x01')\n\r\n\x05\x04\0\x023\x08\
    \x12\x04\x9b\x01*=\n\r\n\x05\x04\0\x023\x07\x12\x04\x9b\x0168\n\x0c\n\
    \x04\x04\0\x024\x12\x04\x9c\x01\x02>\n\r\n\x05\x04\0\x024\x04\x12\x04\
    \x9c\x01\x02\n\n\r\n\x05\x04\0\x024\x05\x12\x04\x9c\x01\r\x13\n\r\n\x05\
    \x04\0\x024\x01\x12\x04\x9c\x01\x14\"\n\r\n\x05\x04\0\x024\x03\x12\x04\
    \x9c\x01')\n\r\n\x05\x04\0\x024\x08\x12\x04\x9c\x01*=\n\r\n\x05\x04\0\
    \x024\x07\x12\x04\x9c\x0168\n\x0c\n\x04\x04\0\x025\x12\x04\x9d\x01\x02>\
    \n\r\n\x05\x04\0\x025\x04\x12\x04\x9d\x01\x02\n\n\r\n\x05\x04\0\x025\x05\
    \x12\x04\x9d\x01\r\x13\n\r\n\x05\x04\0\x025\x01\x12\x04\x9d\x01\x14\"\n\
    \r\n\x05\x04\0\x025\x03\x12\x04\x9d\x01')\n\r\n\x05\x04\0\x025\x08\x12\
    \x04\x9d\x01*=\n\r\n\x05\x04\0\x025\x07\x12\x04\x9d\x0158\n\x0c\n\x04\
    \x04\0\x026\x12\x04\x9e\x01\x02>\n\r\n\x05\x04\0\x026\x04\x12\x04\x9e\
    \x01\x02\n\n\r\n\x05\x04\0\x026\x05\x12\x04\x9e\x01\r\x13\n\r\n\x05\x04\
    \0\x026\x01\x12\x04\x9e\x01\x14\"\n\r\n\x05\x04\0\x026\x03\x12\x04\x9e\
    \x01')\n\r\n\x05\x04\0\x026\x08\x12\x04\x9e\x01*=\n\r\n\x05\x04\0\x026\
    \x07\x12\x04\x9e\x0168\n\x0c\n\x04\x04\0\x027\x12\x04\x9f\x01\x02>\n\r\n\
    \x05\x04\0\x027\x04\x12\x04\x9f\x01\x02\n\n\r\n\x05\x04\0\x027\x05\x12\
    \x04\x9f\x01\x0c\x13\n\r\n\x05\x04\0\x027\x01\x12\x04\x9f\x01\x14#\n\r\n\
    \x05\x04\0\x027\x03\x12\x04\x9f\x01')\n\r\n\x05\x04\0\x027\x08\x12\x04\
    \x9f\x01*=\n\r\n\x05\x04\0\x027\x07\x12\x04\x9f\x0168\n\x0c\n\x04\x04\0\
    \x028\x12\x04\xa0\x01\x02>\n\r\n\x05\x04\0\x028\x04\x12\x04\xa0\x01\x02\
    \n\n\r\n\x05\x04\0\x028\x05\x12\x04\xa0\x01\x0c\x13\n\r\n\x05\x04\0\x028\
    \x01\x12\x04\xa0\x01\x14#\n\r\n\x05\x04\0\x028\x03\x12\x04\xa0\x01')\n\r\
    \n\x05\x04\0\x028\x08\x12\x04\xa0\x01*=\n\r\n\x05\x04\0\x028\x07\x12\x04\
    \xa0\x0168\n\x0c\n\x04\x04\0\x029\x12\x04\xa1\x01\x02>\n\r\n\x05\x04\0\
    \x029\x04\x12\x04\xa1\x01\x02\n\n\r\n\x05\x04\0\x029\x05\x12\x04\xa1\x01\
    \x0b\x13\n\r\n\x05\x04\0\x029\x01\x12\x04\xa1\x01\x14$\n\r\n\x05\x04\0\
    \x029\x03\x12\x04\xa1\x01')\n\r\n\x05\x04\0\x029\x08\x12\x04\xa1\x01*=\n\
    \r\n\x05\x04\0\x029\x07\x12\x04\xa1\x0168\n\x0c\n\x04\x04\0\x02:\x12\x04\
    \xa2\x01\x02>\n\r\n\x05\x04\0\x02:\x04\x12\x04\xa2\x01\x02\n\n\r\n\x05\
    \x04\0\x02:\x05\x12\x04\xa2\x01\x0b\x13\n\r\n\x05\x04\0\x02:\x01\x12\x04\
    \xa2\x01\x14$\n\r\n\x05\x04\0\x02:\x03\x12\x04\xa2\x01')\n\r\n\x05\x04\0\
    \x02:\x08\x12\x04\xa2\x01*=\n\r\n\x05\x04\0\x02:\x07\x12\x04\xa2\x0158\n\
    \x0c\n\x04\x04\0\x02;\x12\x04\xa3\x01\x02>\n\r\n\x05\x04\0\x02;\x04\x12\
    \x04\xa3\x01\x02\n\n\r\n\x05\x04\0\x02;\x05\x12\x04\xa3\x01\x0e\x13\n\r\
    \n\x05\x04\0\x02;\x01\x12\x04\xa3\x01\x14!\n\r\n\x05\x04\0\x02;\x03\x12\
    \x04\xa3\x01')\n\r\n\x05\x04\0\x02;\x08\x12\x04\xa3\x01*=\n\r\n\x05\x04\
    \0\x02;\x07\x12\x04\xa3\x016:\n\x0c\n\x04\x04\0\x02<\x12\x04\xa4\x01\x02\
    >\n\r\n\x05\x04\0\x02<\x04\x12\x04\xa4\x01\x02\n\n\r\n\x05\x04\0\x02<\
    \x05\x12\x04\xa4\x01\r\x13\n\r\n\x05\x04\0\x02<\x01\x12\x04\xa4\x01\x14\
    \"\n\r\n\x05\x04\0\x02<\x03\x12\x04\xa4\x01')\n\r\n\x05\x04\0\x02<\x08\
    \x12\x04\xa4\x01*=\n\r\n\x05\x04\0\x02<\x07\x12\x04\xa4\x016:\n\x0c\n\
    \x04\x04\0\x02=\x12\x04\xa5\x01\x02>\n\r\n\x05\x04\0\x02=\x04\x12\x04\
    \xa5\x01\x02\n\n\r\n\x05\x04\0\x02=\x05\x12\x04\xa5\x01\x0f\x13\n\r\n\
    \x05\x04\0\x02=\x01\x12\x04\xa5\x01\x14\x20\n\r\n\x05\x04\0\x02=\x03\x12\
    \x04\xa5\x01')\n\r\n\x05\x04\0\x02=\x08\x12\x04\xa5\x01*=\n\r\n\x05\x04\
    \0\x02=\x07\x12\x04\xa5\x0159\n\x0c\n\x04\x04\0\x02>\x12\x04\xa6\x01\x02\
    >\n\r\n\x05\x04\0\x02>\x04\x12\x04\xa6\x01\x02\n\n\r\n\x05\x04\0\x02>\
    \x05\x12\x04\xa6\x01\r\x13\n\r\n\x05\x04\0\x02>\x01\x12\x04\xa6\x01\x14\
    \"\n\r\n\x05\x04\0\x02>\x03\x12\x04\xa6\x01')\n\r\n\x05\x04\0\x02>\x08\
    \x12\x04\xa6\x01*=\n\r\n\x05\x04\0\x02>\x07\x12\x04\xa6\x015<\n\x0c\n\
    \x04\x04\0\x02?\x12\x04\xa7\x01\x02>\n\r\n\x05\x04\0\x02?\x04\x12\x04\
    \xa7\x01\x02\n\n\r\n\x05\x04\0\x02?\x05\x12\x04\xa7\x01\x0e\x13\n\r\n\
    \x05\x04\0\x02?\x01\x12\x04\xa7\x01\x14!\n\r\n\x05\x04\0\x02?\x03\x12\
    \x04\xa7\x01')\n\r\n\x05\x04\0\x02?\x08\x12\x04\xa7\x01*=\n\r\n\x05\x04\
    \0\x02?\x07\x12\x04\xa7\x015<\n\x0c\n\x04\x04\0\x02@\x12\x04\xa9\x01\x02\
    I\n\r\n\x05\x04\0\x02@\x04\x12\x04\xa9\x01\x02\n\n\r\n\x05\x04\0\x02@\
    \x06\x12\x04\xa9\x01\x0b\x15\n\r\n\x05\x04\0\x02@\x01\x12\x04\xa9\x01\
    \x17*\n\r\n\x05\x04\0\x02@\x03\x12\x04\xa9\x01.0\n\r\n\x05\x04\0\x02@\
    \x08\x12\x04\xa9\x011H\n\r\n\x05\x04\0\x02@\x07\x12\x04\xa9\x01<?\n\x0c\
    \n\x04\x04\0\x02A\x12\x04\xaa\x01\x02I\n\r\n\x05\x04\0\x02A\x04\x12\x04\
    \xaa\x01\x02\n\n\r\n\x05\x04\0\x02A\x06\x12\x04\xaa\x01\x0b\x16\n\r\n\
    \x05\x04\0\x02A\x01\x12\x04\xaa\x01\x17+\n\r\n\x05\x04\0\x02A\x03\x12\
    \x04\xaa\x01.0\n\r\n\x05\x04\0\x02A\x08\x12\x04\xaa\x011H\n\r\n\x05\x04\
    \0\x02A\x07\x12\x04\xaa\x01<G\n\x0e\n\x04\x04\0\x02B\x12\x06\xab\x01\x02\
    \xac\x016\n\r\n\x05\x04\0\x02B\x04\x12\x04\xab\x01\x02\n\n\r\n\x05\x04\0\
    \x02B\x06\x12\x04\xab\x01\x0b.\n\r\n\x05\x04\0\x02B\x01\x12\x04\xac\x01\
    \x06\x19\n\r\n\x05\x04\0\x02B\x03\x12\x04\xac\x01\x1c\x1e\n\r\n\x05\x04\
    \0\x02B\x08\x12\x04\xac\x01\x1f5\n\r\n\x05\x04\0\x02B\x07\x12\x04\xac\
    \x01*4\n\x0c\n\x04\x04\0\x02C\x12\x04\xae\x01\x02O\n\r\n\x05\x04\0\x02C\
    \x04\x12\x04\xae\x01\x02\n\n\r\n\x05\x04\0\x02C\x05\x12\x04\xae\x01\x0b\
    \x11\n\r\n\x05\x04\0\x02C\x01\x12\x04\xae\x01\x12&\n\r\n\x05\x04\0\x02C\
    \x03\x12\x04\xae\x01)+\n\r\n\x05\x04\0\x02C\x08\x12\x04\xae\x01,N\n\x0e\
    \n\x06\x04\0\x02C\x08\x01\x12\x04\xae\x01-?\n\r\n\x05\x04\0\x02C\x07\x12\
    \x04\xae\x01HM\n\x0c\n\x04\x04\0\x02D\x12\x04\xaf\x01\x02?\n\r\n\x05\x04\
    \0\x02D\x04\x12\x04\xaf\x01\x02\n\n\r\n\x05\x04\0\x02D\x05\x12\x04\xaf\
    \x01\x0b\x11\n\r\n\x05\x04\0\x02D\x01\x12\x04\xaf\x01\x12\x1e\n\r\n\x05\
    \x04\0\x02D\x03\x12\x04\xaf\x01!#\n\r\n\x05\x04\0\x02D\x08\x12\x04\xaf\
    \x01$>\n\x0e\n\x06\x04\0\x02D\x08\x01\x12\x04\xaf\x01%/\n\r\n\x05\x04\0\
    \x02D\x07\x12\x04\xaf\x018=\n\x20\n\x04\x04\0\x08\0\x12\x06\xb2\x01\x02\
    \xb7\x01\x03\x1a\x10\x20For\x20oneof\x20test\n\n\r\n\x05\x04\0\x08\0\x01\
    \x12\x04\xb2\x01\x08\x13\n\x0c\n\x04\x04\0\x02E\x12\x04\xb3\x01\x04\x1e\
    \n\r\n\x05\x04\0\x02E\x05\x12\x04\xb3\x01\x04\n\n\r\n\x05\x04\0\x02E\x01\
    \x12\x04\xb3\x01\x0b\x17\n\r\n\x05\x04\0\x02E\x03\x12\x04\xb3\x01\x1a\
    \x1d\n\x0c\n\x04\x04\0\x02F\x12\x04\xb4\x01\x04-\n\r\n\x05\x04\0\x02F\
    \x06\x12\x04\xb4\x01\x04\x11\n\r\n\x05\x04\0\x02F\x01\x12\x04\xb4\x01\
    \x12&\n\r\n\x05\x04\0\x02F\x03\x12\x04\xb4\x01),\n\x0c\n\x04\x04\0\x02G\
    \x12\x04\xb5\x01\x04\x1e\n\r\n\x05\x04\0\x02G\x05\x12\x04\xb5\x01\x04\n\
    \n\r\n\x05\x04\0\x02G\x01\x12\x04\xb5\x01\x0b\x17\n\r\n\x05\x04\0\x02G\
    \x03\x12\x04\xb5\x01\x1a\x1d\n\x0c\n\x04\x04\0\x02H\x12\x04\xb6\x01\x04\
    \x1c\n\r\n\x05\x04\0\x02H\x05\x12\x04\xb6\x01\x04\t\n\r\n\x05\x04\0\x02H\
    \x01\x12\x04\xb6\x01\n\x15\n\r\n\x05\x04\0\x02H\x03\x12\x04\xb6\x01\x18\
    \x1b\n@\n\x02\x04\x01\x12\x06\xbb\x01\0\xbf\x01\x01\x1a2\x20This\x20prot\
    o\x20includes\x20a\x20recusively\x20nested\x20message.\n\n\x0b\n\x03\x04\
    \x01\x01\x12\x04\xbb\x01\x08\x1a\n\x0c\n\x04\x04\x01\x02\0\x12\x04\xbc\
    \x01\x02(\n\r\n\x05\x04\x01\x02\0\x04\x12\x04\xbc\x01\x02\n\n\r\n\x05\
    \x04\x01\x02\0\x06\x12\x04\xbc\x01\x0b\x1d\n\r\n\x05\x04\x01\x02\0\x01\
    \x12\x04\xbc\x01\x1e#\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\xbc\x01&'\n\
    \x0c\n\x04\x04\x01\x02\x01\x12\x04\xbd\x01\x02$\n\r\n\x05\x04\x01\x02\
    \x01\x04\x12\x04\xbd\x01\x02\n\n\r\n\x05\x04\x01\x02\x01\x06\x12\x04\xbd\
    \x01\x0b\x17\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\xbd\x01\x18\x1f\n\r\n\
    \x05\x04\x01\x02\x01\x03\x12\x04\xbd\x01\"#\n\x0c\n\x04\x04\x01\x02\x02\
    \x12\x04\xbe\x01\x021\n\r\n\x05\x04\x01\x02\x02\x04\x12\x04\xbe\x01\x02\
    \n\n\r\n\x05\x04\x01\x02\x02\x06\x12\x04\xbe\x01\x0b\x1d\n\r\n\x05\x04\
    \x01\x02\x02\x01\x12\x04\xbe\x01\x1e,\n\r\n\x05\x04\x01\x02\x02\x03\x12\
    \x04\xbe\x01/0\n\x0c\n\x02\x04\x02\x12\x06\xc1\x01\0\xc3\x01\x01\n\x0b\n\
    \x03\x04\x02\x01\x12\x04\xc1\x01\x08\x1c\n\x0c\n\x04\x04\x02\x02\0\x12\
    \x04\xc2\x01\x028\n\r\n\x05\x04\x02\x02\0\x04\x12\x04\xc2\x01\x02\n\n\r\
    \n\x05\x04\x02\x02\0\x05\x12\x04\xc2\x01\x0b\x10\n\r\n\x05\x04\x02\x02\0\
    \x01\x12\x04\xc2\x01\x11!\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\xc2\x01$%\
    \n\r\n\x05\x04\x02\x02\0\x08\x12\x04\xc2\x01&7\n\x0e\n\x06\x04\x02\x02\0\
    \x08\x03\x12\x04\xc2\x01'6\n[\n\x02\x04\x03\x12\x06\xc7\x01\0\xc9\x01\
    \x01\x1aM\x20Define\x20these\x20after\x20TestAllTypes\x20to\x20make\x20s\
    ure\x20the\x20compiler\x20can\x20handle\n\x20that.\n\n\x0b\n\x03\x04\x03\
    \x01\x12\x04\xc7\x01\x08\x16\n\x0c\n\x04\x04\x03\x02\0\x12\x04\xc8\x01\
    \x02\x17\n\r\n\x05\x04\x03\x02\0\x04\x12\x04\xc8\x01\x02\n\n\r\n\x05\x04\
    \x03\x02\0\x05\x12\x04\xc8\x01\x0b\x10\n\r\n\x05\x04\x03\x02\0\x01\x12\
    \x04\xc8\x01\x11\x12\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xc8\x01\x15\x16\
    \n\x0c\n\x02\x05\0\x12\x06\xcb\x01\0\xcf\x01\x01\n\x0b\n\x03\x05\0\x01\
    \x12\x04\xcb\x01\x05\x10\n\x0c\n\x04\x05\0\x02\0\x12\x04\xcc\x01\x02\x12\
    \n\r\n\x05\x05\0\x02\0\x01\x12\x04\xcc\x01\x02\r\n\r\n\x05\x05\0\x02\0\
    \x02\x12\x04\xcc\x01\x10\x11\n\x0c\n\x04\x05\0\x02\x01\x12\x04\xcd\x01\
    \x02\x12\n\r\n\x05\x05\0\x02\x01\x01\x12\x04\xcd\x01\x02\r\n\r\n\x05\x05\
    \0\x02\x01\x02\x12\x04\xcd\x01\x10\x11\n\x0c\n\x04\x05\0\x02\x02\x12\x04\
    \xce\x01\x02\x12\n\r\n\x05\x05\0\x02\x02\x01\x12\x04\xce\x01\x02\r\n\r\n\
    \x05\x05\0\x02\x02\x02\x12\x04\xce\x01\x10\x11\n\x0c\n\x02\x04\x04\x12\
    \x06\xd1\x01\0\xd4\x01\x01\n\x0b\n\x03\x04\x04\x01\x12\x04\xd1\x01\x08\
    \x1a\n\x0b\n\x03\x04\x04\t\x12\x04\xd2\x01\x0b\x1a\n\x0c\n\x04\x04\x04\t\
    \0\x12\x04\xd2\x01\x0b\x0c\n\r\n\x05\x04\x04\t\0\x01\x12\x04\xd2\x01\x0b\
    \x0c\n\r\n\x05\x04\x04\t\0\x02\x12\x04\xd2\x01\x0b\x0c\n\x0c\n\x04\x04\
    \x04\t\x01\x12\x04\xd2\x01\x0e\x10\n\r\n\x05\x04\x04\t\x01\x01\x12\x04\
    \xd2\x01\x0e\x10\n\r\n\x05\x04\x04\t\x01\x02\x12\x04\xd2\x01\x0e\x10\n\
    \x0c\n\x04\x04\x04\t\x02\x12\x04\xd2\x01\x12\x19\n\r\n\x05\x04\x04\t\x02\
    \x01\x12\x04\xd2\x01\x12\x13\n\r\n\x05\x04\x04\t\x02\x02\x12\x04\xd2\x01\
    \x17\x19\n\x0b\n\x03\x04\x04\n\x12\x04\xd3\x01\x0b\x18\n\x0c\n\x04\x04\
    \x04\n\0\x12\x04\xd3\x01\x0b\x10\n\x0c\n\x04\x04\x04\n\x01\x12\x04\xd3\
    \x01\x12\x17\n\x0c\n\x02\x04\x05\x12\x06\xd6\x01\0\xd8\x01\x01\n\x0b\n\
    \x03\x04\x05\x01\x12\x04\xd6\x01\x08\x19\n\x0b\n\x03\x04\x05\x05\x12\x04\
    \xd7\x01\x02\x16\n\x0c\n\x04\x04\x05\x05\0\x12\x04\xd7\x01\r\x15\n\r\n\
    \x05\x04\x05\x05\0\x01\x12\x04\xd7\x01\r\x0e\n\r\n\x05\x04\x05\x05\0\x02\
    \x12\x04\xd7\x01\x12\x15\n\x0b\n\x01\x07\x12\x06\xda\x01\0\xcd\x02\x01\n\
    \x16\n\x02\x07\0\x12\x04\xdc\x01\x025\x1a\n\x20Singular\n\n\x0b\n\x03\
    \x07\0\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07\0\x04\x12\x04\xdc\x01\
    \x02\n\n\x0b\n\x03\x07\0\x05\x12\x04\xdc\x01\x0e\x13\n\x0b\n\x03\x07\0\
    \x01\x12\x04\xdc\x01\x14,\n\x0b\n\x03\x07\0\x03\x12\x04\xdc\x0134\n\n\n\
    \x02\x07\x01\x12\x04\xdd\x01\x025\n\x0b\n\x03\x07\x01\x02\x12\x04\xda\
    \x01\x07\x18\n\x0b\n\x03\x07\x01\x04\x12\x04\xdd\x01\x02\n\n\x0b\n\x03\
    \x07\x01\x05\x12\x04\xdd\x01\x0e\x13\n\x0b\n\x03\x07\x01\x01\x12\x04\xdd\
    \x01\x14,\n\x0b\n\x03\x07\x01\x03\x12\x04\xdd\x0134\n\n\n\x02\x07\x02\
    \x12\x04\xde\x01\x025\n\x0b\n\x03\x07\x02\x02\x12\x04\xda\x01\x07\x18\n\
    \x0b\n\x03\x07\x02\x04\x12\x04\xde\x01\x02\n\n\x0b\n\x03\x07\x02\x05\x12\
    \x04\xde\x01\r\x13\n\x0b\n\x03\x07\x02\x01\x12\x04\xde\x01\x14-\n\x0b\n\
    \x03\x07\x02\x03\x12\x04\xde\x0134\n\n\n\x02\x07\x03\x12\x04\xdf\x01\x02\
    5\n\x0b\n\x03\x07\x03\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07\x03\
    \x04\x12\x04\xdf\x01\x02\n\n\x0b\n\x03\x07\x03\x05\x12\x04\xdf\x01\r\x13\
    \n\x0b\n\x03\x07\x03\x01\x12\x04\xdf\x01\x14-\n\x0b\n\x03\x07\x03\x03\
    \x12\x04\xdf\x0134\n\n\n\x02\x07\x04\x12\x04\xe0\x01\x025\n\x0b\n\x03\
    \x07\x04\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07\x04\x04\x12\x04\xe0\
    \x01\x02\n\n\x0b\n\x03\x07\x04\x05\x12\x04\xe0\x01\r\x13\n\x0b\n\x03\x07\
    \x04\x01\x12\x04\xe0\x01\x14-\n\x0b\n\x03\x07\x04\x03\x12\x04\xe0\x0134\
    \n\n\n\x02\x07\x05\x12\x04\xe1\x01\x025\n\x0b\n\x03\x07\x05\x02\x12\x04\
    \xda\x01\x07\x18\n\x0b\n\x03\x07\x05\x04\x12\x04\xe1\x01\x02\n\n\x0b\n\
    \x03\x07\x05\x05\x12\x04\xe1\x01\r\x13\n\x0b\n\x03\x07\x05\x01\x12\x04\
    \xe1\x01\x14-\n\x0b\n\x03\x07\x05\x03\x12\x04\xe1\x0134\n\n\n\x02\x07\
    \x06\x12\x04\xe2\x01\x025\n\x0b\n\x03\x07\x06\x02\x12\x04\xda\x01\x07\
    \x18\n\x0b\n\x03\x07\x06\x04\x12\x04\xe2\x01\x02\n\n\x0b\n\x03\x07\x06\
    \x05\x12\x04\xe2\x01\x0c\x13\n\x0b\n\x03\x07\x06\x01\x12\x04\xe2\x01\x14\
    .\n\x0b\n\x03\x07\x06\x03\x12\x04\xe2\x0134\n\n\n\x02\x07\x07\x12\x04\
    \xe3\x01\x025\n\x0b\n\x03\x07\x07\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\
    \x03\x07\x07\x04\x12\x04\xe3\x01\x02\n\n\x0b\n\x03\x07\x07\x05\x12\x04\
    \xe3\x01\x0c\x13\n\x0b\n\x03\x07\x07\x01\x12\x04\xe3\x01\x14.\n\x0b\n\
    \x03\x07\x07\x03\x12\x04\xe3\x0134\n\n\n\x02\x07\x08\x12\x04\xe4\x01\x02\
    5\n\x0b\n\x03\x07\x08\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07\x08\
    \x04\x12\x04\xe4\x01\x02\n\n\x0b\n\x03\x07\x08\x05\x12\x04\xe4\x01\x0b\
    \x13\n\x0b\n\x03\x07\x08\x01\x12\x04\xe4\x01\x14/\n\x0b\n\x03\x07\x08\
    \x03\x12\x04\xe4\x0134\n\n\n\x02\x07\t\x12\x04\xe5\x01\x025\n\x0b\n\x03\
    \x07\t\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07\t\x04\x12\x04\xe5\x01\
    \x02\n\n\x0b\n\x03\x07\t\x05\x12\x04\xe5\x01\x0b\x13\n\x0b\n\x03\x07\t\
    \x01\x12\x04\xe5\x01\x14/\n\x0b\n\x03\x07\t\x03\x12\x04\xe5\x0124\n\n\n\
    \x02\x07\n\x12\x04\xe6\x01\x025\n\x0b\n\x03\x07\n\x02\x12\x04\xda\x01\
    \x07\x18\n\x0b\n\x03\x07\n\x04\x12\x04\xe6\x01\x02\n\n\x0b\n\x03\x07\n\
    \x05\x12\x04\xe6\x01\x0e\x13\n\x0b\n\x03\x07\n\x01\x12\x04\xe6\x01\x14,\
    \n\x0b\n\x03\x07\n\x03\x12\x04\xe6\x0124\n\n\n\x02\x07\x0b\x12\x04\xe7\
    \x01\x025\n\x0b\n\x03\x07\x0b\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\
    \x07\x0b\x04\x12\x04\xe7\x01\x02\n\n\x0b\n\x03\x07\x0b\x05\x12\x04\xe7\
    \x01\r\x13\n\x0b\n\x03\x07\x0b\x01\x12\x04\xe7\x01\x14-\n\x0b\n\x03\x07\
    \x0b\x03\x12\x04\xe7\x0124\n\n\n\x02\x07\x0c\x12\x04\xe8\x01\x025\n\x0b\
    \n\x03\x07\x0c\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07\x0c\x04\x12\
    \x04\xe8\x01\x02\n\n\x0b\n\x03\x07\x0c\x05\x12\x04\xe8\x01\x0f\x13\n\x0b\
    \n\x03\x07\x0c\x01\x12\x04\xe8\x01\x14+\n\x0b\n\x03\x07\x0c\x03\x12\x04\
    \xe8\x0124\n\n\n\x02\x07\r\x12\x04\xe9\x01\x025\n\x0b\n\x03\x07\r\x02\
    \x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07\r\x04\x12\x04\xe9\x01\x02\n\n\
    \x0b\n\x03\x07\r\x05\x12\x04\xe9\x01\r\x13\n\x0b\n\x03\x07\r\x01\x12\x04\
    \xe9\x01\x14-\n\x0b\n\x03\x07\r\x03\x12\x04\xe9\x0124\n\n\n\x02\x07\x0e\
    \x12\x04\xea\x01\x025\n\x0b\n\x03\x07\x0e\x02\x12\x04\xda\x01\x07\x18\n\
    \x0b\n\x03\x07\x0e\x04\x12\x04\xea\x01\x02\n\n\x0b\n\x03\x07\x0e\x05\x12\
    \x04\xea\x01\x0e\x13\n\x0b\n\x03\x07\x0e\x01\x12\x04\xea\x01\x14,\n\x0b\
    \n\x03\x07\x0e\x03\x12\x04\xea\x0124\nT\n\x02\x07\x0f\x12\x04\xf2\x01\
    \x02M2H\noptional\x20group\x20OptionalGroup_extension\x20=\x2016\x20{\no\
    ptional\x20int32\x20a\x20=\x2017;\n}\n\n\x0b\n\x03\x07\x0f\x02\x12\x04\
    \xda\x01\x07\x18\n\x0b\n\x03\x07\x0f\x04\x12\x04\xf2\x01\x02\n\n\x0b\n\
    \x03\x07\x0f\x06\x12\x04\xf2\x01\x0b%\n\x0b\n\x03\x07\x0f\x01\x12\x04\
    \xf2\x01&G\n\x0b\n\x03\x07\x0f\x03\x12\x04\xf2\x01JL\n\n\n\x02\x07\x10\
    \x12\x04\xf3\x01\x02B\n\x0b\n\x03\x07\x10\x02\x12\x04\xda\x01\x07\x18\n\
    \x0b\n\x03\x07\x10\x04\x12\x04\xf3\x01\x02\n\n\x0b\n\x03\x07\x10\x06\x12\
    \x04\xf3\x01\x0b\x19\n\x0b\n\x03\x07\x10\x01\x12\x04\xf3\x01\x1a<\n\x0b\
    \n\x03\x07\x10\x03\x12\x04\xf3\x01?A\n\x0c\n\x02\x07\x11\x12\x06\xf4\x01\
    \x02\xf5\x01+\n\x0b\n\x03\x07\x11\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\
    \x03\x07\x11\x04\x12\x04\xf4\x01\x02\n\n\x0b\n\x03\x07\x11\x06\x12\x04\
    \xf4\x01\x0b1\n\x0b\n\x03\x07\x11\x01\x12\x04\xf5\x01\x04%\n\x0b\n\x03\
    \x07\x11\x03\x12\x04\xf5\x01(*\n\n\n\x02\x07\x12\x12\x04\xf7\x01\x02G\n\
    \x0b\n\x03\x07\x12\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07\x12\x04\
    \x12\x04\xf7\x01\x02\n\n\x0b\n\x03\x07\x12\x06\x12\x04\xf7\x01\x0b\"\n\
    \x0b\n\x03\x07\x12\x01\x12\x04\xf7\x01#A\n\x0b\n\x03\x07\x12\x03\x12\x04\
    \xf7\x01DF\n\n\n\x02\x07\x13\x12\x04\xf8\x01\x02<\n\x0b\n\x03\x07\x13\
    \x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07\x13\x04\x12\x04\xf8\x01\x02\
    \n\n\x0b\n\x03\x07\x13\x06\x12\x04\xf8\x01\x0b\x16\n\x0b\n\x03\x07\x13\
    \x01\x12\x04\xf8\x01\x176\n\x0b\n\x03\x07\x13\x03\x12\x04\xf8\x019;\n\
    \x0c\n\x02\x07\x14\x12\x06\xf9\x01\x02\xfa\x01(\n\x0b\n\x03\x07\x14\x02\
    \x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07\x14\x04\x12\x04\xf9\x01\x02\n\n\
    \x0b\n\x03\x07\x14\x06\x12\x04\xf9\x01\x0b.\n\x0b\n\x03\x07\x14\x01\x12\
    \x04\xfa\x01\x04\"\n\x0b\n\x03\x07\x14\x03\x12\x04\xfa\x01%'\n\n\n\x02\
    \x07\x15\x12\x04\xfc\x01\x02L\n\x0b\n\x03\x07\x15\x02\x12\x04\xda\x01\
    \x07\x18\n\x0b\n\x03\x07\x15\x04\x12\x04\xfc\x01\x02\n\n\x0b\n\x03\x07\
    \x15\x05\x12\x04\xfc\x01\x0b\x11\n\x0b\n\x03\x07\x15\x01\x12\x04\xfc\x01\
    \x121\n\x0b\n\x03\x07\x15\x03\x12\x04\xfc\x0146\n\x0b\n\x03\x07\x15\x08\
    \x12\x04\xfc\x017K\n\x0c\n\x04\x07\x15\x08\x01\x12\x04\xfc\x018J\n\n\n\
    \x02\x07\x16\x12\x04\xfd\x01\x02<\n\x0b\n\x03\x07\x16\x02\x12\x04\xda\
    \x01\x07\x18\n\x0b\n\x03\x07\x16\x04\x12\x04\xfd\x01\x02\n\n\x0b\n\x03\
    \x07\x16\x05\x12\x04\xfd\x01\x0b\x11\n\x0b\n\x03\x07\x16\x01\x12\x04\xfd\
    \x01\x12)\n\x0b\n\x03\x07\x16\x03\x12\x04\xfd\x01,.\n\x0b\n\x03\x07\x16\
    \x08\x12\x04\xfd\x01/;\n\x0c\n\x04\x07\x16\x08\x01\x12\x04\xfd\x010:\n\
    \x0c\n\x02\x07\x17\x12\x06\xff\x01\x02\x80\x022\n\x0b\n\x03\x07\x17\x02\
    \x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07\x17\x04\x12\x04\xff\x01\x02\n\n\
    \x0b\n\x03\x07\x17\x06\x12\x04\xff\x01\x0b7\n\x0b\n\x03\x07\x17\x01\x12\
    \x04\x80\x02\x04,\n\x0b\n\x03\x07\x17\x03\x12\x04\x80\x02/1\n\x0c\n\x02\
    \x07\x18\x12\x06\x82\x02\x02\x83\x025\n\x0b\n\x03\x07\x18\x02\x12\x04\
    \xda\x01\x07\x18\n\x0b\n\x03\x07\x18\x04\x12\x04\x82\x02\x02\n\n\x0b\n\
    \x03\x07\x18\x06\x12\x04\x82\x02\x0b%\n\x0b\n\x03\x07\x18\x01\x12\x04\
    \x83\x02\x04#\n\x0b\n\x03\x07\x18\x03\x12\x04\x83\x02&(\n\x0b\n\x03\x07\
    \x18\x08\x12\x04\x83\x02)4\n\x0c\n\x04\x07\x18\x08\x05\x12\x04\x83\x02*3\
    \n\x16\n\x02\x07\x19\x12\x04\x86\x02\x025\x1a\n\x20Repeated\n\n\x0b\n\
    \x03\x07\x19\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07\x19\x04\x12\x04\
    \x86\x02\x02\n\n\x0b\n\x03\x07\x19\x05\x12\x04\x86\x02\x0e\x13\n\x0b\n\
    \x03\x07\x19\x01\x12\x04\x86\x02\x14,\n\x0b\n\x03\x07\x19\x03\x12\x04\
    \x86\x0224\n\n\n\x02\x07\x1a\x12\x04\x87\x02\x025\n\x0b\n\x03\x07\x1a\
    \x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07\x1a\x04\x12\x04\x87\x02\x02\
    \n\n\x0b\n\x03\x07\x1a\x05\x12\x04\x87\x02\x0e\x13\n\x0b\n\x03\x07\x1a\
    \x01\x12\x04\x87\x02\x14,\n\x0b\n\x03\x07\x1a\x03\x12\x04\x87\x0224\n\n\
    \n\x02\x07\x1b\x12\x04\x88\x02\x025\n\x0b\n\x03\x07\x1b\x02\x12\x04\xda\
    \x01\x07\x18\n\x0b\n\x03\x07\x1b\x04\x12\x04\x88\x02\x02\n\n\x0b\n\x03\
    \x07\x1b\x05\x12\x04\x88\x02\r\x13\n\x0b\n\x03\x07\x1b\x01\x12\x04\x88\
    \x02\x14-\n\x0b\n\x03\x07\x1b\x03\x12\x04\x88\x0224\n\n\n\x02\x07\x1c\
    \x12\x04\x89\x02\x025\n\x0b\n\x03\x07\x1c\x02\x12\x04\xda\x01\x07\x18\n\
    \x0b\n\x03\x07\x1c\x04\x12\x04\x89\x02\x02\n\n\x0b\n\x03\x07\x1c\x05\x12\
    \x04\x89\x02\r\x13\n\x0b\n\x03\x07\x1c\x01\x12\x04\x89\x02\x14-\n\x0b\n\
    \x03\x07\x1c\x03\x12\x04\x89\x0224\n\n\n\x02\x07\x1d\x12\x04\x8a\x02\x02\
    5\n\x0b\n\x03\x07\x1d\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07\x1d\
    \x04\x12\x04\x8a\x02\x02\n\n\x0b\n\x03\x07\x1d\x05\x12\x04\x8a\x02\r\x13\
    \n\x0b\n\x03\x07\x1d\x01\x12\x04\x8a\x02\x14-\n\x0b\n\x03\x07\x1d\x03\
    \x12\x04\x8a\x0224\n\n\n\x02\x07\x1e\x12\x04\x8b\x02\x025\n\x0b\n\x03\
    \x07\x1e\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07\x1e\x04\x12\x04\x8b\
    \x02\x02\n\n\x0b\n\x03\x07\x1e\x05\x12\x04\x8b\x02\r\x13\n\x0b\n\x03\x07\
    \x1e\x01\x12\x04\x8b\x02\x14-\n\x0b\n\x03\x07\x1e\x03\x12\x04\x8b\x0224\
    \n\n\n\x02\x07\x1f\x12\x04\x8c\x02\x025\n\x0b\n\x03\x07\x1f\x02\x12\x04\
    \xda\x01\x07\x18\n\x0b\n\x03\x07\x1f\x04\x12\x04\x8c\x02\x02\n\n\x0b\n\
    \x03\x07\x1f\x05\x12\x04\x8c\x02\x0c\x13\n\x0b\n\x03\x07\x1f\x01\x12\x04\
    \x8c\x02\x14.\n\x0b\n\x03\x07\x1f\x03\x12\x04\x8c\x0224\n\n\n\x02\x07\
    \x20\x12\x04\x8d\x02\x025\n\x0b\n\x03\x07\x20\x02\x12\x04\xda\x01\x07\
    \x18\n\x0b\n\x03\x07\x20\x04\x12\x04\x8d\x02\x02\n\n\x0b\n\x03\x07\x20\
    \x05\x12\x04\x8d\x02\x0c\x13\n\x0b\n\x03\x07\x20\x01\x12\x04\x8d\x02\x14\
    .\n\x0b\n\x03\x07\x20\x03\x12\x04\x8d\x0224\n\n\n\x02\x07!\x12\x04\x8e\
    \x02\x025\n\x0b\n\x03\x07!\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07!\
    \x04\x12\x04\x8e\x02\x02\n\n\x0b\n\x03\x07!\x05\x12\x04\x8e\x02\x0b\x13\
    \n\x0b\n\x03\x07!\x01\x12\x04\x8e\x02\x14/\n\x0b\n\x03\x07!\x03\x12\x04\
    \x8e\x0224\n\n\n\x02\x07\"\x12\x04\x8f\x02\x025\n\x0b\n\x03\x07\"\x02\
    \x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07\"\x04\x12\x04\x8f\x02\x02\n\n\
    \x0b\n\x03\x07\"\x05\x12\x04\x8f\x02\x0b\x13\n\x0b\n\x03\x07\"\x01\x12\
    \x04\x8f\x02\x14/\n\x0b\n\x03\x07\"\x03\x12\x04\x8f\x0224\n\n\n\x02\x07#\
    \x12\x04\x90\x02\x025\n\x0b\n\x03\x07#\x02\x12\x04\xda\x01\x07\x18\n\x0b\
    \n\x03\x07#\x04\x12\x04\x90\x02\x02\n\n\x0b\n\x03\x07#\x05\x12\x04\x90\
    \x02\x0e\x13\n\x0b\n\x03\x07#\x01\x12\x04\x90\x02\x14,\n\x0b\n\x03\x07#\
    \x03\x12\x04\x90\x0224\n\n\n\x02\x07$\x12\x04\x91\x02\x025\n\x0b\n\x03\
    \x07$\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07$\x04\x12\x04\x91\x02\
    \x02\n\n\x0b\n\x03\x07$\x05\x12\x04\x91\x02\r\x13\n\x0b\n\x03\x07$\x01\
    \x12\x04\x91\x02\x14-\n\x0b\n\x03\x07$\x03\x12\x04\x91\x0224\n\n\n\x02\
    \x07%\x12\x04\x92\x02\x025\n\x0b\n\x03\x07%\x02\x12\x04\xda\x01\x07\x18\
    \n\x0b\n\x03\x07%\x04\x12\x04\x92\x02\x02\n\n\x0b\n\x03\x07%\x05\x12\x04\
    \x92\x02\x0f\x13\n\x0b\n\x03\x07%\x01\x12\x04\x92\x02\x14+\n\x0b\n\x03\
    \x07%\x03\x12\x04\x92\x0224\n\n\n\x02\x07&\x12\x04\x93\x02\x025\n\x0b\n\
    \x03\x07&\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07&\x04\x12\x04\x93\
    \x02\x02\n\n\x0b\n\x03\x07&\x05\x12\x04\x93\x02\r\x13\n\x0b\n\x03\x07&\
    \x01\x12\x04\x93\x02\x14-\n\x0b\n\x03\x07&\x03\x12\x04\x93\x0224\n\n\n\
    \x02\x07'\x12\x04\x94\x02\x025\n\x0b\n\x03\x07'\x02\x12\x04\xda\x01\x07\
    \x18\n\x0b\n\x03\x07'\x04\x12\x04\x94\x02\x02\n\n\x0b\n\x03\x07'\x05\x12\
    \x04\x94\x02\x0e\x13\n\x0b\n\x03\x07'\x01\x12\x04\x94\x02\x14,\n\x0b\n\
    \x03\x07'\x03\x12\x04\x94\x0224\nT\n\x02\x07(\x12\x04\x9c\x02\x02M2H\nre\
    peated\x20group\x20RepeatedGroup_extension\x20=\x2046\x20{\noptional\x20\
    int32\x20a\x20=\x2047;\n}\n\n\x0b\n\x03\x07(\x02\x12\x04\xda\x01\x07\x18\
    \n\x0b\n\x03\x07(\x04\x12\x04\x9c\x02\x02\n\n\x0b\n\x03\x07(\x06\x12\x04\
    \x9c\x02\x0b%\n\x0b\n\x03\x07(\x01\x12\x04\x9c\x02&G\n\x0b\n\x03\x07(\
    \x03\x12\x04\x9c\x02JL\n\n\n\x02\x07)\x12\x04\x9d\x02\x02B\n\x0b\n\x03\
    \x07)\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07)\x04\x12\x04\x9d\x02\
    \x02\n\n\x0b\n\x03\x07)\x06\x12\x04\x9d\x02\x0b\x19\n\x0b\n\x03\x07)\x01\
    \x12\x04\x9d\x02\x1a<\n\x0b\n\x03\x07)\x03\x12\x04\x9d\x02?A\n\x0c\n\x02\
    \x07*\x12\x06\x9e\x02\x02\x9f\x02+\n\x0b\n\x03\x07*\x02\x12\x04\xda\x01\
    \x07\x18\n\x0b\n\x03\x07*\x04\x12\x04\x9e\x02\x02\n\n\x0b\n\x03\x07*\x06\
    \x12\x04\x9e\x02\x0b1\n\x0b\n\x03\x07*\x01\x12\x04\x9f\x02\x04%\n\x0b\n\
    \x03\x07*\x03\x12\x04\x9f\x02(*\n\n\n\x02\x07+\x12\x04\xa1\x02\x02G\n\
    \x0b\n\x03\x07+\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07+\x04\x12\x04\
    \xa1\x02\x02\n\n\x0b\n\x03\x07+\x06\x12\x04\xa1\x02\x0b\"\n\x0b\n\x03\
    \x07+\x01\x12\x04\xa1\x02#A\n\x0b\n\x03\x07+\x03\x12\x04\xa1\x02DF\n\n\n\
    \x02\x07,\x12\x04\xa2\x02\x02<\n\x0b\n\x03\x07,\x02\x12\x04\xda\x01\x07\
    \x18\n\x0b\n\x03\x07,\x04\x12\x04\xa2\x02\x02\n\n\x0b\n\x03\x07,\x06\x12\
    \x04\xa2\x02\x0b\x16\n\x0b\n\x03\x07,\x01\x12\x04\xa2\x02\x176\n\x0b\n\
    \x03\x07,\x03\x12\x04\xa2\x029;\n\x0c\n\x02\x07-\x12\x06\xa3\x02\x02\xa4\
    \x02(\n\x0b\n\x03\x07-\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07-\x04\
    \x12\x04\xa3\x02\x02\n\n\x0b\n\x03\x07-\x06\x12\x04\xa3\x02\x0b.\n\x0b\n\
    \x03\x07-\x01\x12\x04\xa4\x02\x04\"\n\x0b\n\x03\x07-\x03\x12\x04\xa4\x02\
    %'\n\n\n\x02\x07.\x12\x04\xa6\x02\x02L\n\x0b\n\x03\x07.\x02\x12\x04\xda\
    \x01\x07\x18\n\x0b\n\x03\x07.\x04\x12\x04\xa6\x02\x02\n\n\x0b\n\x03\x07.\
    \x05\x12\x04\xa6\x02\x0b\x11\n\x0b\n\x03\x07.\x01\x12\x04\xa6\x02\x121\n\
    \x0b\n\x03\x07.\x03\x12\x04\xa6\x0246\n\x0b\n\x03\x07.\x08\x12\x04\xa6\
    \x027K\n\x0c\n\x04\x07.\x08\x01\x12\x04\xa6\x028J\n\n\n\x02\x07/\x12\x04\
    \xa7\x02\x02<\n\x0b\n\x03\x07/\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\
    \x07/\x04\x12\x04\xa7\x02\x02\n\n\x0b\n\x03\x07/\x05\x12\x04\xa7\x02\x0b\
    \x11\n\x0b\n\x03\x07/\x01\x12\x04\xa7\x02\x12)\n\x0b\n\x03\x07/\x03\x12\
    \x04\xa7\x02,.\n\x0b\n\x03\x07/\x08\x12\x04\xa7\x02/;\n\x0c\n\x04\x07/\
    \x08\x01\x12\x04\xa7\x020:\n\x0c\n\x02\x070\x12\x06\xa9\x02\x02\xaa\x025\
    \n\x0b\n\x03\x070\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x070\x04\x12\
    \x04\xa9\x02\x02\n\n\x0b\n\x03\x070\x06\x12\x04\xa9\x02\x0b%\n\x0b\n\x03\
    \x070\x01\x12\x04\xaa\x02\x04#\n\x0b\n\x03\x070\x03\x12\x04\xaa\x02&(\n\
    \x0b\n\x03\x070\x08\x12\x04\xaa\x02)4\n\x0c\n\x04\x070\x08\x05\x12\x04\
    \xaa\x02*3\n$\n\x02\x071\x12\x04\xad\x02\x02H\x1a\x18\x20Singular\x20wit\
    h\x20defaults\n\n\x0b\n\x03\x071\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\
    \x071\x04\x12\x04\xad\x02\x02\n\n\x0b\n\x03\x071\x05\x12\x04\xad\x02\x0e\
    \x13\n\x0b\n\x03\x071\x01\x12\x04\xad\x02\x14+\n\x0b\n\x03\x071\x03\x12\
    \x04\xad\x0213\n\x0b\n\x03\x071\x08\x12\x04\xad\x024G\n\x0b\n\x03\x071\
    \x07\x12\x04\xad\x02@B\n\n\n\x02\x072\x12\x04\xae\x02\x02H\n\x0b\n\x03\
    \x072\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x072\x04\x12\x04\xae\x02\
    \x02\n\n\x0b\n\x03\x072\x05\x12\x04\xae\x02\x0e\x13\n\x0b\n\x03\x072\x01\
    \x12\x04\xae\x02\x14+\n\x0b\n\x03\x072\x03\x12\x04\xae\x0213\n\x0b\n\x03\
    \x072\x08\x12\x04\xae\x024G\n\x0b\n\x03\x072\x07\x12\x04\xae\x02@B\n\n\n\
    \x02\x073\x12\x04\xaf\x02\x02H\n\x0b\n\x03\x073\x02\x12\x04\xda\x01\x07\
    \x18\n\x0b\n\x03\x073\x04\x12\x04\xaf\x02\x02\n\n\x0b\n\x03\x073\x05\x12\
    \x04\xaf\x02\r\x13\n\x0b\n\x03\x073\x01\x12\x04\xaf\x02\x14,\n\x0b\n\x03\
    \x073\x03\x12\x04\xaf\x0213\n\x0b\n\x03\x073\x08\x12\x04\xaf\x024G\n\x0b\
    \n\x03\x073\x07\x12\x04\xaf\x02@B\n\n\n\x02\x074\x12\x04\xb0\x02\x02H\n\
    \x0b\n\x03\x074\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x074\x04\x12\x04\
    \xb0\x02\x02\n\n\x0b\n\x03\x074\x05\x12\x04\xb0\x02\r\x13\n\x0b\n\x03\
    \x074\x01\x12\x04\xb0\x02\x14,\n\x0b\n\x03\x074\x03\x12\x04\xb0\x0213\n\
    \x0b\n\x03\x074\x08\x12\x04\xb0\x024G\n\x0b\n\x03\x074\x07\x12\x04\xb0\
    \x02@B\n\n\n\x02\x075\x12\x04\xb1\x02\x02H\n\x0b\n\x03\x075\x02\x12\x04\
    \xda\x01\x07\x18\n\x0b\n\x03\x075\x04\x12\x04\xb1\x02\x02\n\n\x0b\n\x03\
    \x075\x05\x12\x04\xb1\x02\r\x13\n\x0b\n\x03\x075\x01\x12\x04\xb1\x02\x14\
    ,\n\x0b\n\x03\x075\x03\x12\x04\xb1\x0213\n\x0b\n\x03\x075\x08\x12\x04\
    \xb1\x024G\n\x0b\n\x03\x075\x07\x12\x04\xb1\x02?B\n\n\n\x02\x076\x12\x04\
    \xb2\x02\x02H\n\x0b\n\x03\x076\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\
    \x076\x04\x12\x04\xb2\x02\x02\n\n\x0b\n\x03\x076\x05\x12\x04\xb2\x02\r\
    \x13\n\x0b\n\x03\x076\x01\x12\x04\xb2\x02\x14,\n\x0b\n\x03\x076\x03\x12\
    \x04\xb2\x0213\n\x0b\n\x03\x076\x08\x12\x04\xb2\x024G\n\x0b\n\x03\x076\
    \x07\x12\x04\xb2\x02@B\n\n\n\x02\x077\x12\x04\xb3\x02\x02H\n\x0b\n\x03\
    \x077\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x077\x04\x12\x04\xb3\x02\
    \x02\n\n\x0b\n\x03\x077\x05\x12\x04\xb3\x02\x0c\x13\n\x0b\n\x03\x077\x01\
    \x12\x04\xb3\x02\x14-\n\x0b\n\x03\x077\x03\x12\x04\xb3\x0213\n\x0b\n\x03\
    \x077\x08\x12\x04\xb3\x024G\n\x0b\n\x03\x077\x07\x12\x04\xb3\x02@B\n\n\n\
    \x02\x078\x12\x04\xb4\x02\x02H\n\x0b\n\x03\x078\x02\x12\x04\xda\x01\x07\
    \x18\n\x0b\n\x03\x078\x04\x12\x04\xb4\x02\x02\n\n\x0b\n\x03\x078\x05\x12\
    \x04\xb4\x02\x0c\x13\n\x0b\n\x03\x078\x01\x12\x04\xb4\x02\x14-\n\x0b\n\
    \x03\x078\x03\x12\x04\xb4\x0213\n\x0b\n\x03\x078\x08\x12\x04\xb4\x024G\n\
    \x0b\n\x03\x078\x07\x12\x04\xb4\x02@B\n\n\n\x02\x079\x12\x04\xb5\x02\x02\
    H\n\x0b\n\x03\x079\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x079\x04\x12\
    \x04\xb5\x02\x02\n\n\x0b\n\x03\x079\x05\x12\x04\xb5\x02\x0b\x13\n\x0b\n\
    \x03\x079\x01\x12\x04\xb5\x02\x14.\n\x0b\n\x03\x079\x03\x12\x04\xb5\x021\
    3\n\x0b\n\x03\x079\x08\x12\x04\xb5\x024G\n\x0b\n\x03\x079\x07\x12\x04\
    \xb5\x02@B\n\n\n\x02\x07:\x12\x04\xb6\x02\x02H\n\x0b\n\x03\x07:\x02\x12\
    \x04\xda\x01\x07\x18\n\x0b\n\x03\x07:\x04\x12\x04\xb6\x02\x02\n\n\x0b\n\
    \x03\x07:\x05\x12\x04\xb6\x02\x0b\x13\n\x0b\n\x03\x07:\x01\x12\x04\xb6\
    \x02\x14.\n\x0b\n\x03\x07:\x03\x12\x04\xb6\x0213\n\x0b\n\x03\x07:\x08\
    \x12\x04\xb6\x024G\n\x0b\n\x03\x07:\x07\x12\x04\xb6\x02?B\n\n\n\x02\x07;\
    \x12\x04\xb7\x02\x02H\n\x0b\n\x03\x07;\x02\x12\x04\xda\x01\x07\x18\n\x0b\
    \n\x03\x07;\x04\x12\x04\xb7\x02\x02\n\n\x0b\n\x03\x07;\x05\x12\x04\xb7\
    \x02\x0e\x13\n\x0b\n\x03\x07;\x01\x12\x04\xb7\x02\x14+\n\x0b\n\x03\x07;\
    \x03\x12\x04\xb7\x0213\n\x0b\n\x03\x07;\x08\x12\x04\xb7\x024G\n\x0b\n\
    \x03\x07;\x07\x12\x04\xb7\x02@D\n\n\n\x02\x07<\x12\x04\xb8\x02\x02H\n\
    \x0b\n\x03\x07<\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07<\x04\x12\x04\
    \xb8\x02\x02\n\n\x0b\n\x03\x07<\x05\x12\x04\xb8\x02\r\x13\n\x0b\n\x03\
    \x07<\x01\x12\x04\xb8\x02\x14,\n\x0b\n\x03\x07<\x03\x12\x04\xb8\x0213\n\
    \x0b\n\x03\x07<\x08\x12\x04\xb8\x024G\n\x0b\n\x03\x07<\x07\x12\x04\xb8\
    \x02@D\n\n\n\x02\x07=\x12\x04\xb9\x02\x02H\n\x0b\n\x03\x07=\x02\x12\x04\
    \xda\x01\x07\x18\n\x0b\n\x03\x07=\x04\x12\x04\xb9\x02\x02\n\n\x0b\n\x03\
    \x07=\x05\x12\x04\xb9\x02\x0f\x13\n\x0b\n\x03\x07=\x01\x12\x04\xb9\x02\
    \x14*\n\x0b\n\x03\x07=\x03\x12\x04\xb9\x0213\n\x0b\n\x03\x07=\x08\x12\
    \x04\xb9\x024G\n\x0b\n\x03\x07=\x07\x12\x04\xb9\x02?C\n\n\n\x02\x07>\x12\
    \x04\xba\x02\x02H\n\x0b\n\x03\x07>\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\
    \x03\x07>\x04\x12\x04\xba\x02\x02\n\n\x0b\n\x03\x07>\x05\x12\x04\xba\x02\
    \r\x13\n\x0b\n\x03\x07>\x01\x12\x04\xba\x02\x14,\n\x0b\n\x03\x07>\x03\
    \x12\x04\xba\x0213\n\x0b\n\x03\x07>\x08\x12\x04\xba\x024G\n\x0b\n\x03\
    \x07>\x07\x12\x04\xba\x02?F\n\n\n\x02\x07?\x12\x04\xbb\x02\x02H\n\x0b\n\
    \x03\x07?\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07?\x04\x12\x04\xbb\
    \x02\x02\n\n\x0b\n\x03\x07?\x05\x12\x04\xbb\x02\x0e\x13\n\x0b\n\x03\x07?\
    \x01\x12\x04\xbb\x02\x14+\n\x0b\n\x03\x07?\x03\x12\x04\xbb\x0213\n\x0b\n\
    \x03\x07?\x08\x12\x04\xbb\x024G\n\x0b\n\x03\x07?\x07\x12\x04\xbb\x02?F\n\
    \x0c\n\x02\x07@\x12\x06\xbd\x02\x02\xbe\x027\n\x0b\n\x03\x07@\x02\x12\
    \x04\xda\x01\x07\x18\n\x0b\n\x03\x07@\x04\x12\x04\xbd\x02\x02\n\n\x0b\n\
    \x03\x07@\x06\x12\x04\xbd\x02\x0b\"\n\x0b\n\x03\x07@\x01\x12\x04\xbe\x02\
    \x04!\n\x0b\n\x03\x07@\x03\x12\x04\xbe\x02$&\n\x0b\n\x03\x07@\x08\x12\
    \x04\xbe\x02'6\n\x0b\n\x03\x07@\x07\x12\x04\xbe\x0225\n\x0c\n\x02\x07A\
    \x12\x06\xbf\x02\x02\xc0\x02@\n\x0b\n\x03\x07A\x02\x12\x04\xda\x01\x07\
    \x18\n\x0b\n\x03\x07A\x04\x12\x04\xbf\x02\x02\n\n\x0b\n\x03\x07A\x06\x12\
    \x04\xbf\x02\x0b\x16\n\x0b\n\x03\x07A\x01\x12\x04\xc0\x02\x04\"\n\x0b\n\
    \x03\x07A\x03\x12\x04\xc0\x02%'\n\x0b\n\x03\x07A\x08\x12\x04\xc0\x02(?\n\
    \x0b\n\x03\x07A\x07\x12\x04\xc0\x023>\n\x0c\n\x02\x07B\x12\x06\xc1\x02\
    \x02\xc2\x02>\n\x0b\n\x03\x07B\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\
    \x07B\x04\x12\x04\xc1\x02\x02\n\n\x0b\n\x03\x07B\x06\x12\x04\xc1\x02\x0b\
    .\n\x0b\n\x03\x07B\x01\x12\x04\xc2\x02\x04!\n\x0b\n\x03\x07B\x03\x12\x04\
    \xc2\x02$&\n\x0b\n\x03\x07B\x08\x12\x04\xc2\x02'=\n\x0b\n\x03\x07B\x07\
    \x12\x04\xc2\x022<\n\x0c\n\x02\x07C\x12\x06\xc4\x02\x02\xc5\x02F\n\x0b\n\
    \x03\x07C\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07C\x04\x12\x04\xc4\
    \x02\x02\n\n\x0b\n\x03\x07C\x05\x12\x04\xc4\x02\x0b\x11\n\x0b\n\x03\x07C\
    \x01\x12\x04\xc4\x02\x120\n\x0b\n\x03\x07C\x03\x12\x04\xc4\x0235\n\r\n\
    \x03\x07C\x08\x12\x06\xc4\x026\xc5\x02E\n\x0c\n\x04\x07C\x08\x01\x12\x04\
    \xc4\x027I\n\x0b\n\x03\x07C\x07\x12\x04\xc5\x02?D\n\n\n\x02\x07D\x12\x04\
    \xc6\x02\x02J\n\x0b\n\x03\x07D\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\
    \x07D\x04\x12\x04\xc6\x02\x02\n\n\x0b\n\x03\x07D\x05\x12\x04\xc6\x02\x0b\
    \x11\n\x0b\n\x03\x07D\x01\x12\x04\xc6\x02\x12(\n\x0b\n\x03\x07D\x03\x12\
    \x04\xc6\x02+-\n\x0b\n\x03\x07D\x08\x12\x04\xc6\x02.I\n\x0c\n\x04\x07D\
    \x08\x01\x12\x04\xc6\x02/9\n\x0b\n\x03\x07D\x07\x12\x04\xc6\x02CH\n\x1c\
    \n\x02\x07E\x12\x04\xc9\x02\x02/\x1a\x10\x20For\x20oneof\x20test\n\n\x0b\
    \n\x03\x07E\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07E\x04\x12\x04\xc9\
    \x02\x02\n\n\x0b\n\x03\x07E\x05\x12\x04\xc9\x02\x0b\x11\n\x0b\n\x03\x07E\
    \x01\x12\x04\xc9\x02\x12(\n\x0b\n\x03\x07E\x03\x12\x04\xc9\x02+.\n\n\n\
    \x02\x07F\x12\x04\xca\x02\x02K\n\x0b\n\x03\x07F\x02\x12\x04\xda\x01\x07\
    \x18\n\x0b\n\x03\x07F\x04\x12\x04\xca\x02\x02\n\n\x0b\n\x03\x07F\x06\x12\
    \x04\xca\x02\x0b%\n\x0b\n\x03\x07F\x01\x12\x04\xca\x02&D\n\x0b\n\x03\x07\
    F\x03\x12\x04\xca\x02GJ\n\n\n\x02\x07G\x12\x04\xcb\x02\x02/\n\x0b\n\x03\
    \x07G\x02\x12\x04\xda\x01\x07\x18\n\x0b\n\x03\x07G\x04\x12\x04\xcb\x02\
    \x02\n\n\x0b\n\x03\x07G\x05\x12\x04\xcb\x02\x0b\x11\n\x0b\n\x03\x07G\x01\
    \x12\x04\xcb\x02\x12(\n\x0b\n\x03\x07G\x03\x12\x04\xcb\x02+.\n\n\n\x02\
    \x07H\x12\x04\xcc\x02\x02-\n\x0b\n\x03\x07H\x02\x12\x04\xda\x01\x07\x18\
    \n\x0b\n\x03\x07H\x04\x12\x04\xcc\x02\x02\n\n\x0b\n\x03\x07H\x05\x12\x04\
    \xcc\x02\x0b\x10\n\x0b\n\x03\x07H\x01\x12\x04\xcc\x02\x11&\n\x0b\n\x03\
    \x07H\x03\x12\x04\xcc\x02),\n\x0c\n\x02\x04\x06\x12\x06\xcf\x02\0\xd8\
    \x02\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\xcf\x02\x08\x1b\n\r\n\x03\x04\
    \x06\x06\x12\x06\xd0\x02\x02\xd7\x02\x03\n`\n\x04\x04\x06\x06\0\x12\x04\
    \xd3\x02\x041\x1aR\x20Check\x20for\x20bug\x20where\x20string\x20extensio\
    ns\x20declared\x20in\x20tested\x20scope\x20did\x20not\n\x20compile.\n\n\
    \r\n\x05\x04\x06\x06\0\x02\x12\x04\xd0\x02\t\x1a\n\r\n\x05\x04\x06\x06\0\
    \x04\x12\x04\xd3\x02\x04\x0c\n\r\n\x05\x04\x06\x06\0\x05\x12\x04\xd3\x02\
    \r\x13\n\r\n\x05\x04\x06\x06\0\x01\x12\x04\xd3\x02\x14\x18\n\r\n\x05\x04\
    \x06\x06\0\x03\x12\x04\xd3\x02\x1b\x1f\n\r\n\x05\x04\x06\x06\0\x08\x12\
    \x04\xd3\x02\x200\n\r\n\x05\x04\x06\x06\0\x07\x12\x04\xd3\x02)/\n`\n\x04\
    \x04\x06\x06\x01\x12\x04\xd6\x02\x043\x1aR\x20Used\x20to\x20test\x20if\
    \x20generated\x20extension\x20name\x20is\x20correct\x20when\x20there\x20\
    are\n\x20underscores.\n\n\r\n\x05\x04\x06\x06\x01\x02\x12\x04\xd0\x02\t\
    \x1a\n\r\n\x05\x04\x06\x06\x01\x04\x12\x04\xd6\x02\x04\x0c\n\r\n\x05\x04\
    \x06\x06\x01\x05\x12\x04\xd6\x02\r\x13\n\r\n\x05\x04\x06\x06\x01\x01\x12\
    \x04\xd6\x02\x14+\n\r\n\x05\x04\x06\x06\x01\x03\x12\x04\xd6\x02.2\n\xc0\
    \x02\n\x02\x04\x07\x12\x06\xdf\x02\0\x8a\x03\x01\x1a\xb1\x02\x20We\x20ha\
    ve\x20separate\x20messages\x20for\x20testing\x20required\x20fields\x20be\
    cause\x20it's\n\x20annoying\x20to\x20have\x20to\x20fill\x20in\x20require\
    d\x20fields\x20in\x20TestProto\x20in\x20order\x20to\n\x20do\x20anything\
    \x20with\x20it.\x20\x20Note\x20that\x20we\x20don't\x20need\x20to\x20test\
    \x20every\x20type\x20of\n\x20required\x20filed\x20because\x20the\x20code\
    \x20output\x20is\x20basically\x20identical\x20to\n\x20optional\x20fields\
    \x20for\x20all\x20types.\n\n\x0b\n\x03\x04\x07\x01\x12\x04\xdf\x02\x08\
    \x14\n\x0c\n\x04\x04\x07\x02\0\x12\x04\xe0\x02\x02\x17\n\r\n\x05\x04\x07\
    \x02\0\x04\x12\x04\xe0\x02\x02\n\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\xe0\
    \x02\x0b\x10\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xe0\x02\x11\x12\n\r\n\
    \x05\x04\x07\x02\0\x03\x12\x04\xe0\x02\x15\x16\n\x0c\n\x04\x04\x07\x02\
    \x01\x12\x04\xe1\x02\x02\x1c\n\r\n\x05\x04\x07\x02\x01\x04\x12\x04\xe1\
    \x02\x02\n\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\xe1\x02\x0b\x10\n\r\n\
    \x05\x04\x07\x02\x01\x01\x12\x04\xe1\x02\x11\x17\n\r\n\x05\x04\x07\x02\
    \x01\x03\x12\x04\xe1\x02\x1a\x1b\n\x0c\n\x04\x04\x07\x02\x02\x12\x04\xe2\
    \x02\x02\x17\n\r\n\x05\x04\x07\x02\x02\x04\x12\x04\xe2\x02\x02\n\n\r\n\
    \x05\x04\x07\x02\x02\x05\x12\x04\xe2\x02\x0b\x10\n\r\n\x05\x04\x07\x02\
    \x02\x01\x12\x04\xe2\x02\x11\x12\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\
    \xe2\x02\x15\x16\n\r\n\x03\x04\x07\x06\x12\x06\xe4\x02\x02\xe7\x02\x03\n\
    \x0c\n\x04\x04\x07\x06\0\x12\x04\xe5\x02\x04(\n\r\n\x05\x04\x07\x06\0\
    \x02\x12\x04\xe4\x02\t\x1a\n\r\n\x05\x04\x07\x06\0\x04\x12\x04\xe5\x02\
    \x04\x0c\n\r\n\x05\x04\x07\x06\0\x06\x12\x04\xe5\x02\r\x19\n\r\n\x05\x04\
    \x07\x06\0\x01\x12\x04\xe5\x02\x1a\x20\n\r\n\x05\x04\x07\x06\0\x03\x12\
    \x04\xe5\x02#'\n\x0c\n\x04\x04\x07\x06\x01\x12\x04\xe6\x02\x04(\n\r\n\
    \x05\x04\x07\x06\x01\x02\x12\x04\xe4\x02\t\x1a\n\r\n\x05\x04\x07\x06\x01\
    \x04\x12\x04\xe6\x02\x04\x0c\n\r\n\x05\x04\x07\x06\x01\x06\x12\x04\xe6\
    \x02\r\x19\n\r\n\x05\x04\x07\x06\x01\x01\x12\x04\xe6\x02\x1a\x1f\n\r\n\
    \x05\x04\x07\x06\x01\x03\x12\x04\xe6\x02#'\n\x83\x01\n\x04\x04\x07\x02\
    \x03\x12\x04\xeb\x02\x02\x1e\x1au\x20Pad\x20the\x20field\x20count\x20to\
    \x2032\x20so\x20that\x20we\x20can\x20test\x20that\x20IsInitialized()\n\
    \x20properly\x20checks\x20multiple\x20elements\x20of\x20has_bits_.\n\n\r\
    \n\x05\x04\x07\x02\x03\x04\x12\x04\xeb\x02\x02\n\n\r\n\x05\x04\x07\x02\
    \x03\x05\x12\x04\xeb\x02\x0b\x10\n\r\n\x05\x04\x07\x02\x03\x01\x12\x04\
    \xeb\x02\x11\x17\n\r\n\x05\x04\x07\x02\x03\x03\x12\x04\xeb\x02\x1c\x1d\n\
    \x0c\n\x04\x04\x07\x02\x04\x12\x04\xec\x02\x02\x1e\n\r\n\x05\x04\x07\x02\
    \x04\x04\x12\x04\xec\x02\x02\n\n\r\n\x05\x04\x07\x02\x04\x05\x12\x04\xec\
    \x02\x0b\x10\n\r\n\x05\x04\x07\x02\x04\x01\x12\x04\xec\x02\x11\x17\n\r\n\
    \x05\x04\x07\x02\x04\x03\x12\x04\xec\x02\x1c\x1d\n\x0c\n\x04\x04\x07\x02\
    \x05\x12\x04\xed\x02\x02\x1e\n\r\n\x05\x04\x07\x02\x05\x04\x12\x04\xed\
    \x02\x02\n\n\r\n\x05\x04\x07\x02\x05\x05\x12\x04\xed\x02\x0b\x10\n\r\n\
    \x05\x04\x07\x02\x05\x01\x12\x04\xed\x02\x11\x17\n\r\n\x05\x04\x07\x02\
    \x05\x03\x12\x04\xed\x02\x1c\x1d\n\x0c\n\x04\x04\x07\x02\x06\x12\x04\xee\
    \x02\x02\x1e\n\r\n\x05\x04\x07\x02\x06\x04\x12\x04\xee\x02\x02\n\n\r\n\
    \x05\x04\x07\x02\x06\x05\x12\x04\xee\x02\x0b\x10\n\r\n\x05\x04\x07\x02\
    \x06\x01\x12\x04\xee\x02\x11\x17\n\r\n\x05\x04\x07\x02\x06\x03\x12\x04\
    \xee\x02\x1c\x1d\n\x0c\n\x04\x04\x07\x02\x07\x12\x04\xef\x02\x02\x1e\n\r\
    \n\x05\x04\x07\x02\x07\x04\x12\x04\xef\x02\x02\n\n\r\n\x05\x04\x07\x02\
    \x07\x05\x12\x04\xef\x02\x0b\x10\n\r\n\x05\x04\x07\x02\x07\x01\x12\x04\
    \xef\x02\x11\x17\n\r\n\x05\x04\x07\x02\x07\x03\x12\x04\xef\x02\x1c\x1d\n\
    \x0c\n\x04\x04\x07\x02\x08\x12\x04\xf0\x02\x02\x1e\n\r\n\x05\x04\x07\x02\
    \x08\x04\x12\x04\xf0\x02\x02\n\n\r\n\x05\x04\x07\x02\x08\x05\x12\x04\xf0\
    \x02\x0b\x10\n\r\n\x05\x04\x07\x02\x08\x01\x12\x04\xf0\x02\x11\x17\n\r\n\
    \x05\x04\x07\x02\x08\x03\x12\x04\xf0\x02\x1c\x1d\n\x0c\n\x04\x04\x07\x02\
    \t\x12\x04\xf1\x02\x02\x1e\n\r\n\x05\x04\x07\x02\t\x04\x12\x04\xf1\x02\
    \x02\n\n\r\n\x05\x04\x07\x02\t\x05\x12\x04\xf1\x02\x0b\x10\n\r\n\x05\x04\
    \x07\x02\t\x01\x12\x04\xf1\x02\x11\x18\n\r\n\x05\x04\x07\x02\t\x03\x12\
    \x04\xf1\x02\x1b\x1d\n\x0c\n\x04\x04\x07\x02\n\x12\x04\xf2\x02\x02\x1e\n\
    \r\n\x05\x04\x07\x02\n\x04\x12\x04\xf2\x02\x02\n\n\r\n\x05\x04\x07\x02\n\
    \x05\x12\x04\xf2\x02\x0b\x10\n\r\n\x05\x04\x07\x02\n\x01\x12\x04\xf2\x02\
    \x11\x18\n\r\n\x05\x04\x07\x02\n\x03\x12\x04\xf2\x02\x1b\x1d\n\x0c\n\x04\
    \x04\x07\x02\x0b\x12\x04\xf3\x02\x02\x1e\n\r\n\x05\x04\x07\x02\x0b\x04\
    \x12\x04\xf3\x02\x02\n\n\r\n\x05\x04\x07\x02\x0b\x05\x12\x04\xf3\x02\x0b\
    \x10\n\r\n\x05\x04\x07\x02\x0b\x01\x12\x04\xf3\x02\x11\x18\n\r\n\x05\x04\
    \x07\x02\x0b\x03\x12\x04\xf3\x02\x1b\x1d\n\x0c\n\x04\x04\x07\x02\x0c\x12\
    \x04\xf4\x02\x02\x1e\n\r\n\x05\x04\x07\x02\x0c\x04\x12\x04\xf4\x02\x02\n\
    \n\r\n\x05\x04\x07\x02\x0c\x05\x12\x04\xf4\x02\x0b\x10\n\r\n\x05\x04\x07\
    \x02\x0c\x01\x12\x04\xf4\x02\x11\x18\n\r\n\x05\x04\x07\x02\x0c\x03\x12\
    \x04\xf4\x02\x1b\x1d\n\x0c\n\x04\x04\x07\x02\r\x12\x04\xf5\x02\x02\x1e\n\
    \r\n\x05\x04\x07\x02\r\x04\x12\x04\xf5\x02\x02\n\n\r\n\x05\x04\x07\x02\r\
    \x05\x12\x04\xf5\x02\x0b\x10\n\r\n\x05\x04\x07\x02\r\x01\x12\x04\xf5\x02\
    \x11\x18\n\r\n\x05\x04\x07\x02\r\x03\x12\x04\xf5\x02\x1b\x1d\n\x0c\n\x04\
    \x04\x07\x02\x0e\x12\x04\xf6\x02\x02\x1e\n\r\n\x05\x04\x07\x02\x0e\x04\
    \x12\x04\xf6\x02\x02\n\n\r\n\x05\x04\x07\x02\x0e\x05\x12\x04\xf6\x02\x0b\
    \x10\n\r\n\x05\x04\x07\x02\x0e\x01\x12\x04\xf6\x02\x11\x18\n\r\n\x05\x04\
    \x07\x02\x0e\x03\x12\x04\xf6\x02\x1b\x1d\n\x0c\n\x04\x04\x07\x02\x0f\x12\
    \x04\xf7\x02\x02\x1e\n\r\n\x05\x04\x07\x02\x0f\x04\x12\x04\xf7\x02\x02\n\
    \n\r\n\x05\x04\x07\x02\x0f\x05\x12\x04\xf7\x02\x0b\x10\n\r\n\x05\x04\x07\
    \x02\x0f\x01\x12\x04\xf7\x02\x11\x18\n\r\n\x05\x04\x07\x02\x0f\x03\x12\
    \x04\xf7\x02\x1b\x1d\n\x0c\n\x04\x04\x07\x02\x10\x12\x04\xf8\x02\x02\x1e\
    \n\r\n\x05\x04\x07\x02\x10\x04\x12\x04\xf8\x02\x02\n\n\r\n\x05\x04\x07\
    \x02\x10\x05\x12\x04\xf8\x02\x0b\x10\n\r\n\x05\x04\x07\x02\x10\x01\x12\
    \x04\xf8\x02\x11\x18\n\r\n\x05\x04\x07\x02\x10\x03\x12\x04\xf8\x02\x1b\
    \x1d\n\x0c\n\x04\x04\x07\x02\x11\x12\x04\xf9\x02\x02\x1e\n\r\n\x05\x04\
    \x07\x02\x11\x04\x12\x04\xf9\x02\x02\n\n\r\n\x05\x04\x07\x02\x11\x05\x12\
    \x04\xf9\x02\x0b\x10\n\r\n\x05\x04\x07\x02\x11\x01\x12\x04\xf9\x02\x11\
    \x18\n\r\n\x05\x04\x07\x02\x11\x03\x12\x04\xf9\x02\x1b\x1d\n\x0c\n\x04\
    \x04\x07\x02\x12\x12\x04\xfa\x02\x02\x1e\n\r\n\x05\x04\x07\x02\x12\x04\
    \x12\x04\xfa\x02\x02\n\n\r\n\x05\x04\x07\x02\x12\x05\x12\x04\xfa\x02\x0b\
    \x10\n\r\n\x05\x04\x07\x02\x12\x01\x12\x04\xfa\x02\x11\x18\n\r\n\x05\x04\
    \x07\x02\x12\x03\x12\x04\xfa\x02\x1b\x1d\n\x0c\n\x04\x04\x07\x02\x13\x12\
    \x04\xfb\x02\x02\x1e\n\r\n\x05\x04\x07\x02\x13\x04\x12\x04\xfb\x02\x02\n\
    \n\r\n\x05\x04\x07\x02\x13\x05\x12\x04\xfb\x02\x0b\x10\n\r\n\x05\x04\x07\
    \x02\x13\x01\x12\x04\xfb\x02\x11\x18\n\r\n\x05\x04\x07\x02\x13\x03\x12\
    \x04\xfb\x02\x1b\x1d\n\x0c\n\x04\x04\x07\x02\x14\x12\x04\xfc\x02\x02\x1e\
    \n\r\n\x05\x04\x07\x02\x14\x04\x12\x04\xfc\x02\x02\n\n\r\n\x05\x04\x07\
    \x02\x14\x05\x12\x04\xfc\x02\x0b\x10\n\r\n\x05\x04\x07\x02\x14\x01\x12\
    \x04\xfc\x02\x11\x18\n\r\n\x05\x04\x07\x02\x14\x03\x12\x04\xfc\x02\x1b\
    \x1d\n\x0c\n\x04\x04\x07\x02\x15\x12\x04\xfd\x02\x02\x1e\n\r\n\x05\x04\
    \x07\x02\x15\x04\x12\x04\xfd\x02\x02\n\n\r\n\x05\x04\x07\x02\x15\x05\x12\
    \x04\xfd\x02\x0b\x10\n\r\n\x05\x04\x07\x02\x15\x01\x12\x04\xfd\x02\x11\
    \x18\n\r\n\x05\x04\x07\x02\x15\x03\x12\x04\xfd\x02\x1b\x1d\n\x0c\n\x04\
    \x04\x07\x02\x16\x12\x04\xfe\x02\x02\x1e\n\r\n\x05\x04\x07\x02\x16\x04\
    \x12\x04\xfe\x02\x02\n\n\r\n\x05\x04\x07\x02\x16\x05\x12\x04\xfe\x02\x0b\
    \x10\n\r\n\x05\x04\x07\x02\x16\x01\x12\x04\xfe\x02\x11\x18\n\r\n\x05\x04\
    \x07\x02\x16\x03\x12\x04\xfe\x02\x1b\x1d\n\x0c\n\x04\x04\x07\x02\x17\x12\
    \x04\xff\x02\x02\x1e\n\r\n\x05\x04\x07\x02\x17\x04\x12\x04\xff\x02\x02\n\
    \n\r\n\x05\x04\x07\x02\x17\x05\x12\x04\xff\x02\x0b\x10\n\r\n\x05\x04\x07\
    \x02\x17\x01\x12\x04\xff\x02\x11\x18\n\r\n\x05\x04\x07\x02\x17\x03\x12\
    \x04\xff\x02\x1b\x1d\n\x0c\n\x04\x04\x07\x02\x18\x12\x04\x80\x03\x02\x1e\
    \n\r\n\x05\x04\x07\x02\x18\x04\x12\x04\x80\x03\x02\n\n\r\n\x05\x04\x07\
    \x02\x18\x05\x12\x04\x80\x03\x0b\x10\n\r\n\x05\x04\x07\x02\x18\x01\x12\
    \x04\x80\x03\x11\x18\n\r\n\x05\x04\x07\x02\x18\x03\x12\x04\x80\x03\x1b\
    \x1d\n\x0c\n\x04\x04\x07\x02\x19\x12\x04\x81\x03\x02\x1e\n\r\n\x05\x04\
    \x07\x02\x19\x04\x12\x04\x81\x03\x02\n\n\r\n\x05\x04\x07\x02\x19\x05\x12\
    \x04\x81\x03\x0b\x10\n\r\n\x05\x04\x07\x02\x19\x01\x12\x04\x81\x03\x11\
    \x18\n\r\n\x05\x04\x07\x02\x19\x03\x12\x04\x81\x03\x1b\x1d\n\x0c\n\x04\
    \x04\x07\x02\x1a\x12\x04\x82\x03\x02\x1e\n\r\n\x05\x04\x07\x02\x1a\x04\
    \x12\x04\x82\x03\x02\n\n\r\n\x05\x04\x07\x02\x1a\x05\x12\x04\x82\x03\x0b\
    \x10\n\r\n\x05\x04\x07\x02\x1a\x01\x12\x04\x82\x03\x11\x18\n\r\n\x05\x04\
    \x07\x02\x1a\x03\x12\x04\x82\x03\x1b\x1d\n\x0c\n\x04\x04\x07\x02\x1b\x12\
    \x04\x83\x03\x02\x1e\n\r\n\x05\x04\x07\x02\x1b\x04\x12\x04\x83\x03\x02\n\
    \n\r\n\x05\x04\x07\x02\x1b\x05\x12\x04\x83\x03\x0b\x10\n\r\n\x05\x04\x07\
    \x02\x1b\x01\x12\x04\x83\x03\x11\x18\n\r\n\x05\x04\x07\x02\x1b\x03\x12\
    \x04\x83\x03\x1b\x1d\n\x0c\n\x04\x04\x07\x02\x1c\x12\x04\x84\x03\x02\x1e\
    \n\r\n\x05\x04\x07\x02\x1c\x04\x12\x04\x84\x03\x02\n\n\r\n\x05\x04\x07\
    \x02\x1c\x05\x12\x04\x84\x03\x0b\x10\n\r\n\x05\x04\x07\x02\x1c\x01\x12\
    \x04\x84\x03\x11\x18\n\r\n\x05\x04\x07\x02\x1c\x03\x12\x04\x84\x03\x1b\
    \x1d\n\x0c\n\x04\x04\x07\x02\x1d\x12\x04\x85\x03\x02\x1e\n\r\n\x05\x04\
    \x07\x02\x1d\x04\x12\x04\x85\x03\x02\n\n\r\n\x05\x04\x07\x02\x1d\x05\x12\
    \x04\x85\x03\x0b\x10\n\r\n\x05\x04\x07\x02\x1d\x01\x12\x04\x85\x03\x11\
    \x18\n\r\n\x05\x04\x07\x02\x1d\x03\x12\x04\x85\x03\x1b\x1d\n\x0c\n\x04\
    \x04\x07\x02\x1e\x12\x04\x86\x03\x02\x1e\n\r\n\x05\x04\x07\x02\x1e\x04\
    \x12\x04\x86\x03\x02\n\n\r\n\x05\x04\x07\x02\x1e\x05\x12\x04\x86\x03\x0b\
    \x10\n\r\n\x05\x04\x07\x02\x1e\x01\x12\x04\x86\x03\x11\x18\n\r\n\x05\x04\
    \x07\x02\x1e\x03\x12\x04\x86\x03\x1b\x1d\n\x0c\n\x04\x04\x07\x02\x1f\x12\
    \x04\x87\x03\x02\x1e\n\r\n\x05\x04\x07\x02\x1f\x04\x12\x04\x87\x03\x02\n\
    \n\r\n\x05\x04\x07\x02\x1f\x05\x12\x04\x87\x03\x0b\x10\n\r\n\x05\x04\x07\
    \x02\x1f\x01\x12\x04\x87\x03\x11\x18\n\r\n\x05\x04\x07\x02\x1f\x03\x12\
    \x04\x87\x03\x1b\x1d\n\x0c\n\x04\x04\x07\x02\x20\x12\x04\x89\x03\x02\x18\
    \n\r\n\x05\x04\x07\x02\x20\x04\x12\x04\x89\x03\x02\n\n\r\n\x05\x04\x07\
    \x02\x20\x05\x12\x04\x89\x03\x0b\x10\n\r\n\x05\x04\x07\x02\x20\x01\x12\
    \x04\x89\x03\x11\x12\n\r\n\x05\x04\x07\x02\x20\x03\x12\x04\x89\x03\x15\
    \x17\n\x0c\n\x02\x04\x08\x12\x06\x8c\x03\0\x90\x03\x01\n\x0b\n\x03\x04\
    \x08\x01\x12\x04\x8c\x03\x08\x1b\n\x0c\n\x04\x04\x08\x02\0\x12\x04\x8d\
    \x03\x02-\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\x8d\x03\x02\n\n\r\n\x05\
    \x04\x08\x02\0\x06\x12\x04\x8d\x03\x0b\x17\n\r\n\x05\x04\x08\x02\0\x01\
    \x12\x04\x8d\x03\x18(\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\x8d\x03+,\n\
    \x0c\n\x04\x04\x08\x02\x01\x12\x04\x8e\x03\x02-\n\r\n\x05\x04\x08\x02\
    \x01\x04\x12\x04\x8e\x03\x02\n\n\r\n\x05\x04\x08\x02\x01\x06\x12\x04\x8e\
    \x03\x0b\x17\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\x8e\x03\x18(\n\r\n\
    \x05\x04\x08\x02\x01\x03\x12\x04\x8e\x03+,\n\x0c\n\x04\x04\x08\x02\x02\
    \x12\x04\x8f\x03\x02\x1b\n\r\n\x05\x04\x08\x02\x02\x04\x12\x04\x8f\x03\
    \x02\n\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\x8f\x03\x0b\x10\n\r\n\x05\
    \x04\x08\x02\x02\x01\x12\x04\x8f\x03\x11\x16\n\r\n\x05\x04\x08\x02\x02\
    \x03\x12\x04\x8f\x03\x19\x1a\nM\n\x02\x04\t\x12\x06\x93\x03\0\x95\x03\
    \x01\x1a?\x20Test\x20that\x20we\x20can\x20use\x20NestedMessage\x20from\
    \x20outside\x20TestAllTypes.\n\n\x0b\n\x03\x04\t\x01\x12\x04\x93\x03\x08\
    \x19\n\x0c\n\x04\x04\t\x02\0\x12\x04\x94\x03\x029\n\r\n\x05\x04\t\x02\0\
    \x04\x12\x04\x94\x03\x02\n\n\r\n\x05\x04\t\x02\0\x06\x12\x04\x94\x03\x0b\
    %\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x94\x03&4\n\r\n\x05\x04\t\x02\0\x03\
    \x12\x04\x94\x0378\nG\n\x02\x04\n\x12\x06\x98\x03\0\x99\x03\x01\x1a9\x20\
    TestEmptyMessage\x20is\x20used\x20to\x20test\x20unknown\x20field\x20supp\
    ort.\n\n\x0b\n\x03\x04\n\x01\x12\x04\x98\x03\x08\x18\n\x90\x01\n\x02\x04\
    \x0b\x12\x06\x9d\x03\0\x9f\x03\x01\x1a\x81\x01\x20Like\x20above,\x20but\
    \x20declare\x20all\x20field\x20numbers\x20as\x20potential\x20extensions.\
    \x20\x20No\n\x20actual\x20extensions\x20should\x20ever\x20be\x20defined\
    \x20for\x20this\x20type.\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\x9d\x03\x08&\
    \n\x0b\n\x03\x04\x0b\x05\x12\x04\x9e\x03\x02\x16\n\x0c\n\x04\x04\x0b\x05\
    \0\x12\x04\x9e\x03\r\x15\n\r\n\x05\x04\x0b\x05\0\x01\x12\x04\x9e\x03\r\
    \x0e\n\r\n\x05\x04\x0b\x05\0\x02\x12\x04\x9e\x03\x12\x15\n\x0c\n\x02\x04\
    \x0c\x12\x06\xa1\x03\0\xa5\x03\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xa1\
    \x03\x08#\n\x0b\n\x03\x04\x0c\x05\x12\x04\xa2\x03\x02\x10\n\x0c\n\x04\
    \x04\x0c\x05\0\x12\x04\xa2\x03\r\x0f\n\r\n\x05\x04\x0c\x05\0\x01\x12\x04\
    \xa2\x03\r\x0f\n\r\n\x05\x04\x0c\x05\0\x02\x12\x04\xa2\x03\r\x0f\n\x0b\n\
    \x03\x04\x0c\x05\x12\x04\xa3\x03\x02\x1a\n\x0c\n\x04\x04\x0c\x05\x01\x12\
    \x04\xa3\x03\r\x19\n\r\n\x05\x04\x0c\x05\x01\x01\x12\x04\xa3\x03\r\x11\n\
    \r\n\x05\x04\x0c\x05\x01\x02\x12\x04\xa3\x03\x15\x19\n\x0b\n\x03\x04\x0c\
    \x05\x12\x04\xa4\x03\x02\x1a\n\x0c\n\x04\x04\x0c\x05\x02\x12\x04\xa4\x03\
    \r\x19\n\r\n\x05\x04\x0c\x05\x02\x01\x12\x04\xa4\x03\r\x12\n\r\n\x05\x04\
    \x0c\x05\x02\x02\x12\x04\xa4\x03\x16\x19\nH\n\x02\x04\r\x12\x06\xa8\x03\
    \0\xad\x03\x01\x1a:\x20Test\x20that\x20really\x20large\x20tag\x20numbers\
    \x20don't\x20break\x20anything.\n\n\x0b\n\x03\x04\r\x01\x12\x04\xa8\x03\
    \x08\x20\n}\n\x04\x04\r\x02\0\x12\x04\xab\x03\x02\x17\x1ao\x20The\x20lar\
    gest\x20possible\x20tag\x20number\x20is\x202^28\x20-\x201,\x20since\x20t\
    he\x20wire\x20format\x20uses\n\x20three\x20bits\x20to\x20communicate\x20\
    wire\x20type.\n\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xab\x03\x02\n\n\r\n\
    \x05\x04\r\x02\0\x05\x12\x04\xab\x03\x0b\x10\n\r\n\x05\x04\r\x02\0\x01\
    \x12\x04\xab\x03\x11\x12\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xab\x03\x15\
    \x16\n\x0c\n\x04\x04\r\x02\x01\x12\x04\xac\x03\x02\x20\n\r\n\x05\x04\r\
    \x02\x01\x04\x12\x04\xac\x03\x02\n\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\
    \xac\x03\x0b\x10\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xac\x03\x11\x13\n\r\
    \n\x05\x04\r\x02\x01\x03\x12\x04\xac\x03\x16\x1f\n\x0c\n\x02\x04\x0e\x12\
    \x06\xaf\x03\0\xb2\x03\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xaf\x03\x08\
    \x1c\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\xb0\x03\x02&\n\r\n\x05\x04\x0e\
    \x02\0\x04\x12\x04\xb0\x03\x02\n\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\xb0\
    \x03\x0b\x1f\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xb0\x03\x20!\n\r\n\x05\
    \x04\x0e\x02\0\x03\x12\x04\xb0\x03$%\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\
    \xb1\x03\x02\x17\n\r\n\x05\x04\x0e\x02\x01\x04\x12\x04\xb1\x03\x02\n\n\r\
    \n\x05\x04\x0e\x02\x01\x05\x12\x04\xb1\x03\x0b\x10\n\r\n\x05\x04\x0e\x02\
    \x01\x01\x12\x04\xb1\x03\x11\x12\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\
    \xb1\x03\x15\x16\n1\n\x02\x04\x0f\x12\x06\xb5\x03\0\xb7\x03\x01\x1a#\x20\
    Test\x20that\x20mutual\x20recursion\x20works.\n\n\x0b\n\x03\x04\x0f\x01\
    \x12\x04\xb5\x03\x08\x1c\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xb6\x03\x02'\
    \n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\xb6\x03\x02\n\n\r\n\x05\x04\x0f\x02\
    \0\x06\x12\x04\xb6\x03\x0b\x1f\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xb6\
    \x03\x20\"\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xb6\x03%&\n\x0c\n\x02\x04\
    \x10\x12\x06\xb9\x03\0\xbc\x03\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\xb9\
    \x03\x08\x1c\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xba\x03\x02&\n\r\n\x05\
    \x04\x10\x02\0\x04\x12\x04\xba\x03\x02\n\n\r\n\x05\x04\x10\x02\0\x06\x12\
    \x04\xba\x03\x0b\x1f\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xba\x03\x20!\n\
    \r\n\x05\x04\x10\x02\0\x03\x12\x04\xba\x03$%\n\x0c\n\x04\x04\x10\x02\x01\
    \x12\x04\xbb\x03\x02$\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\xbb\x03\x02\
    \n\n\r\n\x05\x04\x10\x02\x01\x05\x12\x04\xbb\x03\x0b\x10\n\r\n\x05\x04\
    \x10\x02\x01\x01\x12\x04\xbb\x03\x11\x1f\n\r\n\x05\x04\x10\x02\x01\x03\
    \x12\x04\xbb\x03\"#\n\x99\x02\n\x02\x04\x11\x12\x06\xc2\x03\0\xc8\x03\
    \x01\x1a\xfd\x01\x20Test\x20that\x20groups\x20have\x20disjoint\x20field\
    \x20numbers\x20from\x20their\x20siblings\x20and\n\x20parents.\x20\x20Thi\
    s\x20is\x20NOT\x20possible\x20in\x20proto1;\x20only\x20google.protobuf.\
    \x20\x20When\x20attempting\n\x20to\x20compile\x20with\x20proto1,\x20this\
    \x20will\x20emit\x20an\x20error;\x20so\x20we\x20only\x20include\x20it\n\
    \x20in\x20protobuf_unittest_proto.\n\"\x0b\x20NO_PROTO1\n\n\x0b\n\x03\
    \x04\x11\x01\x12\x04\xc2\x03\x08\x1a\n\x19\n\x04\x04\x11\x02\0\x12\x04\
    \xc3\x03\x02\x17\"\x0b\x20NO_PROTO1\n\n\r\n\x05\x04\x11\x02\0\x04\x12\
    \x04\xc3\x03\x02\n\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xc3\x03\x0b\x10\n\
    \r\n\x05\x04\x11\x02\0\x01\x12\x04\xc3\x03\x11\x12\n\r\n\x05\x04\x11\x02\
    \0\x03\x12\x04\xc3\x03\x15\x16\n<\n\x02\x04\x12\x12\x06\xcb\x03\0\xcd\
    \x03\x01\x1a.\x20Additional\x20messages\x20for\x20testing\x20lazy\x20fie\
    lds.\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xcb\x03\x08\x18\n\x0c\n\x04\x04\
    \x12\x02\0\x12\x04\xcc\x03\x025\n\r\n\x05\x04\x12\x02\0\x04\x12\x04\xcc\
    \x03\x02\n\n\r\n\x05\x04\x12\x02\0\x06\x12\x04\xcc\x03\x0b\x17\n\r\n\x05\
    \x04\x12\x02\0\x01\x12\x04\xcc\x03\x18#\n\r\n\x05\x04\x12\x02\0\x03\x12\
    \x04\xcc\x03&'\n\r\n\x05\x04\x12\x02\0\x08\x12\x04\xcc\x03(4\n\x0e\n\x06\
    \x04\x12\x02\0\x08\x05\x12\x04\xcc\x03)3\n\x0c\n\x02\x04\x13\x12\x06\xce\
    \x03\0\xd0\x03\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\xce\x03\x08\x17\n\x0c\
    \n\x04\x04\x13\x02\0\x12\x04\xcf\x03\x024\n\r\n\x05\x04\x13\x02\0\x04\
    \x12\x04\xcf\x03\x02\n\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\xcf\x03\x0b\
    \x17\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xcf\x03\x18#\n\r\n\x05\x04\x13\
    \x02\0\x03\x12\x04\xcf\x03&'\n\r\n\x05\x04\x13\x02\0\x08\x12\x04\xcf\x03\
    (3\n\x0e\n\x06\x04\x13\x02\0\x08\x05\x12\x04\xcf\x03)2\n)\n\x02\x04\x14\
    \x12\x06\xd3\x03\0\xd9\x03\x01\x1a\x1b\x20Needed\x20for\x20a\x20Python\
    \x20test.\n\n\x0b\n\x03\x04\x14\x01\x12\x04\xd3\x03\x08\x20\n\x0e\n\x04\
    \x04\x14\x03\0\x12\x06\xd4\x03\x02\xd7\x03\x03\n\r\n\x05\x04\x14\x03\0\
    \x01\x12\x04\xd4\x03\n\x17\n\x0e\n\x06\x04\x14\x03\0\x02\0\x12\x04\xd5\
    \x03\x044\n\x0f\n\x07\x04\x14\x03\0\x02\0\x04\x12\x04\xd5\x03\x04\x0c\n\
    \x0f\n\x07\x04\x14\x03\0\x02\0\x05\x12\x04\xd5\x03\r\x12\n\x0f\n\x07\x04\
    \x14\x03\0\x02\0\x01\x12\x04\xd5\x03\x13/\n\x0f\n\x07\x04\x14\x03\0\x02\
    \0\x03\x12\x04\xd5\x0323\n\x0e\n\x06\x04\x14\x03\0\x02\x01\x12\x04\xd6\
    \x03\x04F\n\x0f\n\x07\x04\x14\x03\0\x02\x01\x04\x12\x04\xd6\x03\x04\x0c\
    \n\x0f\n\x07\x04\x14\x03\0\x02\x01\x06\x12\x04\xd6\x03\r\x1b\n\x0f\n\x07\
    \x04\x14\x03\0\x02\x01\x01\x12\x04\xd6\x03\x1cA\n\x0f\n\x07\x04\x14\x03\
    \0\x02\x01\x03\x12\x04\xd6\x03DE\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xd8\
    \x03\x025\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\xd8\x03\x02\n\n\r\n\x05\
    \x04\x14\x02\0\x06\x12\x04\xd8\x03\x0b\x18\n\r\n\x05\x04\x14\x02\0\x01\
    \x12\x04\xd8\x03\x190\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xd8\x0334\nK\n\
    \x02\x05\x01\x12\x06\xdd\x03\0\xe5\x03\x01\x1a=\x20Test\x20an\x20enum\
    \x20that\x20has\x20multiple\x20values\x20with\x20the\x20same\x20number.\
    \n\n\x0b\n\x03\x05\x01\x01\x12\x04\xdd\x03\x05\x19\n\x0b\n\x03\x05\x01\
    \x03\x12\x04\xde\x03\x02\x1c\n\x0c\n\x04\x05\x01\x03\x02\x12\x04\xde\x03\
    \x02\x1c\n\x0c\n\x04\x05\x01\x02\0\x12\x04\xe0\x03\x02\x0b\n\r\n\x05\x05\
    \x01\x02\0\x01\x12\x04\xe0\x03\x02\x06\n\r\n\x05\x05\x01\x02\0\x02\x12\
    \x04\xe0\x03\t\n\n\x0c\n\x04\x05\x01\x02\x01\x12\x04\xe1\x03\x02\x0b\n\r\
    \n\x05\x05\x01\x02\x01\x01\x12\x04\xe1\x03\x02\x06\n\r\n\x05\x05\x01\x02\
    \x01\x02\x12\x04\xe1\x03\t\n\n\x0c\n\x04\x05\x01\x02\x02\x12\x04\xe2\x03\
    \x02\n\n\r\n\x05\x05\x01\x02\x02\x01\x12\x04\xe2\x03\x02\x05\n\r\n\x05\
    \x05\x01\x02\x02\x02\x12\x04\xe2\x03\x08\t\n\x0c\n\x04\x05\x01\x02\x03\
    \x12\x04\xe3\x03\x02\x0b\n\r\n\x05\x05\x01\x02\x03\x01\x12\x04\xe3\x03\
    \x02\x06\n\r\n\x05\x05\x01\x02\x03\x02\x12\x04\xe3\x03\t\n\n\x0c\n\x04\
    \x05\x01\x02\x04\x12\x04\xe4\x03\x02\x0b\n\r\n\x05\x05\x01\x02\x04\x01\
    \x12\x04\xe4\x03\x02\x06\n\r\n\x05\x05\x01\x02\x04\x02\x12\x04\xe4\x03\t\
    \n\n:\n\x02\x05\x02\x12\x06\xe8\x03\0\xf0\x03\x01\x1a,\x20Test\x20an\x20\
    enum\x20with\x20large,\x20unordered\x20values.\n\n\x0b\n\x03\x05\x02\x01\
    \x12\x04\xe8\x03\x05\x13\n\x0c\n\x04\x05\x02\x02\0\x12\x04\xe9\x03\x02\
    \x11\n\r\n\x05\x05\x02\x02\0\x01\x12\x04\xe9\x03\x02\n\n\r\n\x05\x05\x02\
    \x02\0\x02\x12\x04\xe9\x03\r\x10\n\x0c\n\x04\x05\x02\x02\x01\x12\x04\xea\
    \x03\x02\x13\n\r\n\x05\x05\x02\x02\x01\x01\x12\x04\xea\x03\x02\n\n\r\n\
    \x05\x05\x02\x02\x01\x02\x12\x04\xea\x03\r\x12\n\x0c\n\x04\x05\x02\x02\
    \x02\x12\x04\xeb\x03\x02\x16\n\r\n\x05\x05\x02\x02\x02\x01\x12\x04\xeb\
    \x03\x02\n\n\r\n\x05\x05\x02\x02\x02\x02\x12\x04\xeb\x03\r\x15\n\x0c\n\
    \x04\x05\x02\x02\x03\x12\x04\xec\x03\x02\x11\n\r\n\x05\x05\x02\x02\x03\
    \x01\x12\x04\xec\x03\x02\n\n\r\n\x05\x05\x02\x02\x03\x02\x12\x04\xec\x03\
    \r\x10\n\x0c\n\x04\x05\x02\x02\x04\x12\x04\xed\x03\x02\x14\n\r\n\x05\x05\
    \x02\x02\x04\x01\x12\x04\xed\x03\x02\n\n\r\n\x05\x05\x02\x02\x04\x02\x12\
    \x04\xed\x03\r\x13\n\x0c\n\x04\x05\x02\x02\x05\x12\x04\xee\x03\x02\x0f\n\
    \r\n\x05\x05\x02\x02\x05\x01\x12\x04\xee\x03\x02\n\n\r\n\x05\x05\x02\x02\
    \x05\x02\x12\x04\xee\x03\r\x0e\n\x0c\n\x04\x05\x02\x02\x06\x12\x04\xef\
    \x03\x02\x0f\n\r\n\x05\x05\x02\x02\x06\x01\x12\x04\xef\x03\x02\n\n\r\n\
    \x05\x05\x02\x02\x06\x02\x12\x04\xef\x03\r\x0e\nh\n\x02\x04\x15\x12\x06\
    \xf4\x03\0\x82\x04\x01\x1aZ\x20Test\x20message\x20with\x20CamelCase\x20f\
    ield\x20names.\x20\x20This\x20violates\x20Protocol\x20Buffer\n\x20standa\
    rd\x20style.\n\n\x0b\n\x03\x04\x15\x01\x12\x04\xf4\x03\x08\x1f\n\x0c\n\
    \x04\x04\x15\x02\0\x12\x04\xf5\x03\x02$\n\r\n\x05\x04\x15\x02\0\x04\x12\
    \x04\xf5\x03\x02\n\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xf5\x03\x0b\x10\n\
    \r\n\x05\x04\x15\x02\0\x01\x12\x04\xf5\x03\x11\x1f\n\r\n\x05\x04\x15\x02\
    \0\x03\x12\x04\xf5\x03\"#\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\xf6\x03\
    \x02\"\n\r\n\x05\x04\x15\x02\x01\x04\x12\x04\xf6\x03\x02\n\n\r\n\x05\x04\
    \x15\x02\x01\x05\x12\x04\xf6\x03\x0b\x11\n\r\n\x05\x04\x15\x02\x01\x01\
    \x12\x04\xf6\x03\x12\x1d\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xf6\x03\
    \x20!\n\x0c\n\x04\x04\x15\x02\x02\x12\x04\xf7\x03\x02%\n\r\n\x05\x04\x15\
    \x02\x02\x04\x12\x04\xf7\x03\x02\n\n\r\n\x05\x04\x15\x02\x02\x06\x12\x04\
    \xf7\x03\x0b\x16\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\xf7\x03\x17\x20\n\
    \r\n\x05\x04\x15\x02\x02\x03\x12\x04\xf7\x03#$\n\x0c\n\x04\x04\x15\x02\
    \x03\x12\x04\xf8\x03\x02+\n\r\n\x05\x04\x15\x02\x03\x04\x12\x04\xf8\x03\
    \x02\n\n\r\n\x05\x04\x15\x02\x03\x06\x12\x04\xf8\x03\x0b\x19\n\r\n\x05\
    \x04\x15\x02\x03\x01\x12\x04\xf8\x03\x1a&\n\r\n\x05\x04\x15\x02\x03\x03\
    \x12\x04\xf8\x03)*\n\x0c\n\x04\x04\x15\x02\x04\x12\x04\xf9\x03\x02<\n\r\
    \n\x05\x04\x15\x02\x04\x04\x12\x04\xf9\x03\x02\n\n\r\n\x05\x04\x15\x02\
    \x04\x05\x12\x04\xf9\x03\x0b\x11\n\r\n\x05\x04\x15\x02\x04\x01\x12\x04\
    \xf9\x03\x12\"\n\r\n\x05\x04\x15\x02\x04\x03\x12\x04\xf9\x03%&\n\r\n\x05\
    \x04\x15\x02\x04\x08\x12\x04\xf9\x03';\n\x0e\n\x06\x04\x15\x02\x04\x08\
    \x01\x12\x04\xf9\x03(:\n\x0c\n\x04\x04\x15\x02\x05\x12\x04\xfa\x03\x02-\
    \n\r\n\x05\x04\x15\x02\x05\x04\x12\x04\xfa\x03\x02\n\n\r\n\x05\x04\x15\
    \x02\x05\x05\x12\x04\xfa\x03\x0b\x11\n\r\n\x05\x04\x15\x02\x05\x01\x12\
    \x04\xfa\x03\x12\x1b\n\r\n\x05\x04\x15\x02\x05\x03\x12\x04\xfa\x03\x1e\
    \x1f\n\r\n\x05\x04\x15\x02\x05\x08\x12\x04\xfa\x03\x20,\n\x0e\n\x06\x04\
    \x15\x02\x05\x08\x01\x12\x04\xfa\x03!+\n\x0c\n\x04\x04\x15\x02\x06\x12\
    \x04\xfc\x03\x02,\n\r\n\x05\x04\x15\x02\x06\x04\x12\x04\xfc\x03\x02\n\n\
    \r\n\x05\x04\x15\x02\x06\x05\x12\x04\xfc\x03\x0b\x10\n\r\n\x05\x04\x15\
    \x02\x06\x01\x12\x04\xfc\x03\x11'\n\r\n\x05\x04\x15\x02\x06\x03\x12\x04\
    \xfc\x03*+\n\x0c\n\x04\x04\x15\x02\x07\x12\x04\xfd\x03\x02*\n\r\n\x05\
    \x04\x15\x02\x07\x04\x12\x04\xfd\x03\x02\n\n\r\n\x05\x04\x15\x02\x07\x05\
    \x12\x04\xfd\x03\x0b\x11\n\r\n\x05\x04\x15\x02\x07\x01\x12\x04\xfd\x03\
    \x12%\n\r\n\x05\x04\x15\x02\x07\x03\x12\x04\xfd\x03()\n\x0c\n\x04\x04\
    \x15\x02\x08\x12\x04\xfe\x03\x02-\n\r\n\x05\x04\x15\x02\x08\x04\x12\x04\
    \xfe\x03\x02\n\n\r\n\x05\x04\x15\x02\x08\x06\x12\x04\xfe\x03\x0b\x16\n\r\
    \n\x05\x04\x15\x02\x08\x01\x12\x04\xfe\x03\x17(\n\r\n\x05\x04\x15\x02\
    \x08\x03\x12\x04\xfe\x03+,\n\x0c\n\x04\x04\x15\x02\t\x12\x04\xff\x03\x02\
    4\n\r\n\x05\x04\x15\x02\t\x04\x12\x04\xff\x03\x02\n\n\r\n\x05\x04\x15\
    \x02\t\x06\x12\x04\xff\x03\x0b\x19\n\r\n\x05\x04\x15\x02\t\x01\x12\x04\
    \xff\x03\x1a.\n\r\n\x05\x04\x15\x02\t\x03\x12\x04\xff\x0313\n\x0c\n\x04\
    \x04\x15\x02\n\x12\x04\x80\x04\x02E\n\r\n\x05\x04\x15\x02\n\x04\x12\x04\
    \x80\x04\x02\n\n\r\n\x05\x04\x15\x02\n\x05\x12\x04\x80\x04\x0b\x11\n\r\n\
    \x05\x04\x15\x02\n\x01\x12\x04\x80\x04\x12*\n\r\n\x05\x04\x15\x02\n\x03\
    \x12\x04\x80\x04-/\n\r\n\x05\x04\x15\x02\n\x08\x12\x04\x80\x040D\n\x0e\n\
    \x06\x04\x15\x02\n\x08\x01\x12\x04\x80\x041C\n\x0c\n\x04\x04\x15\x02\x0b\
    \x12\x04\x81\x04\x026\n\r\n\x05\x04\x15\x02\x0b\x04\x12\x04\x81\x04\x02\
    \n\n\r\n\x05\x04\x15\x02\x0b\x05\x12\x04\x81\x04\x0b\x11\n\r\n\x05\x04\
    \x15\x02\x0b\x01\x12\x04\x81\x04\x12#\n\r\n\x05\x04\x15\x02\x0b\x03\x12\
    \x04\x81\x04&(\n\r\n\x05\x04\x15\x02\x0b\x08\x12\x04\x81\x04)5\n\x0e\n\
    \x06\x04\x15\x02\x0b\x08\x01\x12\x04\x81\x04*4\n\x8b\x01\n\x02\x04\x16\
    \x12\x06\x87\x04\0\x96\x04\x01\x1a}\x20We\x20list\x20fields\x20out\x20of\
    \x20order,\x20to\x20ensure\x20that\x20we're\x20using\x20field\x20number\
    \x20and\x20not\n\x20field\x20index\x20to\x20determine\x20serialization\
    \x20order.\n\n\x0b\n\x03\x04\x16\x01\x12\x04\x87\x04\x08\x1a\n\x0c\n\x04\
    \x04\x16\x02\0\x12\x04\x88\x04\x02!\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\
    \x88\x04\x02\n\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\x88\x04\x0b\x11\n\r\n\
    \x05\x04\x16\x02\0\x01\x12\x04\x88\x04\x12\x1b\n\r\n\x05\x04\x16\x02\0\
    \x03\x12\x04\x88\x04\x1e\x20\n\x0b\n\x03\x04\x16\x05\x12\x04\x89\x04\x02\
    \x15\n\x0c\n\x04\x04\x16\x05\0\x12\x04\x89\x04\r\x14\n\r\n\x05\x04\x16\
    \x05\0\x01\x12\x04\x89\x04\r\x0e\n\r\n\x05\x04\x16\x05\0\x02\x12\x04\x89\
    \x04\x12\x14\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\x8a\x04\x02\x1c\n\r\n\
    \x05\x04\x16\x02\x01\x04\x12\x04\x8a\x04\x02\n\n\r\n\x05\x04\x16\x02\x01\
    \x05\x12\x04\x8a\x04\x0b\x10\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\x8a\
    \x04\x11\x17\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\x8a\x04\x1a\x1b\n\x0b\
    \n\x03\x04\x16\x05\x12\x04\x8b\x04\x02\x17\n\x0c\n\x04\x04\x16\x05\x01\
    \x12\x04\x8b\x04\r\x16\n\r\n\x05\x04\x16\x05\x01\x01\x12\x04\x8b\x04\r\
    \x0f\n\r\n\x05\x04\x16\x05\x01\x02\x12\x04\x8b\x04\x13\x16\n\x0c\n\x04\
    \x04\x16\x02\x02\x12\x04\x8c\x04\x02\x20\n\r\n\x05\x04\x16\x02\x02\x04\
    \x12\x04\x8c\x04\x02\n\n\r\n\x05\x04\x16\x02\x02\x05\x12\x04\x8c\x04\x0b\
    \x10\n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\x8c\x04\x11\x19\n\r\n\x05\x04\
    \x16\x02\x02\x03\x12\x04\x8c\x04\x1c\x1f\n\x0e\n\x04\x04\x16\x03\0\x12\
    \x06\x8d\x04\x02\x93\x04\x03\n\r\n\x05\x04\x16\x03\0\x01\x12\x04\x8d\x04\
    \n\x17\n\x0e\n\x06\x04\x16\x03\0\x02\0\x12\x04\x8e\x04\x04\x1a\n\x0f\n\
    \x07\x04\x16\x03\0\x02\0\x04\x12\x04\x8e\x04\x04\x0c\n\x0f\n\x07\x04\x16\
    \x03\0\x02\0\x05\x12\x04\x8e\x04\r\x12\n\x0f\n\x07\x04\x16\x03\0\x02\0\
    \x01\x12\x04\x8e\x04\x13\x15\n\x0f\n\x07\x04\x16\x03\0\x02\0\x03\x12\x04\
    \x8e\x04\x18\x19\n\xe4\x01\n\x06\x04\x16\x03\0\x02\x01\x12\x04\x92\x04\
    \x04\x1a\x1a\xd3\x01\x20The\x20field\x20name\x20\"b\"\x20fails\x20to\x20\
    compile\x20in\x20proto1\x20because\x20it\x20conflicts\x20with\n\x20a\x20\
    local\x20variable\x20named\x20\"b\"\x20in\x20one\x20of\x20the\x20generat\
    ed\x20methods.\x20\x20Doh.\n\x20This\x20file\x20needs\x20to\x20compile\
    \x20in\x20proto1\x20to\x20test\x20backwards-compatibility.\n\n\x0f\n\x07\
    \x04\x16\x03\0\x02\x01\x04\x12\x04\x92\x04\x04\x0c\n\x0f\n\x07\x04\x16\
    \x03\0\x02\x01\x05\x12\x04\x92\x04\r\x12\n\x0f\n\x07\x04\x16\x03\0\x02\
    \x01\x01\x12\x04\x92\x04\x13\x15\n\x0f\n\x07\x04\x16\x03\0\x02\x01\x03\
    \x12\x04\x92\x04\x18\x19\n\x0c\n\x04\x04\x16\x02\x03\x12\x04\x95\x04\x02\
    8\n\r\n\x05\x04\x16\x02\x03\x04\x12\x04\x95\x04\x02\n\n\r\n\x05\x04\x16\
    \x02\x03\x06\x12\x04\x95\x04\x0b\x18\n\r\n\x05\x04\x16\x02\x03\x01\x12\
    \x04\x95\x04\x190\n\r\n\x05\x04\x16\x02\x03\x03\x12\x04\x95\x0447\n\x0b\
    \n\x01\x07\x12\x06\x99\x04\0\x9c\x04\x01\n\n\n\x02\x07I\x12\x04\x9a\x04\
    \x02+\n\x0b\n\x03\x07I\x02\x12\x04\x99\x04\x07\x19\n\x0b\n\x03\x07I\x04\
    \x12\x04\x9a\x04\x02\n\n\x0b\n\x03\x07I\x05\x12\x04\x9a\x04\x0b\x11\n\
    \x0b\n\x03\x07I\x01\x12\x04\x9a\x04\x12%\n\x0b\n\x03\x07I\x03\x12\x04\
    \x9a\x04(*\n\n\n\x02\x07J\x12\x04\x9b\x04\x02&\n\x0b\n\x03\x07J\x02\x12\
    \x04\x99\x04\x07\x19\n\x0b\n\x03\x07J\x04\x12\x04\x9b\x04\x02\n\n\x0b\n\
    \x03\x07J\x05\x12\x04\x9b\x04\x0b\x10\n\x0b\n\x03\x07J\x01\x12\x04\x9b\
    \x04\x11!\n\x0b\n\x03\x07J\x03\x12\x04\x9b\x04$%\n\x0c\n\x02\x04\x17\x12\
    \x06\x9f\x04\0\xd2\x04\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\x9f\x04\x08\
    \x20\n^\n\x04\x04\x17\x02\0\x12\x04\xa3\x04\x02:\x1aP\noptional\x20bytes\
    \x20escaped_bytes\x20=\x201\x20[default\x20=\x20\"\\0\\001\\a\\b\\f\\n\\\
    r\\t\\v\\\\\\'\\\"\\xfe\"];\n\n\r\n\x05\x04\x17\x02\0\x04\x12\x04\xa3\
    \x04\x02\n\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xa3\x04\x0b\x11\n\r\n\x05\
    \x04\x17\x02\0\x01\x12\x04\xa3\x04\x12\x1e\n\r\n\x05\x04\x17\x02\0\x03\
    \x12\x04\xa3\x04!\"\n\r\n\x05\x04\x17\x02\0\x08\x12\x04\xa3\x04#9\n\r\n\
    \x05\x04\x17\x02\0\x07\x12\x04\xa3\x04.8\n\x0c\n\x04\x04\x17\x02\x01\x12\
    \x04\xa4\x04\x02B\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\xa4\x04\x02\n\n\
    \r\n\x05\x04\x17\x02\x01\x05\x12\x04\xa4\x04\x0b\x11\n\r\n\x05\x04\x17\
    \x02\x01\x01\x12\x04\xa4\x04\x12\x1e\n\r\n\x05\x04\x17\x02\x01\x03\x12\
    \x04\xa4\x04!\"\n\r\n\x05\x04\x17\x02\x01\x08\x12\x04\xa4\x04#A\n\r\n\
    \x05\x04\x17\x02\x01\x07\x12\x04\xa4\x04.@\n\x0c\n\x04\x04\x17\x02\x02\
    \x12\x04\xa5\x04\x02;\n\r\n\x05\x04\x17\x02\x02\x04\x12\x04\xa5\x04\x02\
    \n\n\r\n\x05\x04\x17\x02\x02\x05\x12\x04\xa5\x04\x0c\x11\n\r\n\x05\x04\
    \x17\x02\x02\x01\x12\x04\xa5\x04\x12\x1d\n\r\n\x05\x04\x17\x02\x02\x03\
    \x12\x04\xa5\x04!\"\n\r\n\x05\x04\x17\x02\x02\x08\x12\x04\xa5\x04#:\n\r\
    \n\x05\x04\x17\x02\x02\x07\x12\x04\xa5\x04.9\n\x0c\n\x04\x04\x17\x02\x03\
    \x12\x04\xa6\x04\x02C\n\r\n\x05\x04\x17\x02\x03\x04\x12\x04\xa6\x04\x02\
    \n\n\r\n\x05\x04\x17\x02\x03\x05\x12\x04\xa6\x04\x0c\x11\n\r\n\x05\x04\
    \x17\x02\x03\x01\x12\x04\xa6\x04\x12\x1d\n\r\n\x05\x04\x17\x02\x03\x03\
    \x12\x04\xa6\x04!\"\n\r\n\x05\x04\x17\x02\x03\x08\x12\x04\xa6\x04#B\n\r\
    \n\x05\x04\x17\x02\x03\x07\x12\x04\xa6\x04.A\n\x0c\n\x04\x04\x17\x02\x04\
    \x12\x04\xa7\x04\x02B\n\r\n\x05\x04\x17\x02\x04\x04\x12\x04\xa7\x04\x02\
    \n\n\r\n\x05\x04\x17\x02\x04\x05\x12\x04\xa7\x04\x0c\x11\n\r\n\x05\x04\
    \x17\x02\x04\x01\x12\x04\xa7\x04\x12$\n\r\n\x05\x04\x17\x02\x04\x03\x12\
    \x04\xa7\x04')\n\r\n\x05\x04\x17\x02\x04\x08\x12\x04\xa7\x04*A\n\r\n\x05\
    \x04\x17\x02\x04\x07\x12\x04\xa7\x045@\n\x0c\n\x04\x04\x17\x02\x05\x12\
    \x04\xa8\x04\x02J\n\r\n\x05\x04\x17\x02\x05\x04\x12\x04\xa8\x04\x02\n\n\
    \r\n\x05\x04\x17\x02\x05\x05\x12\x04\xa8\x04\x0c\x11\n\r\n\x05\x04\x17\
    \x02\x05\x01\x12\x04\xa8\x04\x12$\n\r\n\x05\x04\x17\x02\x05\x03\x12\x04\
    \xa8\x04')\n\r\n\x05\x04\x17\x02\x05\x08\x12\x04\xa8\x04*I\n\r\n\x05\x04\
    \x17\x02\x05\x07\x12\x04\xa8\x045H\n\xdd\x01\n\x04\x04\x17\x02\x06\x12\
    \x04\xad\x04\x02=\x1a\xce\x01\x20The\x20default\x20value\x20here\x20is\
    \x20UTF-8\x20for\x20\"\\u1234\".\x20\x20(We\x20could\x20also\x20just\x20\
    type\n\x20the\x20UTF-8\x20text\x20directly\x20into\x20this\x20text\x20fi\
    le\x20rather\x20than\x20escape\x20it,\x20but\n\x20lots\x20of\x20people\
    \x20use\x20editors\x20that\x20would\x20be\x20confused\x20by\x20this.)\n\
    \n\r\n\x05\x04\x17\x02\x06\x04\x12\x04\xad\x04\x02\n\n\r\n\x05\x04\x17\
    \x02\x06\x05\x12\x04\xad\x04\x0b\x11\n\r\n\x05\x04\x17\x02\x06\x01\x12\
    \x04\xad\x04\x12\x1d\n\r\n\x05\x04\x17\x02\x06\x03\x12\x04\xad\x04\x20!\
    \n\r\n\x05\x04\x17\x02\x06\x08\x12\x04\xad\x04\"<\n\r\n\x05\x04\x17\x02\
    \x06\x07\x12\x04\xad\x04-;\nA\n\x04\x04\x17\x02\x07\x12\x04\xb0\x04\x02.\
    \x1a3\x20Tests\x20for\x20single-precision\x20floating-point\x20values.\n\
    \n\r\n\x05\x04\x17\x02\x07\x04\x12\x04\xb0\x04\x02\n\n\r\n\x05\x04\x17\
    \x02\x07\x05\x12\x04\xb0\x04\x0b\x10\n\r\n\x05\x04\x17\x02\x07\x01\x12\
    \x04\xb0\x04\x11\x1b\n\r\n\x05\x04\x17\x02\x07\x03\x12\x04\xb0\x04\x1e\
    \x1f\n\r\n\x05\x04\x17\x02\x07\x08\x12\x04\xb0\x04\x20-\n\r\n\x05\x04\
    \x17\x02\x07\x07\x12\x04\xb0\x04+,\n\x0c\n\x04\x04\x17\x02\x08\x12\x04\
    \xb1\x04\x02-\n\r\n\x05\x04\x17\x02\x08\x04\x12\x04\xb1\x04\x02\n\n\r\n\
    \x05\x04\x17\x02\x08\x05\x12\x04\xb1\x04\x0b\x10\n\r\n\x05\x04\x17\x02\
    \x08\x01\x12\x04\xb1\x04\x11\x1a\n\r\n\x05\x04\x17\x02\x08\x03\x12\x04\
    \xb1\x04\x1d\x1e\n\r\n\x05\x04\x17\x02\x08\x08\x12\x04\xb1\x04\x1f,\n\r\
    \n\x05\x04\x17\x02\x08\x07\x12\x04\xb1\x04*+\n\x0c\n\x04\x04\x17\x02\t\
    \x12\x04\xb2\x04\x021\n\r\n\x05\x04\x17\x02\t\x04\x12\x04\xb2\x04\x02\n\
    \n\r\n\x05\x04\x17\x02\t\x05\x12\x04\xb2\x04\x0b\x10\n\r\n\x05\x04\x17\
    \x02\t\x01\x12\x04\xb2\x04\x11\x1c\n\r\n\x05\x04\x17\x02\t\x03\x12\x04\
    \xb2\x04\x1f\x20\n\r\n\x05\x04\x17\x02\t\x08\x12\x04\xb2\x04!0\n\r\n\x05\
    \x04\x17\x02\t\x07\x12\x04\xb2\x04,/\n\x0c\n\x04\x04\x17\x02\n\x12\x04\
    \xb3\x04\x028\n\r\n\x05\x04\x17\x02\n\x04\x12\x04\xb3\x04\x02\n\n\r\n\
    \x05\x04\x17\x02\n\x05\x12\x04\xb3\x04\x0b\x10\n\r\n\x05\x04\x17\x02\n\
    \x01\x12\x04\xb3\x04\x11#\n\r\n\x05\x04\x17\x02\n\x03\x12\x04\xb3\x04&(\
    \n\r\n\x05\x04\x17\x02\n\x08\x12\x04\xb3\x04)7\n\r\n\x05\x04\x17\x02\n\
    \x07\x12\x04\xb3\x0446\n\x0c\n\x04\x04\x17\x02\x0b\x12\x04\xb4\x04\x026\
    \n\r\n\x05\x04\x17\x02\x0b\x04\x12\x04\xb4\x04\x02\n\n\r\n\x05\x04\x17\
    \x02\x0b\x05\x12\x04\xb4\x04\x0b\x10\n\r\n\x05\x04\x17\x02\x0b\x01\x12\
    \x04\xb4\x04\x11\x1f\n\r\n\x05\x04\x17\x02\x0b\x03\x12\x04\xb4\x04\"$\n\
    \r\n\x05\x04\x17\x02\x0b\x08\x12\x04\xb4\x04%5\n\r\n\x05\x04\x17\x02\x0b\
    \x07\x12\x04\xb4\x0404\n\x1f\n\x04\x04\x17\x02\x0c\x12\x04\xb6\x04\x022\
    \x1a\x11\x20Using\x20exponents\n\n\r\n\x05\x04\x17\x02\x0c\x04\x12\x04\
    \xb6\x04\x02\n\n\r\n\x05\x04\x17\x02\x0c\x05\x12\x04\xb6\x04\x0b\x10\n\r\
    \n\x05\x04\x17\x02\x0c\x01\x12\x04\xb6\x04\x11\x1c\n\r\n\x05\x04\x17\x02\
    \x0c\x03\x12\x04\xb6\x04\x1f!\n\r\n\x05\x04\x17\x02\x0c\x08\x12\x04\xb6\
    \x04\"1\n\r\n\x05\x04\x17\x02\x0c\x07\x12\x04\xb6\x04-0\n\x0c\n\x04\x04\
    \x17\x02\r\x12\x04\xb7\x04\x02>\n\r\n\x05\x04\x17\x02\r\x04\x12\x04\xb7\
    \x04\x02\n\n\r\n\x05\x04\x17\x02\r\x05\x12\x04\xb7\x04\x0b\x10\n\r\n\x05\
    \x04\x17\x02\r\x01\x12\x04\xb7\x04\x11%\n\r\n\x05\x04\x17\x02\r\x03\x12\
    \x04\xb7\x04(*\n\r\n\x05\x04\x17\x02\r\x08\x12\x04\xb7\x04+=\n\r\n\x05\
    \x04\x17\x02\r\x07\x12\x04\xb7\x046<\n\xbe\x04\n\x04\x04\x17\x02\x0e\x12\
    \x04\xc8\x04\x02L\x1a\xd4\x01\x20Tests\x20for\x20C++\x20trigraphs.\n\x20\
    Trigraphs\x20should\x20be\x20escaped\x20in\x20C++\x20generated\x20files,\
    \x20but\x20they\x20should\x20not\x20be\n\x20escaped\x20for\x20other\x20l\
    anguages.\n\x20Note\x20that\x20in\x20.proto\x20file,\x20\"\\?\"\x20is\
    \x20a\x20valid\x20way\x20to\x20escape\x20?\x20in\x20string\n\x20literals\
    .\n2+\x20Text\x20for\x20nonfinite\x20floating-point\x20values.\n2\xab\
    \x02\noptional\x20double\x20inf_double\x20=\x2014\x20[default\x20=\x20in\
    f];\noptional\x20double\x20neg_inf_double\x20=\x2015\x20[default\x20=\
    \x20-inf];\noptional\x20double\x20nan_double\x20=\x2016\x20[default\x20=\
    \x20nan];\noptional\x20float\x20inf_float\x20=\x2017\x20[default\x20=\
    \x20inf];\noptional\x20float\x20neg_inf_float\x20=\x2018\x20[default\x20\
    =\x20-inf];\noptional\x20float\x20nan_float\x20=\x2019\x20[default\x20=\
    \x20nan];\n\n\r\n\x05\x04\x17\x02\x0e\x04\x12\x04\xc8\x04\x02\n\n\r\n\
    \x05\x04\x17\x02\x0e\x05\x12\x04\xc8\x04\x0b\x11\n\r\n\x05\x04\x17\x02\
    \x0e\x01\x12\x04\xc8\x04\x12\x1e\n\r\n\x05\x04\x17\x02\x0e\x03\x12\x04\
    \xc8\x04!#\n\r\n\x05\x04\x17\x02\x0e\x08\x12\x04\xc8\x04$K\n\r\n\x05\x04\
    \x17\x02\x0e\x07\x12\x04\xc8\x04/J\n?\n\x04\x04\x17\x02\x0f\x12\x04\xcb\
    \x04\x02F\x1a1\x20String\x20defaults\x20containing\x20the\x20character\
    \x20'\\000'\n\n\r\n\x05\x04\x17\x02\x0f\x04\x12\x04\xcb\x04\x02\n\n\r\n\
    \x05\x04\x17\x02\x0f\x05\x12\x04\xcb\x04\x0b\x11\n\r\n\x05\x04\x17\x02\
    \x0f\x01\x12\x04\xcb\x04\x12\"\n\r\n\x05\x04\x17\x02\x0f\x03\x12\x04\xcb\
    \x04+-\n\r\n\x05\x04\x17\x02\x0f\x08\x12\x04\xcb\x04.E\n\r\n\x05\x04\x17\
    \x02\x0f\x07\x12\x04\xcb\x049D\n\x0c\n\x04\x04\x17\x02\x10\x12\x04\xcc\
    \x04\x02F\n\r\n\x05\x04\x17\x02\x10\x04\x12\x04\xcc\x04\x02\n\n\r\n\x05\
    \x04\x17\x02\x10\x05\x12\x04\xcc\x04\x0c\x11\n\r\n\x05\x04\x17\x02\x10\
    \x01\x12\x04\xcc\x04\x12!\n\r\n\x05\x04\x17\x02\x10\x03\x12\x04\xcc\x04+\
    -\n\r\n\x05\x04\x17\x02\x10\x08\x12\x04\xcc\x04.E\n\r\n\x05\x04\x17\x02\
    \x10\x07\x12\x04\xcc\x049D\n\x0e\n\x04\x04\x17\x02\x11\x12\x06\xcd\x04\
    \x02\xce\x04B\n\r\n\x05\x04\x17\x02\x11\x04\x12\x04\xcd\x04\x02\n\n\r\n\
    \x05\x04\x17\x02\x11\x05\x12\x04\xcd\x04\x0b\x11\n\r\n\x05\x04\x17\x02\
    \x11\x01\x12\x04\xcd\x04\x12(\n\r\n\x05\x04\x17\x02\x11\x03\x12\x04\xcd\
    \x04+-\n\x0f\n\x05\x04\x17\x02\x11\x08\x12\x06\xcd\x04.\xce\x04A\n\x0e\n\
    \x06\x04\x17\x02\x11\x08\x01\x12\x04\xcd\x04/A\n\r\n\x05\x04\x17\x02\x11\
    \x07\x12\x04\xce\x047@\n\x0e\n\x04\x04\x17\x02\x12\x12\x06\xcf\x04\x02\
    \xd0\x04B\n\r\n\x05\x04\x17\x02\x12\x04\x12\x04\xcf\x04\x02\n\n\r\n\x05\
    \x04\x17\x02\x12\x05\x12\x04\xcf\x04\x0b\x11\n\r\n\x05\x04\x17\x02\x12\
    \x01\x12\x04\xcf\x04\x12\x20\n\r\n\x05\x04\x17\x02\x12\x03\x12\x04\xcf\
    \x04+-\n\x0f\n\x05\x04\x17\x02\x12\x08\x12\x06\xcf\x04.\xd0\x04A\n\x0e\n\
    \x06\x04\x17\x02\x12\x08\x01\x12\x04\xcf\x04/9\n\r\n\x05\x04\x17\x02\x12\
    \x07\x12\x04\xd0\x047@\n\x0c\n\x04\x04\x17\x02\x13\x12\x04\xd1\x04\x02E\
    \n\r\n\x05\x04\x17\x02\x13\x04\x12\x04\xd1\x04\x02\n\n\r\n\x05\x04\x17\
    \x02\x13\x05\x12\x04\xd1\x04\x0b\x11\n\r\n\x05\x04\x17\x02\x13\x01\x12\
    \x04\xd1\x04\x12$\n\r\n\x05\x04\x17\x02\x13\x03\x12\x04\xd1\x04+-\n\r\n\
    \x05\x04\x17\x02\x13\x08\x12\x04\xd1\x04.D\n\r\n\x05\x04\x17\x02\x13\x07\
    \x12\x04\xd1\x047C\n\x0c\n\x02\x04\x18\x12\x06\xd4\x04\0\xd6\x04\x01\n\
    \x0b\n\x03\x04\x18\x01\x12\x04\xd4\x04\x08\x19\n\x0c\n\x04\x04\x18\x02\0\
    \x12\x04\xd5\x04\x02*\n\r\n\x05\x04\x18\x02\0\x04\x12\x04\xd5\x04\x02\n\
    \n\r\n\x05\x04\x18\x02\0\x06\x12\x04\xd5\x04\x0b\x19\n\r\n\x05\x04\x18\
    \x02\0\x01\x12\x04\xd5\x04\x1a%\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xd5\
    \x04()\nH\n\x02\x04\x19\x12\x06\xd9\x04\0\xdb\x04\x01\x1a:\x20Test\x20St\
    ring\x20and\x20Bytes:\x20string\x20is\x20for\x20valid\x20UTF-8\x20string\
    s\n\n\x0b\n\x03\x04\x19\x01\x12\x04\xd9\x04\x08\x11\n\x0c\n\x04\x04\x19\
    \x02\0\x12\x04\xda\x04\x02\x1b\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\xda\
    \x04\x02\n\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\xda\x04\x0b\x11\n\r\n\x05\
    \x04\x19\x02\0\x01\x12\x04\xda\x04\x12\x16\n\r\n\x05\x04\x19\x02\0\x03\
    \x12\x04\xda\x04\x19\x1a\n\x0c\n\x02\x04\x1a\x12\x06\xdd\x04\0\xdf\x04\
    \x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\xdd\x04\x08\x12\n\x0c\n\x04\x04\x1a\
    \x02\0\x12\x04\xde\x04\x02\x1b\n\r\n\x05\x04\x1a\x02\0\x04\x12\x04\xde\
    \x04\x02\n\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xde\x04\x0b\x11\n\r\n\x05\
    \x04\x1a\x02\0\x01\x12\x04\xde\x04\x12\x16\n\r\n\x05\x04\x1a\x02\0\x03\
    \x12\x04\xde\x04\x19\x1a\n\x0c\n\x02\x04\x1b\x12\x06\xe1\x04\0\xe3\x04\
    \x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\xe1\x04\x08\x10\n\x0c\n\x04\x04\x1b\
    \x02\0\x12\x04\xe2\x04\x02\x1a\n\r\n\x05\x04\x1b\x02\0\x04\x12\x04\xe2\
    \x04\x02\n\n\r\n\x05\x04\x1b\x02\0\x05\x12\x04\xe2\x04\x0b\x10\n\r\n\x05\
    \x04\x1b\x02\0\x01\x12\x04\xe2\x04\x11\x15\n\r\n\x05\x04\x1b\x02\0\x03\
    \x12\x04\xe2\x04\x18\x19\n\x0c\n\x02\x04\x1c\x12\x06\xe5\x04\0\xe7\x04\
    \x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\xe5\x04\x08\x11\n\x0c\n\x04\x04\x1c\
    \x02\0\x12\x04\xe6\x04\x02\x1a\n\r\n\x05\x04\x1c\x02\0\x04\x12\x04\xe6\
    \x04\x02\n\n\r\n\x05\x04\x1c\x02\0\x05\x12\x04\xe6\x04\x0b\x10\n\r\n\x05\
    \x04\x1c\x02\0\x01\x12\x04\xe6\x04\x11\x15\n\r\n\x05\x04\x1c\x02\0\x03\
    \x12\x04\xe6\x04\x18\x19\nN\n\x02\x04\x1d\x12\x06\xea\x04\0\xec\x04\x01\
    \x1a@\x20Test\x20int32,\x20uint32,\x20int64,\x20uint64,\x20and\x20bool\
    \x20are\x20all\x20compatible\n\n\x0b\n\x03\x04\x1d\x01\x12\x04\xea\x04\
    \x08\x14\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xeb\x04\x02\x1a\n\r\n\x05\x04\
    \x1d\x02\0\x04\x12\x04\xeb\x04\x02\n\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\
    \xeb\x04\x0b\x10\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xeb\x04\x11\x15\n\r\
    \n\x05\x04\x1d\x02\0\x03\x12\x04\xeb\x04\x18\x19\n\x0c\n\x02\x04\x1e\x12\
    \x06\xee\x04\0\xf0\x04\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\xee\x04\x08\
    \x15\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xef\x04\x02\x1b\n\r\n\x05\x04\x1e\
    \x02\0\x04\x12\x04\xef\x04\x02\n\n\r\n\x05\x04\x1e\x02\0\x05\x12\x04\xef\
    \x04\x0b\x11\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xef\x04\x12\x16\n\r\n\
    \x05\x04\x1e\x02\0\x03\x12\x04\xef\x04\x19\x1a\n\x0c\n\x02\x04\x1f\x12\
    \x06\xf2\x04\0\xf4\x04\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\xf2\x04\x08\
    \x14\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\xf3\x04\x02\x1a\n\r\n\x05\x04\x1f\
    \x02\0\x04\x12\x04\xf3\x04\x02\n\n\r\n\x05\x04\x1f\x02\0\x05\x12\x04\xf3\
    \x04\x0b\x10\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\xf3\x04\x11\x15\n\r\n\
    \x05\x04\x1f\x02\0\x03\x12\x04\xf3\x04\x18\x19\n\x0c\n\x02\x04\x20\x12\
    \x06\xf6\x04\0\xf8\x04\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\xf6\x04\x08\
    \x15\n\x0c\n\x04\x04\x20\x02\0\x12\x04\xf7\x04\x02\x1b\n\r\n\x05\x04\x20\
    \x02\0\x04\x12\x04\xf7\x04\x02\n\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\xf7\
    \x04\x0b\x11\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xf7\x04\x12\x16\n\r\n\
    \x05\x04\x20\x02\0\x03\x12\x04\xf7\x04\x19\x1a\n\x0c\n\x02\x04!\x12\x06\
    \xfa\x04\0\xfc\x04\x01\n\x0b\n\x03\x04!\x01\x12\x04\xfa\x04\x08\x13\n\
    \x0c\n\x04\x04!\x02\0\x12\x04\xfb\x04\x02\x19\n\r\n\x05\x04!\x02\0\x04\
    \x12\x04\xfb\x04\x02\n\n\r\n\x05\x04!\x02\0\x05\x12\x04\xfb\x04\x0b\x0f\
    \n\r\n\x05\x04!\x02\0\x01\x12\x04\xfb\x04\x10\x14\n\r\n\x05\x04!\x02\0\
    \x03\x12\x04\xfb\x04\x17\x18\n\x1c\n\x02\x04\"\x12\x06\xff\x04\0\x8b\x05\
    \x01\x1a\x0e\x20Test\x20oneofs.\n\n\x0b\n\x03\x04\"\x01\x12\x04\xff\x04\
    \x08\x11\n\x0e\n\x04\x04\"\x08\0\x12\x06\x80\x05\x02\x8a\x05\x03\n\r\n\
    \x05\x04\"\x08\0\x01\x12\x04\x80\x05\x08\x0b\n\x0c\n\x04\x04\"\x02\0\x12\
    \x04\x81\x05\x04\x16\n\r\n\x05\x04\"\x02\0\x05\x12\x04\x81\x05\x04\t\n\r\
    \n\x05\x04\"\x02\0\x01\x12\x04\x81\x05\n\x11\n\r\n\x05\x04\"\x02\0\x03\
    \x12\x04\x81\x05\x14\x15\n\x0c\n\x04\x04\"\x02\x01\x12\x04\x82\x05\x04\
    \x1a\n\r\n\x05\x04\"\x02\x01\x05\x12\x04\x82\x05\x04\n\n\r\n\x05\x04\"\
    \x02\x01\x01\x12\x04\x82\x05\x0b\x15\n\r\n\x05\x04\"\x02\x01\x03\x12\x04\
    \x82\x05\x18\x19\nS\n\x04\x04\"\x02\x02\x12\x04\x83\x05\x04!\"E\ngroup\
    \x20FooGroup\x20=\x204\x20{\noptional\x20int32\x20a\x20=\x205;\noptional\
    \x20string\x20b\x20=\x206;\n}\n\n\r\n\x05\x04\"\x02\x02\x06\x12\x04\x83\
    \x05\x04\x10\n\r\n\x05\x04\"\x02\x02\x01\x12\x04\x83\x05\x11\x1c\n\r\n\
    \x05\x04\"\x02\x02\x03\x12\x04\x83\x05\x1f\x20\n\x0c\n\x02\x04#\x12\x06\
    \x8d\x05\0\x97\x05\x01\n\x0b\n\x03\x04#\x01\x12\x04\x8d\x05\x08$\n\x0c\n\
    \x04\x04#\x02\0\x12\x04\x8e\x05\x02\x1d\n\r\n\x05\x04#\x02\0\x04\x12\x04\
    \x8e\x05\x02\n\n\r\n\x05\x04#\x02\0\x05\x12\x04\x8e\x05\x0b\x10\n\r\n\
    \x05\x04#\x02\0\x01\x12\x04\x8e\x05\x11\x18\n\r\n\x05\x04#\x02\0\x03\x12\
    \x04\x8e\x05\x1b\x1c\n\x0c\n\x04\x04#\x02\x01\x12\x04\x8f\x05\x02!\n\r\n\
    \x05\x04#\x02\x01\x04\x12\x04\x8f\x05\x02\n\n\r\n\x05\x04#\x02\x01\x05\
    \x12\x04\x8f\x05\x0b\x11\n\r\n\x05\x04#\x02\x01\x01\x12\x04\x8f\x05\x12\
    \x1c\n\r\n\x05\x04#\x02\x01\x03\x12\x04\x8f\x05\x1f\x20\n\\\n\x04\x04#\
    \x02\x02\x12\x04\x90\x05\x02(\"N\noptional\x20group\x20FooGroup\x20=\x20\
    4\x20{\noptional\x20int32\x20a\x20=\x205;\noptional\x20string\x20b\x20=\
    \x206;\n}\n\n\r\n\x05\x04#\x02\x02\x04\x12\x04\x90\x05\x02\n\n\r\n\x05\
    \x04#\x02\x02\x06\x12\x04\x90\x05\x0b\x17\n\r\n\x05\x04#\x02\x02\x01\x12\
    \x04\x90\x05\x18#\n\r\n\x05\x04#\x02\x02\x03\x12\x04\x90\x05&'\n\x0c\n\
    \x02\x04$\x12\x06\x99\x05\0\xc3\x05\x01\n\x0b\n\x03\x04$\x01\x12\x04\x99\
    \x05\x08\x12\n\x0e\n\x04\x04$\x08\0\x12\x06\x9a\x05\x02\xa9\x05\x03\n\r\
    \n\x05\x04$\x08\0\x01\x12\x04\x9a\x05\x08\x0b\n\x0c\n\x04\x04$\x02\0\x12\
    \x04\x9b\x05\x04\x16\n\r\n\x05\x04$\x02\0\x05\x12\x04\x9b\x05\x04\t\n\r\
    \n\x05\x04$\x02\0\x01\x12\x04\x9b\x05\n\x11\n\r\n\x05\x04$\x02\0\x03\x12\
    \x04\x9b\x05\x14\x15\n\x0c\n\x04\x04$\x02\x01\x12\x04\x9c\x05\x04\x1a\n\
    \r\n\x05\x04$\x02\x01\x05\x12\x04\x9c\x05\x04\n\n\r\n\x05\x04$\x02\x01\
    \x01\x12\x04\x9c\x05\x0b\x15\n\r\n\x05\x04$\x02\x01\x03\x12\x04\x9c\x05\
    \x18\x19\n\x0c\n\x04\x04$\x02\x02\x12\x04\x9d\x05\x04%\n\r\n\x05\x04$\
    \x02\x02\x05\x12\x04\x9d\x05\x04\n\n\r\n\x05\x04$\x02\x02\x01\x12\x04\
    \x9d\x05\x0b\x13\n\r\n\x05\x04$\x02\x02\x03\x12\x04\x9d\x05\x16\x17\n\r\
    \n\x05\x04$\x02\x02\x08\x12\x04\x9d\x05\x18$\n\x0e\n\x06\x04$\x02\x02\
    \x08\x01\x12\x04\x9d\x05\x19#\n\x0c\n\x04\x04$\x02\x03\x12\x04\x9e\x05\
    \x045\n\r\n\x05\x04$\x02\x03\x05\x12\x04\x9e\x05\x04\n\n\r\n\x05\x04$\
    \x02\x03\x01\x12\x04\x9e\x05\x0b\x1b\n\r\n\x05\x04$\x02\x03\x03\x12\x04\
    \x9e\x05\x1e\x1f\n\r\n\x05\x04$\x02\x03\x08\x12\x04\x9e\x05\x204\n\x0e\n\
    \x06\x04$\x02\x03\x08\x01\x12\x04\x9e\x05!3\n\x0c\n\x04\x04$\x02\x04\x12\
    \x04\x9f\x05\x04\x18\n\r\n\x05\x04$\x02\x04\x05\x12\x04\x9f\x05\x04\t\n\
    \r\n\x05\x04$\x02\x04\x01\x12\x04\x9f\x05\n\x13\n\r\n\x05\x04$\x02\x04\
    \x03\x12\x04\x9f\x05\x16\x17\n\x0c\n\x04\x04$\x02\x05\x12\x04\xa0\x05\
    \x04\x1c\n\r\n\x05\x04$\x02\x05\x06\x12\x04\xa0\x05\x04\x0e\n\r\n\x05\
    \x04$\x02\x05\x01\x12\x04\xa0\x05\x0f\x17\n\r\n\x05\x04$\x02\x05\x03\x12\
    \x04\xa0\x05\x1a\x1b\n\x0c\n\x04\x04$\x02\x06\x12\x04\xa1\x05\x04\"\n\r\
    \n\x05\x04$\x02\x06\x06\x12\x04\xa1\x05\x04\x11\n\r\n\x05\x04$\x02\x06\
    \x01\x12\x04\xa1\x05\x12\x1d\n\r\n\x05\x04$\x02\x06\x03\x12\x04\xa1\x05\
    \x20!\nT\n\x04\x04$\x02\x07\x12\x04\xa8\x05\x044\x1aF\ngroup\x20FooGroup\
    \x20=\x208\x20{\noptional\x20int32\x20a\x20=\x209;\noptional\x20string\
    \x20b\x20=\x2010;\n}\n\n\r\n\x05\x04$\x02\x07\x06\x12\x04\xa8\x05\x04\
    \x11\n\r\n\x05\x04$\x02\x07\x01\x12\x04\xa8\x05\x12\"\n\r\n\x05\x04$\x02\
    \x07\x03\x12\x04\xa8\x05%'\n\r\n\x05\x04$\x02\x07\x08\x12\x04\xa8\x05(3\
    \n\x0e\n\x06\x04$\x02\x07\x08\x05\x12\x04\xa8\x05)2\n\x0e\n\x04\x04$\x08\
    \x01\x12\x06\xab\x05\x02\xb4\x05\x03\n\r\n\x05\x04$\x08\x01\x01\x12\x04\
    \xab\x05\x08\x0b\n\x0c\n\x04\x04$\x02\x08\x12\x04\xac\x05\x04%\n\r\n\x05\
    \x04$\x02\x08\x05\x12\x04\xac\x05\x04\t\n\r\n\x05\x04$\x02\x08\x01\x12\
    \x04\xac\x05\n\x11\n\r\n\x05\x04$\x02\x08\x03\x12\x04\xac\x05\x14\x16\n\
    \r\n\x05\x04$\x02\x08\x08\x12\x04\xac\x05\x17$\n\r\n\x05\x04$\x02\x08\
    \x07\x12\x04\xac\x05\"#\n\xe3\x01\n\x04\x04$\x02\t\x12\x04\xb3\x05\x04-\
    \x1a\xd4\x01\nstring\x20bar_string\x20=\x2013\x20[default\x20=\x20\"STRI\
    NG\"];\nstring\x20bar_cord\x20=\x2014\x20[ctype=CORD,\x20default\x20=\
    \x20\"CORD\"];\nstring\x20bar_string_piece\x20=\x2015\x20[ctype=STRING_P\
    IECE,\x20default\x20=\x20\"SPIECE\"];\nbytes\x20bar_bytes\x20=\x2016\x20\
    [default\x20=\x20\"BYTES\"];\n\n\r\n\x05\x04$\x02\t\x06\x12\x04\xb3\x05\
    \x04\x0e\n\r\n\x05\x04$\x02\t\x01\x12\x04\xb3\x05\x0f\x17\n\r\n\x05\x04$\
    \x02\t\x03\x12\x04\xb3\x05\x1a\x1c\n\r\n\x05\x04$\x02\t\x08\x12\x04\xb3\
    \x05\x1d,\n\r\n\x05\x04$\x02\t\x07\x12\x04\xb3\x05(+\n\x0c\n\x04\x04$\
    \x02\n\x12\x04\xb6\x05\x02\x1e\n\r\n\x05\x04$\x02\n\x04\x12\x04\xb6\x05\
    \x02\n\n\r\n\x05\x04$\x02\n\x05\x12\x04\xb6\x05\x0b\x10\n\r\n\x05\x04$\
    \x02\n\x01\x12\x04\xb6\x05\x11\x18\n\r\n\x05\x04$\x02\n\x03\x12\x04\xb6\
    \x05\x1b\x1d\n\x0c\n\x04\x04$\x02\x0b\x12\x04\xb7\x05\x024\n\r\n\x05\x04\
    $\x02\x0b\x04\x12\x04\xb7\x05\x02\n\n\r\n\x05\x04$\x02\x0b\x05\x12\x04\
    \xb7\x05\x0b\x11\n\r\n\x05\x04$\x02\x0b\x01\x12\x04\xb7\x05\x12\x1c\n\r\
    \n\x05\x04$\x02\x0b\x03\x12\x04\xb7\x05\x1f!\n\r\n\x05\x04$\x02\x0b\x08\
    \x12\x04\xb7\x05\"3\n\r\n\x05\x04$\x02\x0b\x07\x12\x04\xb7\x05-2\n\x0e\n\
    \x04\x04$\x03\0\x12\x06\xb9\x05\x02\xbc\x05\x03\n\r\n\x05\x04$\x03\0\x01\
    \x12\x04\xb9\x05\n\x17\n\x0e\n\x06\x04$\x03\0\x02\0\x12\x04\xba\x05\x04\
    \x1f\n\x0f\n\x07\x04$\x03\0\x02\0\x04\x12\x04\xba\x05\x04\x0c\n\x0f\n\
    \x07\x04$\x03\0\x02\0\x05\x12\x04\xba\x05\r\x12\n\x0f\n\x07\x04$\x03\0\
    \x02\0\x01\x12\x04\xba\x05\x13\x1a\n\x0f\n\x07\x04$\x03\0\x02\0\x03\x12\
    \x04\xba\x05\x1d\x1e\n\x0e\n\x06\x04$\x03\0\x02\x01\x12\x04\xbb\x05\x04!\
    \n\x0f\n\x07\x04$\x03\0\x02\x01\x04\x12\x04\xbb\x05\x04\x0c\n\x0f\n\x07\
    \x04$\x03\0\x02\x01\x05\x12\x04\xbb\x05\r\x12\n\x0f\n\x07\x04$\x03\0\x02\
    \x01\x01\x12\x04\xbb\x05\x13\x1c\n\x0f\n\x07\x04$\x03\0\x02\x01\x03\x12\
    \x04\xbb\x05\x1f\x20\n\x0e\n\x04\x04$\x04\0\x12\x06\xbe\x05\x02\xc2\x05\
    \x03\n\r\n\x05\x04$\x04\0\x01\x12\x04\xbe\x05\x07\x11\n\x0e\n\x06\x04$\
    \x04\0\x02\0\x12\x04\xbf\x05\x04\x0c\n\x0f\n\x07\x04$\x04\0\x02\0\x01\
    \x12\x04\xbf\x05\x04\x07\n\x0f\n\x07\x04$\x04\0\x02\0\x02\x12\x04\xbf\
    \x05\n\x0b\n\x0e\n\x06\x04$\x04\0\x02\x01\x12\x04\xc0\x05\x04\x0c\n\x0f\
    \n\x07\x04$\x04\0\x02\x01\x01\x12\x04\xc0\x05\x04\x07\n\x0f\n\x07\x04$\
    \x04\0\x02\x01\x02\x12\x04\xc0\x05\n\x0b\n\x0e\n\x06\x04$\x04\0\x02\x02\
    \x12\x04\xc1\x05\x04\x0c\n\x0f\n\x07\x04$\x04\0\x02\x02\x01\x12\x04\xc1\
    \x05\x04\x07\n\x0f\n\x07\x04$\x04\0\x02\x02\x02\x12\x04\xc1\x05\n\x0b\n\
    \x0c\n\x02\x04%\x12\x06\xc5\x05\0\xce\x05\x01\n\x0b\n\x03\x04%\x01\x12\
    \x04\xc5\x05\x08\x19\n\x0e\n\x04\x04%\x08\0\x12\x06\xc6\x05\x02\xca\x05\
    \x03\n\r\n\x05\x04%\x08\0\x01\x12\x04\xc6\x05\x08\x0b\n\x0c\n\x04\x04%\
    \x02\0\x12\x04\xc7\x05\x04\x16\n\r\n\x05\x04%\x02\0\x05\x12\x04\xc7\x05\
    \x04\t\n\r\n\x05\x04%\x02\0\x01\x12\x04\xc7\x05\n\x11\n\r\n\x05\x04%\x02\
    \0\x03\x12\x04\xc7\x05\x14\x15\n\x0c\n\x04\x04%\x02\x01\x12\x04\xc8\x05\
    \x04\x1a\n\r\n\x05\x04%\x02\x01\x05\x12\x04\xc8\x05\x04\n\n\r\n\x05\x04%\
    \x02\x01\x01\x12\x04\xc8\x05\x0b\x15\n\r\n\x05\x04%\x02\x01\x03\x12\x04\
    \xc8\x05\x18\x19\n\x0c\n\x04\x04%\x02\x02\x12\x04\xc9\x05\x04\"\n\r\n\
    \x05\x04%\x02\x02\x06\x12\x04\xc9\x05\x04\x11\n\r\n\x05\x04%\x02\x02\x01\
    \x12\x04\xc9\x05\x12\x1d\n\r\n\x05\x04%\x02\x02\x03\x12\x04\xc9\x05\x20!\
    \n\x0e\n\x04\x04%\x03\0\x12\x06\xcb\x05\x02\xcd\x05\x03\n\r\n\x05\x04%\
    \x03\0\x01\x12\x04\xcb\x05\n\x17\n\x0e\n\x06\x04%\x03\0\x02\0\x12\x04\
    \xcc\x05\x04(\n\x0f\n\x07\x04%\x03\0\x02\0\x04\x12\x04\xcc\x05\x04\x0c\n\
    \x0f\n\x07\x04%\x03\0\x02\0\x05\x12\x04\xcc\x05\r\x13\n\x0f\n\x07\x04%\
    \x03\0\x02\0\x01\x12\x04\xcc\x05\x14#\n\x0f\n\x07\x04%\x03\0\x02\0\x03\
    \x12\x04\xcc\x05&'\n/\n\x02\x04&\x12\x06\xd3\x05\0\xe2\x05\x012!\x20Test\
    \x20messages\x20for\x20packed\x20fields\n\n\x0b\n\x03\x04&\x01\x12\x04\
    \xd3\x05\x08\x17\n\x0c\n\x04\x04&\x02\0\x12\x04\xd4\x05\x02:\n\r\n\x05\
    \x04&\x02\0\x04\x12\x04\xd4\x05\x02\n\n\r\n\x05\x04&\x02\0\x05\x12\x04\
    \xd4\x05\x0e\x13\n\r\n\x05\x04&\x02\0\x01\x12\x04\xd4\x05\x14\x20\n\r\n\
    \x05\x04&\x02\0\x03\x12\x04\xd4\x05')\n\r\n\x05\x04&\x02\0\x08\x12\x04\
    \xd4\x05*9\n\x0e\n\x06\x04&\x02\0\x08\x02\x12\x04\xd4\x05+8\n\x0c\n\x04\
    \x04&\x02\x01\x12\x04\xd5\x05\x02:\n\r\n\x05\x04&\x02\x01\x04\x12\x04\
    \xd5\x05\x02\n\n\r\n\x05\x04&\x02\x01\x05\x12\x04\xd5\x05\x0e\x13\n\r\n\
    \x05\x04&\x02\x01\x01\x12\x04\xd5\x05\x14\x20\n\r\n\x05\x04&\x02\x01\x03\
    \x12\x04\xd5\x05')\n\r\n\x05\x04&\x02\x01\x08\x12\x04\xd5\x05*9\n\x0e\n\
    \x06\x04&\x02\x01\x08\x02\x12\x04\xd5\x05+8\n\x0c\n\x04\x04&\x02\x02\x12\
    \x04\xd6\x05\x02:\n\r\n\x05\x04&\x02\x02\x04\x12\x04\xd6\x05\x02\n\n\r\n\
    \x05\x04&\x02\x02\x05\x12\x04\xd6\x05\r\x13\n\r\n\x05\x04&\x02\x02\x01\
    \x12\x04\xd6\x05\x14!\n\r\n\x05\x04&\x02\x02\x03\x12\x04\xd6\x05')\n\r\n\
    \x05\x04&\x02\x02\x08\x12\x04\xd6\x05*9\n\x0e\n\x06\x04&\x02\x02\x08\x02\
    \x12\x04\xd6\x05+8\n\x0c\n\x04\x04&\x02\x03\x12\x04\xd7\x05\x02:\n\r\n\
    \x05\x04&\x02\x03\x04\x12\x04\xd7\x05\x02\n\n\r\n\x05\x04&\x02\x03\x05\
    \x12\x04\xd7\x05\r\x13\n\r\n\x05\x04&\x02\x03\x01\x12\x04\xd7\x05\x14!\n\
    \r\n\x05\x04&\x02\x03\x03\x12\x04\xd7\x05')\n\r\n\x05\x04&\x02\x03\x08\
    \x12\x04\xd7\x05*9\n\x0e\n\x06\x04&\x02\x03\x08\x02\x12\x04\xd7\x05+8\n\
    \x0c\n\x04\x04&\x02\x04\x12\x04\xd8\x05\x02:\n\r\n\x05\x04&\x02\x04\x04\
    \x12\x04\xd8\x05\x02\n\n\r\n\x05\x04&\x02\x04\x05\x12\x04\xd8\x05\r\x13\
    \n\r\n\x05\x04&\x02\x04\x01\x12\x04\xd8\x05\x14!\n\r\n\x05\x04&\x02\x04\
    \x03\x12\x04\xd8\x05')\n\r\n\x05\x04&\x02\x04\x08\x12\x04\xd8\x05*9\n\
    \x0e\n\x06\x04&\x02\x04\x08\x02\x12\x04\xd8\x05+8\n\x0c\n\x04\x04&\x02\
    \x05\x12\x04\xd9\x05\x02:\n\r\n\x05\x04&\x02\x05\x04\x12\x04\xd9\x05\x02\
    \n\n\r\n\x05\x04&\x02\x05\x05\x12\x04\xd9\x05\r\x13\n\r\n\x05\x04&\x02\
    \x05\x01\x12\x04\xd9\x05\x14!\n\r\n\x05\x04&\x02\x05\x03\x12\x04\xd9\x05\
    ')\n\r\n\x05\x04&\x02\x05\x08\x12\x04\xd9\x05*9\n\x0e\n\x06\x04&\x02\x05\
    \x08\x02\x12\x04\xd9\x05+8\n\x0c\n\x04\x04&\x02\x06\x12\x04\xda\x05\x02:\
    \n\r\n\x05\x04&\x02\x06\x04\x12\x04\xda\x05\x02\n\n\r\n\x05\x04&\x02\x06\
    \x05\x12\x04\xda\x05\x0c\x13\n\r\n\x05\x04&\x02\x06\x01\x12\x04\xda\x05\
    \x14\"\n\r\n\x05\x04&\x02\x06\x03\x12\x04\xda\x05')\n\r\n\x05\x04&\x02\
    \x06\x08\x12\x04\xda\x05*9\n\x0e\n\x06\x04&\x02\x06\x08\x02\x12\x04\xda\
    \x05+8\n\x0c\n\x04\x04&\x02\x07\x12\x04\xdb\x05\x02:\n\r\n\x05\x04&\x02\
    \x07\x04\x12\x04\xdb\x05\x02\n\n\r\n\x05\x04&\x02\x07\x05\x12\x04\xdb\
    \x05\x0c\x13\n\r\n\x05\x04&\x02\x07\x01\x12\x04\xdb\x05\x14\"\n\r\n\x05\
    \x04&\x02\x07\x03\x12\x04\xdb\x05')\n\r\n\x05\x04&\x02\x07\x08\x12\x04\
    \xdb\x05*9\n\x0e\n\x06\x04&\x02\x07\x08\x02\x12\x04\xdb\x05+8\n\x0c\n\
    \x04\x04&\x02\x08\x12\x04\xdc\x05\x02:\n\r\n\x05\x04&\x02\x08\x04\x12\
    \x04\xdc\x05\x02\n\n\r\n\x05\x04&\x02\x08\x05\x12\x04\xdc\x05\x0b\x13\n\
    \r\n\x05\x04&\x02\x08\x01\x12\x04\xdc\x05\x14#\n\r\n\x05\x04&\x02\x08\
    \x03\x12\x04\xdc\x05')\n\r\n\x05\x04&\x02\x08\x08\x12\x04\xdc\x05*9\n\
    \x0e\n\x06\x04&\x02\x08\x08\x02\x12\x04\xdc\x05+8\n\x0c\n\x04\x04&\x02\t\
    \x12\x04\xdd\x05\x02:\n\r\n\x05\x04&\x02\t\x04\x12\x04\xdd\x05\x02\n\n\r\
    \n\x05\x04&\x02\t\x05\x12\x04\xdd\x05\x0b\x13\n\r\n\x05\x04&\x02\t\x01\
    \x12\x04\xdd\x05\x14#\n\r\n\x05\x04&\x02\t\x03\x12\x04\xdd\x05')\n\r\n\
    \x05\x04&\x02\t\x08\x12\x04\xdd\x05*9\n\x0e\n\x06\x04&\x02\t\x08\x02\x12\
    \x04\xdd\x05+8\n\x0c\n\x04\x04&\x02\n\x12\x04\xde\x05\x02:\n\r\n\x05\x04\
    &\x02\n\x04\x12\x04\xde\x05\x02\n\n\r\n\x05\x04&\x02\n\x05\x12\x04\xde\
    \x05\x0e\x13\n\r\n\x05\x04&\x02\n\x01\x12\x04\xde\x05\x14\x20\n\r\n\x05\
    \x04&\x02\n\x03\x12\x04\xde\x05&)\n\r\n\x05\x04&\x02\n\x08\x12\x04\xde\
    \x05*9\n\x0e\n\x06\x04&\x02\n\x08\x02\x12\x04\xde\x05+8\n\x0c\n\x04\x04&\
    \x02\x0b\x12\x04\xdf\x05\x02:\n\r\n\x05\x04&\x02\x0b\x04\x12\x04\xdf\x05\
    \x02\n\n\r\n\x05\x04&\x02\x0b\x05\x12\x04\xdf\x05\r\x13\n\r\n\x05\x04&\
    \x02\x0b\x01\x12\x04\xdf\x05\x14!\n\r\n\x05\x04&\x02\x0b\x03\x12\x04\xdf\
    \x05&)\n\r\n\x05\x04&\x02\x0b\x08\x12\x04\xdf\x05*9\n\x0e\n\x06\x04&\x02\
    \x0b\x08\x02\x12\x04\xdf\x05+8\n\x0c\n\x04\x04&\x02\x0c\x12\x04\xe0\x05\
    \x02:\n\r\n\x05\x04&\x02\x0c\x04\x12\x04\xe0\x05\x02\n\n\r\n\x05\x04&\
    \x02\x0c\x05\x12\x04\xe0\x05\x0f\x13\n\r\n\x05\x04&\x02\x0c\x01\x12\x04\
    \xe0\x05\x14\x1f\n\r\n\x05\x04&\x02\x0c\x03\x12\x04\xe0\x05&)\n\r\n\x05\
    \x04&\x02\x0c\x08\x12\x04\xe0\x05*9\n\x0e\n\x06\x04&\x02\x0c\x08\x02\x12\
    \x04\xe0\x05+8\n\x0c\n\x04\x04&\x02\r\x12\x04\xe1\x05\x02:\n\r\n\x05\x04\
    &\x02\r\x04\x12\x04\xe1\x05\x02\n\n\r\n\x05\x04&\x02\r\x06\x12\x04\xe1\
    \x05\x0b\x16\n\r\n\x05\x04&\x02\r\x01\x12\x04\xe1\x05\x17\"\n\r\n\x05\
    \x04&\x02\r\x03\x12\x04\xe1\x05&)\n\r\n\x05\x04&\x02\r\x08\x12\x04\xe1\
    \x05*9\n\x0e\n\x06\x04&\x02\r\x08\x02\x12\x04\xe1\x05+8\n\x8d\x01\n\x02\
    \x04'\x12\x06\xe6\x05\0\xf5\x05\x01\x1a\x7f\x20A\x20message\x20with\x20t\
    he\x20same\x20fields\x20as\x20TestPackedTypes,\x20but\x20without\x20pack\
    ing.\x20Used\n\x20to\x20test\x20packed\x20<->\x20unpacked\x20wire\x20com\
    patibility.\n\n\x0b\n\x03\x04'\x01\x12\x04\xe6\x05\x08\x19\n\x0c\n\x04\
    \x04'\x02\0\x12\x04\xe7\x05\x02=\n\r\n\x05\x04'\x02\0\x04\x12\x04\xe7\
    \x05\x02\n\n\r\n\x05\x04'\x02\0\x05\x12\x04\xe7\x05\x0e\x13\n\r\n\x05\
    \x04'\x02\0\x01\x12\x04\xe7\x05\x14\"\n\r\n\x05\x04'\x02\0\x03\x12\x04\
    \xe7\x05)+\n\r\n\x05\x04'\x02\0\x08\x12\x04\xe7\x05,<\n\x0e\n\x06\x04'\
    \x02\0\x08\x02\x12\x04\xe7\x05-;\n\x0c\n\x04\x04'\x02\x01\x12\x04\xe8\
    \x05\x02=\n\r\n\x05\x04'\x02\x01\x04\x12\x04\xe8\x05\x02\n\n\r\n\x05\x04\
    '\x02\x01\x05\x12\x04\xe8\x05\x0e\x13\n\r\n\x05\x04'\x02\x01\x01\x12\x04\
    \xe8\x05\x14\"\n\r\n\x05\x04'\x02\x01\x03\x12\x04\xe8\x05)+\n\r\n\x05\
    \x04'\x02\x01\x08\x12\x04\xe8\x05,<\n\x0e\n\x06\x04'\x02\x01\x08\x02\x12\
    \x04\xe8\x05-;\n\x0c\n\x04\x04'\x02\x02\x12\x04\xe9\x05\x02=\n\r\n\x05\
    \x04'\x02\x02\x04\x12\x04\xe9\x05\x02\n\n\r\n\x05\x04'\x02\x02\x05\x12\
    \x04\xe9\x05\r\x13\n\r\n\x05\x04'\x02\x02\x01\x12\x04\xe9\x05\x14#\n\r\n\
    \x05\x04'\x02\x02\x03\x12\x04\xe9\x05)+\n\r\n\x05\x04'\x02\x02\x08\x12\
    \x04\xe9\x05,<\n\x0e\n\x06\x04'\x02\x02\x08\x02\x12\x04\xe9\x05-;\n\x0c\
    \n\x04\x04'\x02\x03\x12\x04\xea\x05\x02=\n\r\n\x05\x04'\x02\x03\x04\x12\
    \x04\xea\x05\x02\n\n\r\n\x05\x04'\x02\x03\x05\x12\x04\xea\x05\r\x13\n\r\
    \n\x05\x04'\x02\x03\x01\x12\x04\xea\x05\x14#\n\r\n\x05\x04'\x02\x03\x03\
    \x12\x04\xea\x05)+\n\r\n\x05\x04'\x02\x03\x08\x12\x04\xea\x05,<\n\x0e\n\
    \x06\x04'\x02\x03\x08\x02\x12\x04\xea\x05-;\n\x0c\n\x04\x04'\x02\x04\x12\
    \x04\xeb\x05\x02=\n\r\n\x05\x04'\x02\x04\x04\x12\x04\xeb\x05\x02\n\n\r\n\
    \x05\x04'\x02\x04\x05\x12\x04\xeb\x05\r\x13\n\r\n\x05\x04'\x02\x04\x01\
    \x12\x04\xeb\x05\x14#\n\r\n\x05\x04'\x02\x04\x03\x12\x04\xeb\x05)+\n\r\n\
    \x05\x04'\x02\x04\x08\x12\x04\xeb\x05,<\n\x0e\n\x06\x04'\x02\x04\x08\x02\
    \x12\x04\xeb\x05-;\n\x0c\n\x04\x04'\x02\x05\x12\x04\xec\x05\x02=\n\r\n\
    \x05\x04'\x02\x05\x04\x12\x04\xec\x05\x02\n\n\r\n\x05\x04'\x02\x05\x05\
    \x12\x04\xec\x05\r\x13\n\r\n\x05\x04'\x02\x05\x01\x12\x04\xec\x05\x14#\n\
    \r\n\x05\x04'\x02\x05\x03\x12\x04\xec\x05)+\n\r\n\x05\x04'\x02\x05\x08\
    \x12\x04\xec\x05,<\n\x0e\n\x06\x04'\x02\x05\x08\x02\x12\x04\xec\x05-;\n\
    \x0c\n\x04\x04'\x02\x06\x12\x04\xed\x05\x02=\n\r\n\x05\x04'\x02\x06\x04\
    \x12\x04\xed\x05\x02\n\n\r\n\x05\x04'\x02\x06\x05\x12\x04\xed\x05\x0c\
    \x13\n\r\n\x05\x04'\x02\x06\x01\x12\x04\xed\x05\x14$\n\r\n\x05\x04'\x02\
    \x06\x03\x12\x04\xed\x05)+\n\r\n\x05\x04'\x02\x06\x08\x12\x04\xed\x05,<\
    \n\x0e\n\x06\x04'\x02\x06\x08\x02\x12\x04\xed\x05-;\n\x0c\n\x04\x04'\x02\
    \x07\x12\x04\xee\x05\x02=\n\r\n\x05\x04'\x02\x07\x04\x12\x04\xee\x05\x02\
    \n\n\r\n\x05\x04'\x02\x07\x05\x12\x04\xee\x05\x0c\x13\n\r\n\x05\x04'\x02\
    \x07\x01\x12\x04\xee\x05\x14$\n\r\n\x05\x04'\x02\x07\x03\x12\x04\xee\x05\
    )+\n\r\n\x05\x04'\x02\x07\x08\x12\x04\xee\x05,<\n\x0e\n\x06\x04'\x02\x07\
    \x08\x02\x12\x04\xee\x05-;\n\x0c\n\x04\x04'\x02\x08\x12\x04\xef\x05\x02=\
    \n\r\n\x05\x04'\x02\x08\x04\x12\x04\xef\x05\x02\n\n\r\n\x05\x04'\x02\x08\
    \x05\x12\x04\xef\x05\x0b\x13\n\r\n\x05\x04'\x02\x08\x01\x12\x04\xef\x05\
    \x14%\n\r\n\x05\x04'\x02\x08\x03\x12\x04\xef\x05)+\n\r\n\x05\x04'\x02\
    \x08\x08\x12\x04\xef\x05,<\n\x0e\n\x06\x04'\x02\x08\x08\x02\x12\x04\xef\
    \x05-;\n\x0c\n\x04\x04'\x02\t\x12\x04\xf0\x05\x02=\n\r\n\x05\x04'\x02\t\
    \x04\x12\x04\xf0\x05\x02\n\n\r\n\x05\x04'\x02\t\x05\x12\x04\xf0\x05\x0b\
    \x13\n\r\n\x05\x04'\x02\t\x01\x12\x04\xf0\x05\x14%\n\r\n\x05\x04'\x02\t\
    \x03\x12\x04\xf0\x05)+\n\r\n\x05\x04'\x02\t\x08\x12\x04\xf0\x05,<\n\x0e\
    \n\x06\x04'\x02\t\x08\x02\x12\x04\xf0\x05-;\n\x0c\n\x04\x04'\x02\n\x12\
    \x04\xf1\x05\x02=\n\r\n\x05\x04'\x02\n\x04\x12\x04\xf1\x05\x02\n\n\r\n\
    \x05\x04'\x02\n\x05\x12\x04\xf1\x05\x0e\x13\n\r\n\x05\x04'\x02\n\x01\x12\
    \x04\xf1\x05\x14\"\n\r\n\x05\x04'\x02\n\x03\x12\x04\xf1\x05(+\n\r\n\x05\
    \x04'\x02\n\x08\x12\x04\xf1\x05,<\n\x0e\n\x06\x04'\x02\n\x08\x02\x12\x04\
    \xf1\x05-;\n\x0c\n\x04\x04'\x02\x0b\x12\x04\xf2\x05\x02=\n\r\n\x05\x04'\
    \x02\x0b\x04\x12\x04\xf2\x05\x02\n\n\r\n\x05\x04'\x02\x0b\x05\x12\x04\
    \xf2\x05\r\x13\n\r\n\x05\x04'\x02\x0b\x01\x12\x04\xf2\x05\x14#\n\r\n\x05\
    \x04'\x02\x0b\x03\x12\x04\xf2\x05(+\n\r\n\x05\x04'\x02\x0b\x08\x12\x04\
    \xf2\x05,<\n\x0e\n\x06\x04'\x02\x0b\x08\x02\x12\x04\xf2\x05-;\n\x0c\n\
    \x04\x04'\x02\x0c\x12\x04\xf3\x05\x02=\n\r\n\x05\x04'\x02\x0c\x04\x12\
    \x04\xf3\x05\x02\n\n\r\n\x05\x04'\x02\x0c\x05\x12\x04\xf3\x05\x0f\x13\n\
    \r\n\x05\x04'\x02\x0c\x01\x12\x04\xf3\x05\x14!\n\r\n\x05\x04'\x02\x0c\
    \x03\x12\x04\xf3\x05(+\n\r\n\x05\x04'\x02\x0c\x08\x12\x04\xf3\x05,<\n\
    \x0e\n\x06\x04'\x02\x0c\x08\x02\x12\x04\xf3\x05-;\n\x0c\n\x04\x04'\x02\r\
    \x12\x04\xf4\x05\x02=\n\r\n\x05\x04'\x02\r\x04\x12\x04\xf4\x05\x02\n\n\r\
    \n\x05\x04'\x02\r\x06\x12\x04\xf4\x05\x0b\x16\n\r\n\x05\x04'\x02\r\x01\
    \x12\x04\xf4\x05\x17$\n\r\n\x05\x04'\x02\r\x03\x12\x04\xf4\x05(+\n\r\n\
    \x05\x04'\x02\r\x08\x12\x04\xf4\x05,<\n\x0e\n\x06\x04'\x02\r\x08\x02\x12\
    \x04\xf4\x05-;\n\x0c\n\x02\x04(\x12\x06\xf7\x05\0\xf9\x05\x01\n\x0b\n\
    \x03\x04(\x01\x12\x04\xf7\x05\x08\x1c\n\x0b\n\x03\x04(\x05\x12\x04\xf8\
    \x05\x02\x16\n\x0c\n\x04\x04(\x05\0\x12\x04\xf8\x05\r\x15\n\r\n\x05\x04(\
    \x05\0\x01\x12\x04\xf8\x05\r\x0e\n\r\n\x05\x04(\x05\0\x02\x12\x04\xf8\
    \x05\x12\x15\n\x0b\n\x01\x07\x12\x06\xfb\x05\0\x8a\x06\x01\n\n\n\x02\x07\
    K\x12\x04\xfc\x05\x02D\n\x0b\n\x03\x07K\x02\x12\x04\xfb\x05\x07\x1b\n\
    \x0b\n\x03\x07K\x04\x12\x04\xfc\x05\x02\n\n\x0b\n\x03\x07K\x05\x12\x04\
    \xfc\x05\x0e\x13\n\x0b\n\x03\x07K\x01\x12\x04\xfc\x05\x14*\n\x0b\n\x03\
    \x07K\x03\x12\x04\xfc\x0513\n\x0b\n\x03\x07K\x08\x12\x04\xfc\x054C\n\x0c\
    \n\x04\x07K\x08\x02\x12\x04\xfc\x055B\n\n\n\x02\x07L\x12\x04\xfd\x05\x02\
    D\n\x0b\n\x03\x07L\x02\x12\x04\xfb\x05\x07\x1b\n\x0b\n\x03\x07L\x04\x12\
    \x04\xfd\x05\x02\n\n\x0b\n\x03\x07L\x05\x12\x04\xfd\x05\x0e\x13\n\x0b\n\
    \x03\x07L\x01\x12\x04\xfd\x05\x14*\n\x0b\n\x03\x07L\x03\x12\x04\xfd\x051\
    3\n\x0b\n\x03\x07L\x08\x12\x04\xfd\x054C\n\x0c\n\x04\x07L\x08\x02\x12\
    \x04\xfd\x055B\n\n\n\x02\x07M\x12\x04\xfe\x05\x02D\n\x0b\n\x03\x07M\x02\
    \x12\x04\xfb\x05\x07\x1b\n\x0b\n\x03\x07M\x04\x12\x04\xfe\x05\x02\n\n\
    \x0b\n\x03\x07M\x05\x12\x04\xfe\x05\r\x13\n\x0b\n\x03\x07M\x01\x12\x04\
    \xfe\x05\x14+\n\x0b\n\x03\x07M\x03\x12\x04\xfe\x0513\n\x0b\n\x03\x07M\
    \x08\x12\x04\xfe\x054C\n\x0c\n\x04\x07M\x08\x02\x12\x04\xfe\x055B\n\n\n\
    \x02\x07N\x12\x04\xff\x05\x02D\n\x0b\n\x03\x07N\x02\x12\x04\xfb\x05\x07\
    \x1b\n\x0b\n\x03\x07N\x04\x12\x04\xff\x05\x02\n\n\x0b\n\x03\x07N\x05\x12\
    \x04\xff\x05\r\x13\n\x0b\n\x03\x07N\x01\x12\x04\xff\x05\x14+\n\x0b\n\x03\
    \x07N\x03\x12\x04\xff\x0513\n\x0b\n\x03\x07N\x08\x12\x04\xff\x054C\n\x0c\
    \n\x04\x07N\x08\x02\x12\x04\xff\x055B\n\n\n\x02\x07O\x12\x04\x80\x06\x02\
    D\n\x0b\n\x03\x07O\x02\x12\x04\xfb\x05\x07\x1b\n\x0b\n\x03\x07O\x04\x12\
    \x04\x80\x06\x02\n\n\x0b\n\x03\x07O\x05\x12\x04\x80\x06\r\x13\n\x0b\n\
    \x03\x07O\x01\x12\x04\x80\x06\x14+\n\x0b\n\x03\x07O\x03\x12\x04\x80\x061\
    3\n\x0b\n\x03\x07O\x08\x12\x04\x80\x064C\n\x0c\n\x04\x07O\x08\x02\x12\
    \x04\x80\x065B\n\n\n\x02\x07P\x12\x04\x81\x06\x02D\n\x0b\n\x03\x07P\x02\
    \x12\x04\xfb\x05\x07\x1b\n\x0b\n\x03\x07P\x04\x12\x04\x81\x06\x02\n\n\
    \x0b\n\x03\x07P\x05\x12\x04\x81\x06\r\x13\n\x0b\n\x03\x07P\x01\x12\x04\
    \x81\x06\x14+\n\x0b\n\x03\x07P\x03\x12\x04\x81\x0613\n\x0b\n\x03\x07P\
    \x08\x12\x04\x81\x064C\n\x0c\n\x04\x07P\x08\x02\x12\x04\x81\x065B\n\n\n\
    \x02\x07Q\x12\x04\x82\x06\x02D\n\x0b\n\x03\x07Q\x02\x12\x04\xfb\x05\x07\
    \x1b\n\x0b\n\x03\x07Q\x04\x12\x04\x82\x06\x02\n\n\x0b\n\x03\x07Q\x05\x12\
    \x04\x82\x06\x0c\x13\n\x0b\n\x03\x07Q\x01\x12\x04\x82\x06\x14,\n\x0b\n\
    \x03\x07Q\x03\x12\x04\x82\x0613\n\x0b\n\x03\x07Q\x08\x12\x04\x82\x064C\n\
    \x0c\n\x04\x07Q\x08\x02\x12\x04\x82\x065B\n\n\n\x02\x07R\x12\x04\x83\x06\
    \x02D\n\x0b\n\x03\x07R\x02\x12\x04\xfb\x05\x07\x1b\n\x0b\n\x03\x07R\x04\
    \x12\x04\x83\x06\x02\n\n\x0b\n\x03\x07R\x05\x12\x04\x83\x06\x0c\x13\n\
    \x0b\n\x03\x07R\x01\x12\x04\x83\x06\x14,\n\x0b\n\x03\x07R\x03\x12\x04\
    \x83\x0613\n\x0b\n\x03\x07R\x08\x12\x04\x83\x064C\n\x0c\n\x04\x07R\x08\
    \x02\x12\x04\x83\x065B\n\n\n\x02\x07S\x12\x04\x84\x06\x02D\n\x0b\n\x03\
    \x07S\x02\x12\x04\xfb\x05\x07\x1b\n\x0b\n\x03\x07S\x04\x12\x04\x84\x06\
    \x02\n\n\x0b\n\x03\x07S\x05\x12\x04\x84\x06\x0b\x13\n\x0b\n\x03\x07S\x01\
    \x12\x04\x84\x06\x14-\n\x0b\n\x03\x07S\x03\x12\x04\x84\x0613\n\x0b\n\x03\
    \x07S\x08\x12\x04\x84\x064C\n\x0c\n\x04\x07S\x08\x02\x12\x04\x84\x065B\n\
    \n\n\x02\x07T\x12\x04\x85\x06\x02D\n\x0b\n\x03\x07T\x02\x12\x04\xfb\x05\
    \x07\x1b\n\x0b\n\x03\x07T\x04\x12\x04\x85\x06\x02\n\n\x0b\n\x03\x07T\x05\
    \x12\x04\x85\x06\x0b\x13\n\x0b\n\x03\x07T\x01\x12\x04\x85\x06\x14-\n\x0b\
    \n\x03\x07T\x03\x12\x04\x85\x0613\n\x0b\n\x03\x07T\x08\x12\x04\x85\x064C\
    \n\x0c\n\x04\x07T\x08\x02\x12\x04\x85\x065B\n\n\n\x02\x07U\x12\x04\x86\
    \x06\x02D\n\x0b\n\x03\x07U\x02\x12\x04\xfb\x05\x07\x1b\n\x0b\n\x03\x07U\
    \x04\x12\x04\x86\x06\x02\n\n\x0b\n\x03\x07U\x05\x12\x04\x86\x06\x0e\x13\
    \n\x0b\n\x03\x07U\x01\x12\x04\x86\x06\x14*\n\x0b\n\x03\x07U\x03\x12\x04\
    \x86\x0603\n\x0b\n\x03\x07U\x08\x12\x04\x86\x064C\n\x0c\n\x04\x07U\x08\
    \x02\x12\x04\x86\x065B\n\n\n\x02\x07V\x12\x04\x87\x06\x02D\n\x0b\n\x03\
    \x07V\x02\x12\x04\xfb\x05\x07\x1b\n\x0b\n\x03\x07V\x04\x12\x04\x87\x06\
    \x02\n\n\x0b\n\x03\x07V\x05\x12\x04\x87\x06\r\x13\n\x0b\n\x03\x07V\x01\
    \x12\x04\x87\x06\x14+\n\x0b\n\x03\x07V\x03\x12\x04\x87\x0603\n\x0b\n\x03\
    \x07V\x08\x12\x04\x87\x064C\n\x0c\n\x04\x07V\x08\x02\x12\x04\x87\x065B\n\
    \n\n\x02\x07W\x12\x04\x88\x06\x02D\n\x0b\n\x03\x07W\x02\x12\x04\xfb\x05\
    \x07\x1b\n\x0b\n\x03\x07W\x04\x12\x04\x88\x06\x02\n\n\x0b\n\x03\x07W\x05\
    \x12\x04\x88\x06\x0f\x13\n\x0b\n\x03\x07W\x01\x12\x04\x88\x06\x14)\n\x0b\
    \n\x03\x07W\x03\x12\x04\x88\x0603\n\x0b\n\x03\x07W\x08\x12\x04\x88\x064C\
    \n\x0c\n\x04\x07W\x08\x02\x12\x04\x88\x065B\n\n\n\x02\x07X\x12\x04\x89\
    \x06\x02D\n\x0b\n\x03\x07X\x02\x12\x04\xfb\x05\x07\x1b\n\x0b\n\x03\x07X\
    \x04\x12\x04\x89\x06\x02\n\n\x0b\n\x03\x07X\x06\x12\x04\x89\x06\x0b\x16\
    \n\x0b\n\x03\x07X\x01\x12\x04\x89\x06\x17,\n\x0b\n\x03\x07X\x03\x12\x04\
    \x89\x0603\n\x0b\n\x03\x07X\x08\x12\x04\x89\x064C\n\x0c\n\x04\x07X\x08\
    \x02\x12\x04\x89\x065B\n\x0c\n\x02\x04)\x12\x06\x8c\x06\0\x8e\x06\x01\n\
    \x0b\n\x03\x04)\x01\x12\x04\x8c\x06\x08\x1e\n\x0b\n\x03\x04)\x05\x12\x04\
    \x8d\x06\x02\x16\n\x0c\n\x04\x04)\x05\0\x12\x04\x8d\x06\r\x15\n\r\n\x05\
    \x04)\x05\0\x01\x12\x04\x8d\x06\r\x0e\n\r\n\x05\x04)\x05\0\x02\x12\x04\
    \x8d\x06\x12\x15\n\x0b\n\x01\x07\x12\x06\x90\x06\0\x9f\x06\x01\n\n\n\x02\
    \x07Y\x12\x04\x91\x06\x02G\n\x0b\n\x03\x07Y\x02\x12\x04\x90\x06\x07\x1d\
    \n\x0b\n\x03\x07Y\x04\x12\x04\x91\x06\x02\n\n\x0b\n\x03\x07Y\x05\x12\x04\
    \x91\x06\x0e\x13\n\x0b\n\x03\x07Y\x01\x12\x04\x91\x06\x14,\n\x0b\n\x03\
    \x07Y\x03\x12\x04\x91\x0635\n\x0b\n\x03\x07Y\x08\x12\x04\x91\x066F\n\x0c\
    \n\x04\x07Y\x08\x02\x12\x04\x91\x067E\n\n\n\x02\x07Z\x12\x04\x92\x06\x02\
    G\n\x0b\n\x03\x07Z\x02\x12\x04\x90\x06\x07\x1d\n\x0b\n\x03\x07Z\x04\x12\
    \x04\x92\x06\x02\n\n\x0b\n\x03\x07Z\x05\x12\x04\x92\x06\x0e\x13\n\x0b\n\
    \x03\x07Z\x01\x12\x04\x92\x06\x14,\n\x0b\n\x03\x07Z\x03\x12\x04\x92\x063\
    5\n\x0b\n\x03\x07Z\x08\x12\x04\x92\x066F\n\x0c\n\x04\x07Z\x08\x02\x12\
    \x04\x92\x067E\n\n\n\x02\x07[\x12\x04\x93\x06\x02G\n\x0b\n\x03\x07[\x02\
    \x12\x04\x90\x06\x07\x1d\n\x0b\n\x03\x07[\x04\x12\x04\x93\x06\x02\n\n\
    \x0b\n\x03\x07[\x05\x12\x04\x93\x06\r\x13\n\x0b\n\x03\x07[\x01\x12\x04\
    \x93\x06\x14-\n\x0b\n\x03\x07[\x03\x12\x04\x93\x0635\n\x0b\n\x03\x07[\
    \x08\x12\x04\x93\x066F\n\x0c\n\x04\x07[\x08\x02\x12\x04\x93\x067E\n\n\n\
    \x02\x07\\\x12\x04\x94\x06\x02G\n\x0b\n\x03\x07\\\x02\x12\x04\x90\x06\
    \x07\x1d\n\x0b\n\x03\x07\\\x04\x12\x04\x94\x06\x02\n\n\x0b\n\x03\x07\\\
    \x05\x12\x04\x94\x06\r\x13\n\x0b\n\x03\x07\\\x01\x12\x04\x94\x06\x14-\n\
    \x0b\n\x03\x07\\\x03\x12\x04\x94\x0635\n\x0b\n\x03\x07\\\x08\x12\x04\x94\
    \x066F\n\x0c\n\x04\x07\\\x08\x02\x12\x04\x94\x067E\n\n\n\x02\x07]\x12\
    \x04\x95\x06\x02G\n\x0b\n\x03\x07]\x02\x12\x04\x90\x06\x07\x1d\n\x0b\n\
    \x03\x07]\x04\x12\x04\x95\x06\x02\n\n\x0b\n\x03\x07]\x05\x12\x04\x95\x06\
    \r\x13\n\x0b\n\x03\x07]\x01\x12\x04\x95\x06\x14-\n\x0b\n\x03\x07]\x03\
    \x12\x04\x95\x0635\n\x0b\n\x03\x07]\x08\x12\x04\x95\x066F\n\x0c\n\x04\
    \x07]\x08\x02\x12\x04\x95\x067E\n\n\n\x02\x07^\x12\x04\x96\x06\x02G\n\
    \x0b\n\x03\x07^\x02\x12\x04\x90\x06\x07\x1d\n\x0b\n\x03\x07^\x04\x12\x04\
    \x96\x06\x02\n\n\x0b\n\x03\x07^\x05\x12\x04\x96\x06\r\x13\n\x0b\n\x03\
    \x07^\x01\x12\x04\x96\x06\x14-\n\x0b\n\x03\x07^\x03\x12\x04\x96\x0635\n\
    \x0b\n\x03\x07^\x08\x12\x04\x96\x066F\n\x0c\n\x04\x07^\x08\x02\x12\x04\
    \x96\x067E\n\n\n\x02\x07_\x12\x04\x97\x06\x02G\n\x0b\n\x03\x07_\x02\x12\
    \x04\x90\x06\x07\x1d\n\x0b\n\x03\x07_\x04\x12\x04\x97\x06\x02\n\n\x0b\n\
    \x03\x07_\x05\x12\x04\x97\x06\x0c\x13\n\x0b\n\x03\x07_\x01\x12\x04\x97\
    \x06\x14.\n\x0b\n\x03\x07_\x03\x12\x04\x97\x0635\n\x0b\n\x03\x07_\x08\
    \x12\x04\x97\x066F\n\x0c\n\x04\x07_\x08\x02\x12\x04\x97\x067E\n\n\n\x02\
    \x07`\x12\x04\x98\x06\x02G\n\x0b\n\x03\x07`\x02\x12\x04\x90\x06\x07\x1d\
    \n\x0b\n\x03\x07`\x04\x12\x04\x98\x06\x02\n\n\x0b\n\x03\x07`\x05\x12\x04\
    \x98\x06\x0c\x13\n\x0b\n\x03\x07`\x01\x12\x04\x98\x06\x14.\n\x0b\n\x03\
    \x07`\x03\x12\x04\x98\x0635\n\x0b\n\x03\x07`\x08\x12\x04\x98\x066F\n\x0c\
    \n\x04\x07`\x08\x02\x12\x04\x98\x067E\n\n\n\x02\x07a\x12\x04\x99\x06\x02\
    G\n\x0b\n\x03\x07a\x02\x12\x04\x90\x06\x07\x1d\n\x0b\n\x03\x07a\x04\x12\
    \x04\x99\x06\x02\n\n\x0b\n\x03\x07a\x05\x12\x04\x99\x06\x0b\x13\n\x0b\n\
    \x03\x07a\x01\x12\x04\x99\x06\x14/\n\x0b\n\x03\x07a\x03\x12\x04\x99\x063\
    5\n\x0b\n\x03\x07a\x08\x12\x04\x99\x066F\n\x0c\n\x04\x07a\x08\x02\x12\
    \x04\x99\x067E\n\n\n\x02\x07b\x12\x04\x9a\x06\x02G\n\x0b\n\x03\x07b\x02\
    \x12\x04\x90\x06\x07\x1d\n\x0b\n\x03\x07b\x04\x12\x04\x9a\x06\x02\n\n\
    \x0b\n\x03\x07b\x05\x12\x04\x9a\x06\x0b\x13\n\x0b\n\x03\x07b\x01\x12\x04\
    \x9a\x06\x14/\n\x0b\n\x03\x07b\x03\x12\x04\x9a\x0635\n\x0b\n\x03\x07b\
    \x08\x12\x04\x9a\x066F\n\x0c\n\x04\x07b\x08\x02\x12\x04\x9a\x067E\n\n\n\
    \x02\x07c\x12\x04\x9b\x06\x02G\n\x0b\n\x03\x07c\x02\x12\x04\x90\x06\x07\
    \x1d\n\x0b\n\x03\x07c\x04\x12\x04\x9b\x06\x02\n\n\x0b\n\x03\x07c\x05\x12\
    \x04\x9b\x06\x0e\x13\n\x0b\n\x03\x07c\x01\x12\x04\x9b\x06\x14,\n\x0b\n\
    \x03\x07c\x03\x12\x04\x9b\x0625\n\x0b\n\x03\x07c\x08\x12\x04\x9b\x066F\n\
    \x0c\n\x04\x07c\x08\x02\x12\x04\x9b\x067E\n\n\n\x02\x07d\x12\x04\x9c\x06\
    \x02G\n\x0b\n\x03\x07d\x02\x12\x04\x90\x06\x07\x1d\n\x0b\n\x03\x07d\x04\
    \x12\x04\x9c\x06\x02\n\n\x0b\n\x03\x07d\x05\x12\x04\x9c\x06\r\x13\n\x0b\
    \n\x03\x07d\x01\x12\x04\x9c\x06\x14-\n\x0b\n\x03\x07d\x03\x12\x04\x9c\
    \x0625\n\x0b\n\x03\x07d\x08\x12\x04\x9c\x066F\n\x0c\n\x04\x07d\x08\x02\
    \x12\x04\x9c\x067E\n\n\n\x02\x07e\x12\x04\x9d\x06\x02G\n\x0b\n\x03\x07e\
    \x02\x12\x04\x90\x06\x07\x1d\n\x0b\n\x03\x07e\x04\x12\x04\x9d\x06\x02\n\
    \n\x0b\n\x03\x07e\x05\x12\x04\x9d\x06\x0f\x13\n\x0b\n\x03\x07e\x01\x12\
    \x04\x9d\x06\x14+\n\x0b\n\x03\x07e\x03\x12\x04\x9d\x0625\n\x0b\n\x03\x07\
    e\x08\x12\x04\x9d\x066F\n\x0c\n\x04\x07e\x08\x02\x12\x04\x9d\x067E\n\n\n\
    \x02\x07f\x12\x04\x9e\x06\x02G\n\x0b\n\x03\x07f\x02\x12\x04\x90\x06\x07\
    \x1d\n\x0b\n\x03\x07f\x04\x12\x04\x9e\x06\x02\n\n\x0b\n\x03\x07f\x06\x12\
    \x04\x9e\x06\x0b\x16\n\x0b\n\x03\x07f\x01\x12\x04\x9e\x06\x17.\n\x0b\n\
    \x03\x07f\x03\x12\x04\x9e\x0625\n\x0b\n\x03\x07f\x08\x12\x04\x9e\x066F\n\
    \x0c\n\x04\x07f\x08\x02\x12\x04\x9e\x067E\n\xb8\x01\n\x02\x04*\x12\x06\
    \xa4\x06\0\xb7\x06\x01\x1a\xa9\x01\x20Used\x20by\x20ExtensionSetTest/Dyn\
    amicExtensions.\x20\x20The\x20test\x20actually\x20builds\n\x20a\x20set\
    \x20of\x20extensions\x20to\x20TestAllExtensions\x20dynamically,\x20based\
    \x20on\x20the\x20fields\n\x20of\x20this\x20message\x20type.\n\n\x0b\n\
    \x03\x04*\x01\x12\x04\xa4\x06\x08\x1d\n\x0e\n\x04\x04*\x04\0\x12\x06\xa5\
    \x06\x02\xa9\x06\x03\n\r\n\x05\x04*\x04\0\x01\x12\x04\xa5\x06\x07\x16\n\
    \x0e\n\x06\x04*\x04\0\x02\0\x12\x04\xa6\x06\x04\x17\n\x0f\n\x07\x04*\x04\
    \0\x02\0\x01\x12\x04\xa6\x06\x04\x0f\n\x0f\n\x07\x04*\x04\0\x02\0\x02\
    \x12\x04\xa6\x06\x12\x16\n\x0e\n\x06\x04*\x04\0\x02\x01\x12\x04\xa7\x06\
    \x04\x17\n\x0f\n\x07\x04*\x04\0\x02\x01\x01\x12\x04\xa7\x06\x04\x0f\n\
    \x0f\n\x07\x04*\x04\0\x02\x01\x02\x12\x04\xa7\x06\x12\x16\n\x0e\n\x06\
    \x04*\x04\0\x02\x02\x12\x04\xa8\x06\x04\x17\n\x0f\n\x07\x04*\x04\0\x02\
    \x02\x01\x12\x04\xa8\x06\x04\x0f\n\x0f\n\x07\x04*\x04\0\x02\x02\x02\x12\
    \x04\xa8\x06\x12\x16\n\x0e\n\x04\x04*\x03\0\x12\x06\xaa\x06\x02\xac\x06\
    \x03\n\r\n\x05\x04*\x03\0\x01\x12\x04\xaa\x06\n\x1c\n\x0e\n\x06\x04*\x03\
    \0\x02\0\x12\x04\xab\x06\x04(\n\x0f\n\x07\x04*\x03\0\x02\0\x04\x12\x04\
    \xab\x06\x04\x0c\n\x0f\n\x07\x04*\x03\0\x02\0\x05\x12\x04\xab\x06\r\x12\
    \n\x0f\n\x07\x04*\x03\0\x02\0\x01\x12\x04\xab\x06\x13\x20\n\x0f\n\x07\
    \x04*\x03\0\x02\0\x03\x12\x04\xab\x06#'\n\x0c\n\x04\x04*\x02\0\x12\x04\
    \xae\x06\x02+\n\r\n\x05\x04*\x02\0\x04\x12\x04\xae\x06\x02\n\n\r\n\x05\
    \x04*\x02\0\x05\x12\x04\xae\x06\x0b\x12\n\r\n\x05\x04*\x02\0\x01\x12\x04\
    \xae\x06\x13#\n\r\n\x05\x04*\x02\0\x03\x12\x04\xae\x06&*\n\x0c\n\x04\x04\
    *\x02\x01\x12\x04\xaf\x06\x02-\n\r\n\x05\x04*\x02\x01\x04\x12\x04\xaf\
    \x06\x02\n\n\r\n\x05\x04*\x02\x01\x06\x12\x04\xaf\x06\x0b\x16\n\r\n\x05\
    \x04*\x02\x01\x01\x12\x04\xaf\x06\x17%\n\r\n\x05\x04*\x02\x01\x03\x12\
    \x04\xaf\x06(,\n\x0c\n\x04\x04*\x02\x02\x12\x04\xb0\x06\x029\n\r\n\x05\
    \x04*\x02\x02\x04\x12\x04\xb0\x06\x02\n\n\r\n\x05\x04*\x02\x02\x06\x12\
    \x04\xb0\x06\x0b\x1a\n\r\n\x05\x04*\x02\x02\x01\x12\x04\xb0\x06\x1b1\n\r\
    \n\x05\x04*\x02\x02\x03\x12\x04\xb0\x0648\n\x0c\n\x04\x04*\x02\x03\x12\
    \x04\xb2\x06\x023\n\r\n\x05\x04*\x02\x03\x04\x12\x04\xb2\x06\x02\n\n\r\n\
    \x05\x04*\x02\x03\x06\x12\x04\xb2\x06\x0b\x19\n\r\n\x05\x04*\x02\x03\x01\
    \x12\x04\xb2\x06\x1a+\n\r\n\x05\x04*\x02\x03\x03\x12\x04\xb2\x06.2\n\x0c\
    \n\x04\x04*\x02\x04\x12\x04\xb3\x06\x02?\n\r\n\x05\x04*\x02\x04\x04\x12\
    \x04\xb3\x06\x02\n\n\r\n\x05\x04*\x02\x04\x06\x12\x04\xb3\x06\x0b\x1d\n\
    \r\n\x05\x04*\x02\x04\x01\x12\x04\xb3\x06\x1e7\n\r\n\x05\x04*\x02\x04\
    \x03\x12\x04\xb3\x06:>\n\x0c\n\x04\x04*\x02\x05\x12\x04\xb5\x06\x02,\n\r\
    \n\x05\x04*\x02\x05\x04\x12\x04\xb5\x06\x02\n\n\r\n\x05\x04*\x02\x05\x05\
    \x12\x04\xb5\x06\x0b\x11\n\r\n\x05\x04*\x02\x05\x01\x12\x04\xb5\x06\x12$\
    \n\r\n\x05\x04*\x02\x05\x03\x12\x04\xb5\x06'+\n\x0c\n\x04\x04*\x02\x06\
    \x12\x04\xb6\x06\x02:\n\r\n\x05\x04*\x02\x06\x04\x12\x04\xb6\x06\x02\n\n\
    \r\n\x05\x04*\x02\x06\x05\x12\x04\xb6\x06\x0b\x11\n\r\n\x05\x04*\x02\x06\
    \x01\x12\x04\xb6\x06\x12\"\n\r\n\x05\x04*\x02\x06\x03\x12\x04\xb6\x06%)\
    \n\r\n\x05\x04*\x02\x06\x08\x12\x04\xb6\x06*9\n\x0e\n\x06\x04*\x02\x06\
    \x08\x02\x12\x04\xb6\x06+8\n\x0c\n\x02\x04+\x12\x06\xb9\x06\0\xc8\x06\
    \x01\n\x0b\n\x03\x04+\x01\x12\x04\xb9\x06\x08+\n\xcf\x01\n\x04\x04+\x02\
    \0\x12\x04\xbd\x06\x02)\x1a\xc0\x01\x20Parsing\x20repeated\x20fixed\x20s\
    ize\x20values\x20used\x20to\x20fail.\x20This\x20message\x20needs\x20to\
    \x20be\n\x20used\x20in\x20order\x20to\x20get\x20a\x20tag\x20of\x20the\
    \x20right\x20size;\x20all\x20of\x20the\x20repeated\x20fields\n\x20in\x20\
    TestAllTypes\x20didn't\x20trigger\x20the\x20check.\n\n\r\n\x05\x04+\x02\
    \0\x04\x12\x04\xbd\x06\x02\n\n\r\n\x05\x04+\x02\0\x05\x12\x04\xbd\x06\
    \x0b\x12\n\r\n\x05\x04+\x02\0\x01\x12\x04\xbd\x06\x13#\n\r\n\x05\x04+\
    \x02\0\x03\x12\x04\xbd\x06&(\n?\n\x04\x04+\x02\x01\x12\x04\xbf\x06\x02)\
    \x1a1\x20Check\x20for\x20a\x20varint\x20type,\x20just\x20for\x20good\x20\
    measure.\n\n\r\n\x05\x04+\x02\x01\x04\x12\x04\xbf\x06\x02\n\n\r\n\x05\
    \x04+\x02\x01\x05\x12\x04\xbf\x06\x0b\x10\n\r\n\x05\x04+\x02\x01\x01\x12\
    \x04\xbf\x06\x13!\n\r\n\x05\x04+\x02\x01\x03\x12\x04\xbf\x06&(\n)\n\x04\
    \x04+\x02\x02\x12\x04\xc2\x06\x02+\x1a\x1b\x20These\x20have\x20two-byte\
    \x20tags.\n\n\r\n\x05\x04+\x02\x02\x04\x12\x04\xc2\x06\x02\n\n\r\n\x05\
    \x04+\x02\x02\x05\x12\x04\xc2\x06\x0b\x12\n\r\n\x05\x04+\x02\x02\x01\x12\
    \x04\xc2\x06\x13#\n\r\n\x05\x04+\x02\x02\x03\x12\x04\xc2\x06&*\n\x0c\n\
    \x04\x04+\x02\x03\x12\x04\xc3\x06\x02+\n\r\n\x05\x04+\x02\x03\x04\x12\
    \x04\xc3\x06\x02\n\n\r\n\x05\x04+\x02\x03\x05\x12\x04\xc3\x06\x0b\x10\n\
    \r\n\x05\x04+\x02\x03\x01\x12\x04\xc3\x06\x13!\n\r\n\x05\x04+\x02\x03\
    \x03\x12\x04\xc3\x06&*\n\x20\n\x04\x04+\x02\x04\x12\x04\xc6\x06\x02-\x1a\
    \x12\x20Three\x20byte\x20tags.\n\n\r\n\x05\x04+\x02\x04\x04\x12\x04\xc6\
    \x06\x02\n\n\r\n\x05\x04+\x02\x04\x05\x12\x04\xc6\x06\x0b\x10\n\r\n\x05\
    \x04+\x02\x04\x01\x12\x04\xc6\x06\x13!\n\r\n\x05\x04+\x02\x04\x03\x12\
    \x04\xc6\x06&,\n\x0c\n\x04\x04+\x02\x05\x12\x04\xc7\x06\x02-\n\r\n\x05\
    \x04+\x02\x05\x04\x12\x04\xc7\x06\x02\n\n\r\n\x05\x04+\x02\x05\x05\x12\
    \x04\xc7\x06\x0b\x11\n\r\n\x05\x04+\x02\x05\x01\x12\x04\xc7\x06\x13\"\n\
    \r\n\x05\x04+\x02\x05\x03\x12\x04\xc7\x06&,\n\x86\x01\n\x02\x04,\x12\x06\
    \xcc\x06\0\xf1\x06\x01\x1ax\x20Test\x20that\x20if\x20an\x20optional\x20o\
    r\x20required\x20message/group\x20field\x20appears\x20multiple\n\x20time\
    s\x20in\x20the\x20input,\x20they\x20need\x20to\x20be\x20merged.\n\n\x0b\
    \n\x03\x04,\x01\x12\x04\xcc\x06\x08\x18\n\xfe\x02\n\x04\x04,\x03\0\x12\
    \x06\xd2\x06\x02\xe0\x06\x03\x1a\xed\x02\x20RepeatedFieldsGenerator\x20d\
    efines\x20matching\x20field\x20types\x20as\x20TestParsingMerge,\n\x20exc\
    ept\x20that\x20all\x20fields\x20are\x20repeated.\x20In\x20the\x20tests,\
    \x20we\x20will\x20serialize\x20the\n\x20RepeatedFieldsGenerator\x20to\
    \x20bytes,\x20and\x20parse\x20the\x20bytes\x20to\x20TestParsingMerge.\n\
    \x20Repeated\x20fields\x20in\x20RepeatedFieldsGenerator\x20are\x20expect\
    ed\x20to\x20be\x20merged\x20into\n\x20the\x20corresponding\x20required/o\
    ptional\x20fields\x20in\x20TestParsingMerge.\n\n\r\n\x05\x04,\x03\0\x01\
    \x12\x04\xd2\x06\n!\n\x0e\n\x06\x04,\x03\0\x02\0\x12\x04\xd3\x06\x04%\n\
    \x0f\n\x07\x04,\x03\0\x02\0\x04\x12\x04\xd3\x06\x04\x0c\n\x0f\n\x07\x04,\
    \x03\0\x02\0\x06\x12\x04\xd3\x06\r\x19\n\x0f\n\x07\x04,\x03\0\x02\0\x01\
    \x12\x04\xd3\x06\x1a\x20\n\x0f\n\x07\x04,\x03\0\x02\0\x03\x12\x04\xd3\
    \x06#$\n\x0e\n\x06\x04,\x03\0\x02\x01\x12\x04\xd4\x06\x04%\n\x0f\n\x07\
    \x04,\x03\0\x02\x01\x04\x12\x04\xd4\x06\x04\x0c\n\x0f\n\x07\x04,\x03\0\
    \x02\x01\x06\x12\x04\xd4\x06\r\x19\n\x0f\n\x07\x04,\x03\0\x02\x01\x01\
    \x12\x04\xd4\x06\x1a\x20\n\x0f\n\x07\x04,\x03\0\x02\x01\x03\x12\x04\xd4\
    \x06#$\n\x0e\n\x06\x04,\x03\0\x02\x02\x12\x04\xd5\x06\x04%\n\x0f\n\x07\
    \x04,\x03\0\x02\x02\x04\x12\x04\xd5\x06\x04\x0c\n\x0f\n\x07\x04,\x03\0\
    \x02\x02\x06\x12\x04\xd5\x06\r\x19\n\x0f\n\x07\x04,\x03\0\x02\x02\x01\
    \x12\x04\xd5\x06\x1a\x20\n\x0f\n\x07\x04,\x03\0\x02\x02\x03\x12\x04\xd5\
    \x06#$\n\x96\x01\n\x06\x04,\x03\0\x02\x03\x12\x04\xde\x06\x04&\x1a\x85\
    \x01\nrepeated\x20group\x20Group1\x20=\x2010\x20{\noptional\x20TestAllTy\
    pes\x20field1\x20=\x2011;\n}\nrepeated\x20group\x20Group2\x20=\x2020\x20\
    {\noptional\x20TestAllTypes\x20field1\x20=\x2021;\n}\n\n\x0f\n\x07\x04,\
    \x03\0\x02\x03\x04\x12\x04\xde\x06\x04\x0c\n\x0f\n\x07\x04,\x03\0\x02\
    \x03\x06\x12\x04\xde\x06\r\x19\n\x0f\n\x07\x04,\x03\0\x02\x03\x01\x12\
    \x04\xde\x06\x1a\x1e\n\x0f\n\x07\x04,\x03\0\x02\x03\x03\x12\x04\xde\x06!\
    %\n\x0e\n\x06\x04,\x03\0\x02\x04\x12\x04\xdf\x06\x04&\n\x0f\n\x07\x04,\
    \x03\0\x02\x04\x04\x12\x04\xdf\x06\x04\x0c\n\x0f\n\x07\x04,\x03\0\x02\
    \x04\x06\x12\x04\xdf\x06\r\x19\n\x0f\n\x07\x04,\x03\0\x02\x04\x01\x12\
    \x04\xdf\x06\x1a\x1e\n\x0f\n\x07\x04,\x03\0\x02\x04\x03\x12\x04\xdf\x06!\
    %\n\x0c\n\x04\x04,\x02\0\x12\x04\xe1\x06\x02/\n\r\n\x05\x04,\x02\0\x04\
    \x12\x04\xe1\x06\x02\n\n\r\n\x05\x04,\x02\0\x06\x12\x04\xe1\x06\x0b\x17\
    \n\r\n\x05\x04,\x02\0\x01\x12\x04\xe1\x06\x18*\n\r\n\x05\x04,\x02\0\x03\
    \x12\x04\xe1\x06-.\n\x0c\n\x04\x04,\x02\x01\x12\x04\xe2\x06\x02/\n\r\n\
    \x05\x04,\x02\x01\x04\x12\x04\xe2\x06\x02\n\n\r\n\x05\x04,\x02\x01\x06\
    \x12\x04\xe2\x06\x0b\x17\n\r\n\x05\x04,\x02\x01\x01\x12\x04\xe2\x06\x18*\
    \n\r\n\x05\x04,\x02\x01\x03\x12\x04\xe2\x06-.\n\x0c\n\x04\x04,\x02\x02\
    \x12\x04\xe3\x06\x02/\n\r\n\x05\x04,\x02\x02\x04\x12\x04\xe3\x06\x02\n\n\
    \r\n\x05\x04,\x02\x02\x06\x12\x04\xe3\x06\x0b\x17\n\r\n\x05\x04,\x02\x02\
    \x01\x12\x04\xe3\x06\x18*\n\r\n\x05\x04,\x02\x02\x03\x12\x04\xe3\x06-.\n\
    \xc5\x01\n\x03\x04,\x05\x12\x04\xec\x06\x02\x19\x1a\xb7\x01\noptional\
    \x20group\x20OptionalGroup\x20=\x2010\x20{\noptional\x20TestAllTypes\x20\
    optional_group_all_types\x20=\x2011;\n}\nrepeated\x20group\x20RepeatedGr\
    oup\x20=\x2020\x20{\noptional\x20TestAllTypes\x20repeated_group_all_type\
    s\x20=\x2021;\n}\n\n\x0c\n\x04\x04,\x05\0\x12\x04\xec\x06\r\x18\n\r\n\
    \x05\x04,\x05\0\x01\x12\x04\xec\x06\r\x11\n\r\n\x05\x04,\x05\0\x02\x12\
    \x04\xec\x06\x15\x18\n\r\n\x03\x04,\x06\x12\x06\xed\x06\x02\xf0\x06\x03\
    \n\x0c\n\x04\x04,\x06\0\x12\x04\xee\x06\x04.\n\r\n\x05\x04,\x06\0\x02\
    \x12\x04\xed\x06\t\x19\n\r\n\x05\x04,\x06\0\x04\x12\x04\xee\x06\x04\x0c\
    \n\r\n\x05\x04,\x06\0\x06\x12\x04\xee\x06\r\x19\n\r\n\x05\x04,\x06\0\x01\
    \x12\x04\xee\x06\x1a&\n\r\n\x05\x04,\x06\0\x03\x12\x04\xee\x06)-\n\x0c\n\
    \x04\x04,\x06\x01\x12\x04\xef\x06\x04.\n\r\n\x05\x04,\x06\x01\x02\x12\
    \x04\xed\x06\t\x19\n\r\n\x05\x04,\x06\x01\x04\x12\x04\xef\x06\x04\x0c\n\
    \r\n\x05\x04,\x06\x01\x06\x12\x04\xef\x06\r\x19\n\r\n\x05\x04,\x06\x01\
    \x01\x12\x04\xef\x06\x1a&\n\r\n\x05\x04,\x06\x01\x03\x12\x04\xef\x06)-\n\
    \x0c\n\x02\x04-\x12\x06\xf3\x06\0\xf6\x06\x01\n\x0b\n\x03\x04-\x01\x12\
    \x04\xf3\x06\x08#\nE\n\x04\x04-\x02\0\x12\x04\xf5\x06\x02?\x1a7\x20*/\
    \x20<-\x20This\x20should\x20not\x20close\x20the\x20generated\x20doc\x20c\
    omment\n\n\r\n\x05\x04-\x02\0\x04\x12\x04\xf5\x06\x02\n\n\r\n\x05\x04-\
    \x02\0\x05\x12\x04\xf5\x06\x0b\x11\n\r\n\x05\x04-\x02\0\x01\x12\x04\xf5\
    \x06\x12\x13\n\r\n\x05\x04-\x02\0\x03\x12\x04\xf5\x06\x16\x17\n\r\n\x05\
    \x04-\x02\0\x08\x12\x04\xf5\x06\x18>\n\r\n\x05\x04-\x02\0\x07\x12\x04\
    \xf5\x06!=\n*\n\x02\x04.\x12\x04\xfa\x06\0\x16\x1a\x1e\x20Test\x20that\
    \x20RPC\x20services\x20work.\n\n\x0b\n\x03\x04.\x01\x12\x04\xfa\x06\x08\
    \x12\n\n\n\x02\x04/\x12\x04\xfb\x06\0\x16\n\x0b\n\x03\x04/\x01\x12\x04\
    \xfb\x06\x08\x13\n\n\n\x02\x040\x12\x04\xfd\x06\0\x1b\n\x0b\n\x03\x040\
    \x01\x12\x04\xfd\x06\x08\x18\n\n\n\x02\x041\x12\x04\xfe\x06\0\x1a\n\x0b\
    \n\x03\x041\x01\x12\x04\xfe\x06\x08\x18\n\x0c\n\x02\x06\0\x12\x06\x80\
    \x07\0\x83\x07\x01\n\x0b\n\x03\x06\0\x01\x12\x04\x80\x07\x08\x13\n\x0c\n\
    \x04\x06\0\x02\0\x12\x04\x81\x07\x02,\n\r\n\x05\x06\0\x02\0\x01\x12\x04\
    \x81\x07\x06\t\n\r\n\x05\x06\0\x02\0\x02\x12\x04\x81\x07\n\x14\n\r\n\x05\
    \x06\0\x02\0\x03\x12\x04\x81\x07\x1f*\n\x0c\n\x04\x06\0\x02\x01\x12\x04\
    \x82\x07\x02,\n\r\n\x05\x06\0\x02\x01\x01\x12\x04\x82\x07\x06\t\n\r\n\
    \x05\x06\0\x02\x01\x02\x12\x04\x82\x07\n\x14\n\r\n\x05\x06\0\x02\x01\x03\
    \x12\x04\x82\x07\x1f*\n\n\n\x02\x042\x12\x04\x86\x07\0\x16\n\x0b\n\x03\
    \x042\x01\x12\x04\x86\x07\x08\x12\n\n\n\x02\x043\x12\x04\x87\x07\0\x16\n\
    \x0b\n\x03\x043\x01\x12\x04\x87\x07\x08\x13\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
